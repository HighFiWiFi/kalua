#!/bin/sh

# filename: 	/tmp/2008aug8-username-00:11:22:33:44:55.ulog
#
#		direction time ip port proto id seq ack
# 		> 11:35:41 212.58.226.33 80 TCP 10415 3248578720 0
# 		< 11:35:41 212.58.226.33 80 TCP 0 1694259892 3248578721
# 		< 11:35:47 212.58.226.33 80 TCP 33278 1694279284 3248579419
# 		< 11:35:56 212.58.226.33 80 TCP 10434 3248579419 1694279285
#
#		fixme! 11:35:56 -> unixtime?
#
# example-shot:     92.750 bytes |  337 lines (~273 bytes) ->  18985 bytes in 86sec (-> 20%) -> gzip -> 4000 bytes (-> 21%/4.3% overall)
# extrapolation: 2.000.000 bytes | 7272 lines              -> 80.000 bytes / user / day

. /bin/needs base vars_old log

ULOG_LOGFILE_ORIG="/var/log/ulogd.syslogemu"
ULOG_LOGFILE="/var/log/ulogd.syslogemu_working_copy"
VDS_PATH="/tmp"

func_ulog_prepare ()
{
	local FUNC="ulog_prepare"
	local PID_ULOG="$( pidof ulogd )"
	
	[ -z "$PID_ULOG" -a -e /usr/sbin/ulogd ] && {
		_log do $FUNC daemon debug "ulogd inactive - starting up"
		
		ulogd -d || {
			_log do $FUNC daemon debug "ulogd-startup failed"
			return 1		# needs correct /etc/ulogd.conf !
		}
			
		PID_ULOG="$( pidof ulogd )"
		_log do $FUNC daemon debug "ulogd-startup successful"
	}
	
	[ ! -e $ULOG_LOGFILE_ORIG ]			&& return 1
	[ ! -e /tmp/USER_PACKETFILTER ]			&& return 1	# no packetfilter, no logfile?
	[ $(func_filesize $ULOG_LOGFILE_ORIG) -eq 0 ]	&& return 1

	_log do $FUNC daemon debug "creating logfile working copy"
	
	mv $ULOG_LOGFILE_ORIG $ULOG_LOGFILE
	kill -HUP $PID_ULOG			# logfile touching not needed

	_log do $FUNC daemon debug "created"

	return 0
}

func_ulog_sqeeze_log ()
{
	local FUNC="ulog_sqeeze_log"
	local DATE="$( _system date humanreadable short )"
	local BYTES="$( func_filesize $ULOG_LOGFILE )"
	local LINES="$( func_file_lines $ULOG_LOGFILE )"
	local NODEID="$( nvram get fff_node_number )"

	_log do $FUNC daemon debug "parsing now $BYTES bytes / $LINES lines"	

	# local FLAGS="| ACK:$FLAG_ACK SYN:$FLAG_SYN RST:$FLAG_RST FIN:$FLAG_FIN PSH:$FLAG_PSH URGP:$URGP"
	local LINE
	local FLAGS
	local PORT
	local IP
	local OUTPUT
	local COUNTER=0

	local TIME
	local MAC
	local DIR
	local SRC
	local DST
	local ID
	local PROTO
	local SPT
	local DPT
	local SEQ
	local ACK
	local WINDOW
	local FLAG_ACK
	local FLAG_SYN
	local FLAG_RST
	local FLAG_FIN
	local FLAG_PSH
	local URGP

	while read LINE; do {		# func_ulog_make_evalable "$LINE" >>/tmp/vds_debug

		eval $( func_ulog_make_evalable "$LINE" )
	
		if grep -q ^"${DST};" "$CLIENTS_LAN" "$CLIENTS_WIFI" ; then
			IP=$SRC
			PORT=$SPT
			USERIP=$DST
		else
			PORT=$DPT
			IP=$DST
			USERIP=$SRC
		fi

		USERNAME="$( cat /tmp/vds_user_$MAC 2>/dev/null )"
		OUTPUT="$DIR $TIME $IP $PORT $PROTO $ID $SEQ $ACK"
		COUNTER=$(( $COUNTER + ${#OUTPUT} ))			# count bytes for logfile
		
		echo >>"${VDS_PATH}/user-${USERNAME:-unknown}-${MAC}-${USERIP:-noip}-${DATE}-${NODEID}.ulog" "$OUTPUT"

		# > 11:35:41 212.58.226.33 80 TCP 10415 3248578720 0
		# < 11:35:41 212.58.226.33 80 TCP 0 1694259892 3248578721
		# < 11:35:47 212.58.226.33 80 TCP 33278 1694279284 3248579419
		# < 11:35:56 212.58.226.33 80 TCP 10434 3248579419 1694279285

	} done <$ULOG_LOGFILE

	rm $ULOG_LOGFILE
	_log do $FUNC daemon debug "squeezed to $(( $COUNTER * 100 / ${BYTES:=1} ))% ($COUNTER bytes)"
}

func_ulog_make_evalable ()
{
	# Input is like: (no space, all in one line)

	# Mar  9 23:21:29 node408ap 00:04:75:f8:ed:67< IN=eth2 OUT=br0 MAC=00:90:4b:87:82:d5:00:04:75:f8:ed:67:08:00
	# SRC=10.63.153.66 DST=212.79.62.105 LEN=52 TOS=00 PREC=0x00 TTL=63 ID=26975 DF PROTO=TCP SPT=39952 DPT=80
	# SEQ=3144651213 ACK=3259829088 WINDOW=4340 ACK FIN URGP=0

	# Mar 10 11:18:17 liszt28 00:02:2d:2d:8a:54< IN=vlan1 OUT=eth1 MAC=00:1d:73:05:0f:58:00:1c:4a:89:b6:17:08:00:45:00:00:34
	# SRC=74.125.39.104 DST=10.63.167.70 LEN=52 TOS=00 PREC=0x00 TTL=55 ID=49744 CE PROTO=TCP SPT=80 DPT=32908
	# SEQ=4275812248 ACK=2185052976 WINDOW=135 ACK FIN URGP=0 

	# Mar 10 11:18:21 liszt28 00:02:2d:2d:8a:54< IN=eth1 OUT=vlan1 MAC=00:1d:73:05:0f:59:00:02:2d:2d:8a:54:08:00
	# SRC=10.63.167.70 DST=74.125.39.104 LEN=52 TOS=00 PREC=0x00 TTL=63 ID=37032 CE DF PROTO=TCP SPT=32908 DPT=80
	# SEQ=2185052976 ACK=4275812249 WINDOW=25524 ACK FIN URGP=0 

	echo "$1" | sed -ne 's/^[a-zA-Z]* *[0-9]* \([0-9][0-9]:[0-9][0-9]:[0-9][0-9]\).*\([0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]\)\(.\) .* SRC=\([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) DST=\([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .* ID=\([0-9]*\).*PROTO=\(.*\)$/TIME=\1;MAC=\2;DIR="\3";SRC=\4;DST=\5;ID=\6;PROTO=\7/' \
	                 -e 'y/ /;/' \
	                 -e 's/;ACK;/;FLAG_ACK=1;/' \
	                 -e 's/;SYN;/;FLAG_SYN=1;/' \
	                 -e 's/;RST;/;FLAG_RST=1;/' \
			 -e 's/;FIN;/;FLAG_FIN=1;/' \
			 -e 's/;PSH;/;FLAG_PSH=1;/' \
			 -e 'p'

	# Output is like: (no spaces, all in one line)

	# TIME=11:18:17; MAC=00:02:2d:2d:8a:54; DIR="<"; SRC=74.125.39.104; DST=10.63.167.70; ID=49744; PROTO=TCP;
	# SPT=80; DPT=32908; SEQ=4275812248; ACK=2185052976; WINDOW=135; FLAG_ACK=1; FLAG_FIN=1; URGP=0
	
	# TIME=11:18:21; MAC=00:02:2d:2d:8a:54; DIR="<"; SRC=10.63.167.70; DST=74.125.39.104; ID=37032; PROTO=TCP;
	# SPT=32908; DPT=80; SEQ=2185052976; ACK=4275812249; WINDOW=25524; FLAG_ACK=1; FLAG_FIN=1; URGP=0
}

func_ulog_logsaving ()
{
	local FUNC="ulog_logsaving"
	local PATTERN="${VDS_PATH}/user-*"
	local TODAY="$( _system date humanreadable short )"
	local COPYCOMMAND
	local DESTINATION
	local FILELIST="$( find $PATTERN -type f )"
	local FILE FILESIZE
	local LOGPRIO="alert" 

	[ -e /tmp/ERROR_VDS ] && LOGPRIO="info"

	[ -z "$FILELIST" ] && {
		_log do $FUNC daemon debug "no logs - abort"
		return
	}

	. /tmp/NETPARAM
	eval "$( tail -n1 archiv_trace_inet_gateway_fff+ )"

	if [ "$GW" = "$WIFIADR" ]; then					# fixme! make this check at 1st, and abort if low flash, safes cpu-power
		_log do $FUNC daemon debug "gateway = myself"
		COPYCOMMAND="cp -p"
		DESTINATION="$( func_system_get_storage_path )"		# e.g. /www/cgi-bin

		[ "$DESTINATION" = "/www/cgi-bin" ] && [ "$(func_system_flash_free)" -lt 200 ] && {
			_log do $FUNC daemon $LOGPRIO "low_flash: $(func_system_flash_free)kb - aborting"
			touch /tmp/ERROR_VDS
			exit 1
		}			# fixme! remove VDS-data from RAM? or copy to /dev/null?
	else
		_log do $FUNC daemon debug "gateway = '$GW'"
		COPYCOMMAND="scp -p -i $HOME/.ssh/dropbear_dss_host_key"	# fixme! -B (batchmode) -C (compression) -q (quiet)
		DESTINATION="${GW}:${VDS_PATH}"
	fi

	for FILE in $FILELIST; do {

		FILESIZE="$( func_filesize "$FILE" )"

		if $COPYCOMMAND "$FILE" $DESTINATION ; then			# fixme! only copy to lokal, if not existent
			if echo "$FILE" | grep -q "$TODAY" ; then
				_log do $FUNC daemon info "copying '$FILE' ($FILESIZE bytes) was successful (is from today)"
			else
				_log do $FUNC daemon info "copying '$FILE' ($FILESIZE bytes) was successful - removing"
				rm "$FILE"
			fi
			
			[ -e /tmp/ERROR_VDS ] && rm /tmp/ERROR_VDS
		else	
			_log do $FUNC daemon $LOGPRIO "copying '$FILE' ($FILESIZE bytes) failed"
			touch /tmp/ERROR_VDS
		fi
		
		sync		# if destination is USB-stick, then be sure that all data was written
	} done
}

func_ulog_prepare && func_ulog_sqeeze_log
func_ulog_logsaving

