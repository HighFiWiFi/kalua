#!/bin/sh
. /tmp/loader

# filename: 	/tmp/2008aug8-username-00:11:22:33:44:55.ulog
#
#		direction time ip port proto id seq ack
# 		> 11:35:41 212.58.226.33 80 TCP 10415 3248578720 0
# 		< 11:35:41 212.58.226.33 80 TCP 0 1694259892 3248578721
# 		< 11:35:47 212.58.226.33 80 TCP 33278 1694279284 3248579419
# 		< 11:35:56 212.58.226.33 80 TCP 10434 3248579419 1694279285
#
#		fixme! 11:35:56 -> unixtime?
#
# example-shot:     92.750 bytes |  337 lines (~273 bytes) ->  18985 bytes in 86sec (-> 20%) -> gzip -> 4000 bytes (-> 21%/4.3% overall)
# extrapolation: 2.000.000 bytes | 7272 lines              -> 80.000 bytes / user / day

ULOG_LOGFILE_ORIG="/var/log/ulogd.syslogemu"
ULOG_LOGFILE="/var/log/ulogd.syslogemu_working_copy"
VDS_PATH="/tmp"

func_ulog_prepare ()
{
	local FUNC="ulog_prepare"
	local PID_ULOG="$( pidof ulogd )"
	
	[ -z "$PID_ULOG" -a -e /usr/sbin/ulogd ] && {
		_log do $FUNC daemon debug "ulogd inactive - starting up"
		
		ulogd -d || {
			_log do $FUNC daemon debug "ulogd-startup failed"
			return 1		# needs correct /etc/ulogd.conf !
		}
			
		PID_ULOG="$( pidof ulogd )"
		_log do $FUNC daemon debug "ulogd-startup successful"
	}
	
	[ ! -e $ULOG_LOGFILE_ORIG ]			&& return 1
	[ ! -e /tmp/USER_PACKETFILTER ]			&& return 1	# no packetfilter, no logfile?
	[ $(_file size $ULOG_LOGFILE_ORIG) -eq 0 ]	&& return 1

	_log do $FUNC daemon debug "creating logfile working copy"
	
	mv $ULOG_LOGFILE_ORIG $ULOG_LOGFILE
	kill -HUP $PID_ULOG			# logfile touching not needed

	_log do $FUNC daemon debug "created"

	return 0
}

func_ulog_sqeeze_log ()
{
	local FUNC="ulog_sqeeze_log"
	local DATE="$( _system date humanreadable short )"
	local BYTES="$( _file size $ULOG_LOGFILE )"
	local LINES="$( _file lines $ULOG_LOGFILE )"
	local NODEID="$( nvram get fff_node_number )"
	local REBOOTS="$( cat /www/REBOOT_COUNTER )"

	_log do $FUNC daemon debug "parsing now $BYTES bytes / $LINES lines"	

	# local FLAGS="| ACK:$FLAG_ACK SYN:$FLAG_SYN RST:$FLAG_RST FIN:$FLAG_FIN PSH:$FLAG_PSH URGP:$URGP"
	local LINE
	local FLAGS
	local PORT
	local IP
	local OUTPUT
	local COUNTER=0
					# fixme! fetch conn_length from conntrack when connection was closed
	local TIME
	local MAC
	local DIR
	local SRC
	local DST
	local ID
	local PROTO
	local SPT
	local DPT
	local SEQ
	local ACK
	local WINDOW
	local FLAG_ACK
	local FLAG_SYN
	local FLAG_RST
	local FLAG_FIN
	local FLAG_PSH
	local URGP

	while read LINE; do {		# func_ulog_make_evalable "$LINE" >>/tmp/vds_debug

		eval $( func_ulog_make_evalable "$LINE" )
	
		if grep -q ^"${DST};" "/tmp/CLIENTS_LAN" "/tmp/CLIENTS_WIFI" ; then
			IP=$SRC
			PORT=$SPT
			USERIP=$DST
		else
			PORT=$DPT
			IP=$DST
			USERIP=$SRC
		fi

		USERNAME="$( cat /tmp/vds_user_$MAC 2>/dev/null )"
		OUTPUT="$DIR $TIME $IP $PORT $PROTO $ID $SEQ $ACK"
		COUNTER=$(( $COUNTER + ${#OUTPUT} ))			# count bytes for logfile
		
		echo >>"${VDS_PATH}/user-${USERNAME:-unknown}-${MAC}-${USERIP:-noip}-${DATE}-node${NODEID}-reboots${REBOOTS}.ulog" "$OUTPUT"

		# > 11:35:41 212.58.226.33 80 TCP 10415 3248578720 0
		# < 11:35:41 212.58.226.33 80 TCP 0 1694259892 3248578721
		# < 11:35:47 212.58.226.33 80 TCP 33278 1694279284 3248579419
		# < 11:35:56 212.58.226.33 80 TCP 10434 3248579419 1694279285

	} done <$ULOG_LOGFILE

	rm $ULOG_LOGFILE
	_log do $FUNC daemon debug "squeezed to $(( $COUNTER * 100 / ${BYTES:=1} ))% ($COUNTER bytes)"
}

func_ulog_make_evalable ()
{
	# Input is like: (no space, all in one line)

	# Mar  9 23:21:29 node408ap 00:04:75:f8:ed:67< IN=eth2 OUT=br0 MAC=00:90:4b:87:82:d5:00:04:75:f8:ed:67:08:00
	# SRC=10.63.153.66 DST=212.79.62.105 LEN=52 TOS=00 PREC=0x00 TTL=63 ID=26975 DF PROTO=TCP SPT=39952 DPT=80
	# SEQ=3144651213 ACK=3259829088 WINDOW=4340 ACK FIN URGP=0

	# Mar 10 11:18:17 liszt28 00:02:2d:2d:8a:54< IN=vlan1 OUT=eth1 MAC=00:1d:73:05:0f:58:00:1c:4a:89:b6:17:08:00:45:00:00:34
	# SRC=74.125.39.104 DST=10.63.167.70 LEN=52 TOS=00 PREC=0x00 TTL=55 ID=49744 CE PROTO=TCP SPT=80 DPT=32908
	# SEQ=4275812248 ACK=2185052976 WINDOW=135 ACK FIN URGP=0 

	# Mar 10 11:18:21 liszt28 00:02:2d:2d:8a:54< IN=eth1 OUT=vlan1 MAC=00:1d:73:05:0f:59:00:02:2d:2d:8a:54:08:00
	# SRC=10.63.167.70 DST=74.125.39.104 LEN=52 TOS=00 PREC=0x00 TTL=63 ID=37032 CE DF PROTO=TCP SPT=32908 DPT=80
	# SEQ=2185052976 ACK=4275812249 WINDOW=25524 ACK FIN URGP=0 

	echo "$1" | sed -ne 's/^[a-zA-Z]* *[0-9]* \([0-9][0-9]:[0-9][0-9]:[0-9][0-9]\).*\([0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]\)\(.\) .* SRC=\([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) DST=\([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .* ID=\([0-9]*\).*PROTO=\(.*\)$/TIME=\1;MAC=\2;DIR="\3";SRC=\4;DST=\5;ID=\6;PROTO=\7/' \
	                 -e 'y/ /;/' \
	                 -e 's/;ACK;/;FLAG_ACK=1;/' \
	                 -e 's/;SYN;/;FLAG_SYN=1;/' \
	                 -e 's/;RST;/;FLAG_RST=1;/' \
			 -e 's/;FIN;/;FLAG_FIN=1;/' \
			 -e 's/;PSH;/;FLAG_PSH=1;/' \
			 -e 'p'

	# Output is like: (no spaces, all in one line)

	# TIME=11:18:17; MAC=00:02:2d:2d:8a:54; DIR="<"; SRC=74.125.39.104; DST=10.63.167.70; ID=49744; PROTO=TCP;
	# SPT=80; DPT=32908; SEQ=4275812248; ACK=2185052976; WINDOW=135; FLAG_ACK=1; FLAG_FIN=1; URGP=0
	
	# TIME=11:18:21; MAC=00:02:2d:2d:8a:54; DIR="<"; SRC=10.63.167.70; DST=74.125.39.104; ID=37032; PROTO=TCP;
	# SPT=32908; DPT=80; SEQ=2185052976; ACK=4275812249; WINDOW=25524; FLAG_ACK=1; FLAG_FIN=1; URGP=0
}

func_ulog_logsaving ()
{
	local FUNC="ulog_logsaving"
	local PATTERN="${VDS_PATH}/user-*.ulog"
	local TODAY="$( _system date humanreadable short )"
	local COPYCOMMAND
	local DESTINATION
	local FILELIST="$( find $PATTERN -type f 2>/dev/null )"
	local FILE FILESIZE
	local LOGPRIO="alert" 

	[ -e /tmp/ERROR_VDS ] && LOGPRIO="info"

	[ -z "$FILELIST" ] && {
		_log do $FUNC daemon debug "no logs - abort"
		return
	}

	eval "$( tail -n1 /tmp/ARCHIV_TRACEINET )"

	if   [ -n "$( nvram get fff_vds_server )" ]; then

		_log do $FUNC daemon debug "direct copy to server '$( nvram get fff_vds_server )'"
		
		COPYCOMMAND="scp -p -i $HOME/.ssh/dropbear_dss_host_key"	# '-p' preserve time,accesstime and modes
		DESTINATION="$( nvram get fff_vds_server )"

	elif [ "$GW" = "$WIFIADR" ]; then				# fixme! make this check at 1st, and abort if low flash, safes cpu-power
		_log do $FUNC daemon debug "gateway = myself"

		COPYCOMMAND="cp -p"
		DESTINATION="$( _system get_storage_path )"		# e.g. /www/cgi-bin

		[ "$DESTINATION" = "/www/cgi-bin" ] && [ "$( _system flash_free )" -lt 200 ] && {
			_log do $FUNC daemon $LOGPRIO "low_flash: $( _system flash_free )kb - aborting"
			touch /tmp/ERROR_VDS
			exit 1
		}			# fixme! remove VDS-data from RAM? or copy to /dev/null?
	else
		_log do $FUNC daemon debug "gateway = '$GW'"
		COPYCOMMAND="scp -p -i $HOME/.ssh/dropbear_dss_host_key"	# '-p' preserve time,accesstime and modes, fixme! -B (batchmode) -C (compression) -q (quiet)
		DESTINATION="${GW}:${VDS_PATH}"					# fixme! empty GW?
	fi

	for FILE in $FILELIST; do {

		FILESIZE="$( _file size "$FILE" )"

		local HASH_NOW="$( _file hash "$FILE" )"
		local HASH_OLD="$( cat "${FILE}.copyhash" 2>/dev/null )"

		_log do $FUNC daemon debug "NOW:'$HASH_NOW'"
		_log do $FUNC daemon debug "OLD:'$HASH_OLD'"

		if [ "${HASH_OLD:=never_hashed}" != "$HASH_NOW" ]; then		# file has changed

			if $COPYCOMMAND "$FILE" "$DESTINATION" ; then
				
				if echo "$FILE" | grep -q "$TODAY" ; then
					_log do $FUNC daemon info "copying '$FILE' ($FILESIZE bytes) was successful (is from today)"
					echo -n "$HASH_NOW" >"${FILE}.copyhash"
				else
					_log do $FUNC daemon info "copying '$FILE' ($FILESIZE bytes) was successful - removing"
					rm "$FILE" "${FILE}.copyhash"
				fi
			
				[ -e /tmp/ERROR_VDS ] && rm /tmp/ERROR_VDS
			else	
				_log do $FUNC daemon $LOGPRIO "copying '$FILE' ($FILESIZE bytes) failed"
				touch /tmp/ERROR_VDS
			fi
		else								# file unchanged
			[ -e /tmp/ERROR_VDS ] || {				# no former error
				echo "$FILE" | grep -q "$TODAY" || {		# not from today
				
					_log do $FUNC daemon info "removing old '$FILE' ($FILESIZE bytes)"
					rm "$FILE" "${FILE}.copyhash"
				}
			}
		fi
		
		sync		# if destination is USB-stick, then be sure that all data was written
	} done
}

func_ulog_prepare && func_ulog_sqeeze_log
func_ulog_logsaving
