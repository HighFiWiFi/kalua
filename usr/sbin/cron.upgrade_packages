#!/bin/sh
. /tmp/loader								# fixme! push most into _software() because it is very ipkg-specific
									# reading and working directly with a stream of package-metadata
									# without the need to use flashspace like with 'ipkg update'
URL_PACKAGE_LIST="$(nvram get fff_url_network)/packages/Packages"
_log do grab_package_list daemon debug "fetching '$URL_PACKAGE_LIST'"

wget -qO - "$URL_PACKAGE_LIST" | while read LINE; do {

	case "$( echo $LINE | cut -d':' -f1 )" in			# ipkg-keyword
	
		Priority|Maintainer|Section|Description|Source|Size|Architecture|Depends|MD5Sum|Conflicts)
			continue
		;;
		Package)
			PACKAGE="$(  echo $LINE | cut -d' ' -f2 )"	# mydesign
			VERSION=
			FILENAME=
		;;
		Version)
			VERSION="$(  echo $LINE | cut -d' ' -f2 )"	# 0.1
		;;
		Filename)
			FILENAME="$( echo $LINE | cut -d' ' -f2 )"	# mydesign_0.1.ipk
		;;
		"")
			[ -n "$VERSION" ] && [ -n "$FILENAME" ] && {
			
				case $PACKAGE in
					mydesign|mysettings|sshpubkeys|fff-adblock-list)
					
						VERSION_HERE="$( _software package_version $PACKAGE )"
						VERSION_SERVER="$VERSION"
						
						if [ "$( _software package_newer_version ${VERSION_HERE:=0} $VERSION_SERVER )" = "$VERSION_SERVER" ] || _software package_is_not_installed $PACKAGE; then
						
							URL="$(nvram get fff_url_network)/packages/${FILENAME}?host=$( _system hostname_get )"
							_log do found_newer_version daemon alert "upgrading '$PACKAGE' (here/server: v$VERSION_HERE/v$VERSION_SERVER url: '$URL')"
						
							wget -q -O "/tmp/mypackage_$$.ipk" "$URL"		
							ipkg install "/tmp/mypackage_$$.ipk"	# package must have no dependencies
							rm "/tmp/mypackage_$$.ipk"
						else
							_log do version_not_newer daemon debug "package '$PACKAGE' not upgraded (here/server: v$VERSION_HERE/v$VERSION_SERVER)"
						fi
					;;
					*)
						_log do uninteresting_package daemon debug "ignoring '$PACKAGE'"	# fixme! upgrade already installed packages?
					;;
				esac
			
				PACKAGE=""; VERSION=""; FILENAME=""
			}
		;;
	esac
} done
