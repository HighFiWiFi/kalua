#!/bin/sh
. /tmp/loader

ERR=1
while getopts "a:A:s:wmrRlpofuOPH" FLAG; do {

	ERR=0

	case $FLAG in
		m)
			pidof cron.minutely >/dev/null || /usr/sbin/cron.minutely
		;;
		w)
			# some quirks for ath9k/mac80211 till

			wifidev_name_has_changed()
			{
				[ -e /usr/sbin/iwconfig ] && {
					[ "$( iwconfig wlan1 2>/dev/null | wc -l )" -gt 0 ] && return 1
					[ "$( iwconfig wlan2 2>/dev/null | wc -l )" -gt 0 ] && return 1
				}

				return 0
			}

			wifidev_name_has_changed || _system reboot_safe "wifidev_name_has_changed"

			# [ "$( logread | fgrep "nf_conntrack: table full, dropping packet." | wc -l )" -gt 6 ] && reboot

			incoming_wifi_activity()
			{
				local funcname="incoming_wifi_activity"
				local framecount_old framecount_new
				local file_framecount="/tmp/WIFI_INCOMING_FRAME_COUNTER_$WIFIDEV"

				eval "$( sed -n "s/.*$WIFIDEV: *[0-9]* *\([0-9]*\).*/framecount_new=\1/p" /proc/net/dev )"

				if [ -e "$file_framecount" ]; then
					read framecount_old <"$file_framecount"
				else
					framecount_old=0
				fi

				echo "$framecount_new" >"$file_framecount"

				if [ "$framecount_old" = "$framecount_new" ]; then
					_log do $funcname daemon info "framecounter old/new: $framecount_old/$framecount_new"
					return 1
				else
					return 0
				fi
			}

			is_wifi_ap()
			{
				[ "ap" = "$( uci get wireless.@wifi-iface[0].mode )" ]
			}

			is_wifi_ap || incoming_wifi_activity || wifi
		;;
		a)
			_scheduler add "$OPTARG"
		;;
		s)
			sleep "$OPTARG"
		;;
		R)
			[ -e /tmp/.autorun ] && /tmp/.autorun		# can be helpful to make changes an many nodes
		;;							# script must first delete himself with 'rm $0'
		r)
			[ -e /tmp/SEND_ALIVE_FAILED ] && {				# fixme! this is a hack
				_scheduler queue_list | grep -q 15min_checks || {
					_scheduler add 15min_checks move2top
				}
			}
			_scheduler run
		;;
		l)
			_scheduler queue_list
		;;
		A)									# fixme! doubled entrys with -A ?
			_log do user_defined_now daemon debug "start '$OPTARG'"
			COMMAND="$( _scheduler task2command "$OPTARG" )"
			_log do user_defined_now daemon debug "start '$OPTARG' ('$COMMAND')"
			/bin/sh -c "${COMMAND:-true}"
			_log do user_defined_now daemon debug "ready '$OPTARG' ('$COMMAND')"
		;;
		P)
			case "$( uci get network.@gatewaycheck[0].mode )" in
				ping|1)
					SERVER_IP="8.8.8.8"
					LOSS="$( ping -q -c 1 $SERVER_IP | sed -n 's/^.* received, \([0-9]*\)%.*/\1/p' )"
					[ "${LOSS:-222}" -gt 0 ] && _log pingtest daemon info "[ERR] packetloss is ${LOSS}% to IP $SERVER_IP"
				;;
			esac
		;;
		p)
			_scheduler queue_purge
		;;
		O)
			_wget do "http://127.0.0.1:2006" 5 >/tmp/olsr_plain_$$
			mv /tmp/olsr_plain_$$ /tmp/olsr_plain
		;;
		H)
			[ -e /usr/sbin/uhttpd ] && \
				echo -n "$WIFIADR #" >/tmp/WELCOME_HELPER
		;;
		o)
			grep -q ^"printdev()" /usr/bin/netparam || {	# fixme! better concept needed, wrong place (but efficient)!
				INCOMING_OLSR_PACKETS_WIRED="$( iptables --line-numbers -nxvL olsr_in_wire 2>/dev/null | sed -n 's/^4[^0-9]*\([0-9]*\)[^0-9]*[0-9]*.*/\1/p' )"
				[ ${INCOMING_OLSR_PACKETS_WIRED:=0} -gt 0 ] && {
					_log do detect_wired_olsr_traffic daemon info "restart olsr-daemon with wired interfaces"
					/etc/init.d/S41build_static_netparam restore_original_netparam
					_olsr daemon restart "detected wired neigh"
				}
			}
		;;
		f)			
			IFS='. '; read NOP NOP FIVEMINLOAD DECIMALS NOP </proc/loadavg; unset IFS 
			if [ $FIVEMINLOAD -gt 1 ]; then
				_log do overload_detection daemon info "detected high 5min-load: $FIVEMINLOAD.$DECIMALS"
				_watch topusage_task
			else
				_watch counter /tmp/counter_highload set 0
			fi
		;;
		u)
			grep -q "kernel: Oops" /var/log/messages && {	# fixme! dirty, but the only chance?
				grep -q "kernel: Process wifi (" /var/log/messages || {
					logger -s "$0: detected kernel-oops, rebooting after safing reason"		# without using _log()
					grep "kern.warn kernel: " /var/log/messages >>/www/everlasting_syslog.txt
					reboot
				}
				_log do detect_kernel_oops daemon alert "only a wifi-oops, ignoring"
			}
		;;
		*)
			ERR=1
		;;
	esac
} done

[ "$ERR" = "1" ] && _scheduler print_usage && exit 1
