#!/bin/sh

. /bin/needs base log olsr

func_longest_string ()
{
	local LIST="$1"
	local MIN=0
	local WORD
	local OUT

	for WORD in $LIST; do {
		[ ${#WORD} -gt $MIN ] && {
			OUT="$WORD"
			MIN="${#WORD}"
		}
	} done
	
	echo $OUT
}

func_normalize_ip ()	# IP_max=123.123.123.123 (15chars) IP_min=1.1.1.1 (7chars) -> DIFF_max = 8
{
	local MAX="${#1}"
	local LENGTH="${#2}"
	local DIFF=$(( $MAX - $LENGTH ))

	case $DIFF in
		0) return ;;
		1) echo -n ' ' ;;
		2) echo -n '  ' ;;
		3) echo -n '   ' ;;
		4) echo -n '    ' ;;
		5) echo -n '     ' ;;
		6) echo -n '      ' ;;
		7) echo -n '       ' ;;
		*) echo -n '        ' ;;
	esac
}

if [ "$2" = "use_recent" ]; then

	OUT_OLSR="/tmp/olsr_output_recent"
else
	case $1 in
		gateways) OUT_OLSR="$(func_olsr_get_neighbours full)" || exit ;;
		       *) OUT_OLSR="$(func_olsr_get_neighbours     )" || exit ;;
	esac
	
	cp $OUT_OLSR /tmp/olsr_output_recent
fi

case $1 in		# all those functions must care about removing $OUT_OLSR !
	meshrdf)
		func_olsr_output_neigh_meshrdf $OUT_OLSR
		[ "$( ls -1 /tmp/olsr_output_* 2>/dev/null | wc -l )" -gt 5 ] && {		# fixme! (dirty workaround)
			func_log olsr_output_garbage_collector daemon debug "removing >5 cadaver's"
			rm /tmp/olsr_output_*
		}
	;;
	gateways)
		func_olsr_get_gateways $OUT_OLSR
	;;
	evalable)
		func_olsr_output_neigh_evalable $OUT_OLSR verbose
	;;
	best_wifi_nlq)
		func_olsr_best_wifi_nlq $OUT_OLSR	# output like '500' which is 0.500 - output can be <empty>!
	;;
	get_nlq)
		[ -n "$2" ] && func_olsr_get_nlq $OUT_OLSR "$2"	
	;;
	check4nonwifi)
		func_olsr_check_if_any_nonwifi_neigh $OUT_OLSR
	;;
	check4wifi)
		func_olsr_check_for_wifi_neigh $OUT_OLSR
	;;
	check4good_non_tunnel_neigh)
		func_olsr_check_for_good_non_tunnel_neigh $OUT_OLSR || exit 1
	;;
	get_random)
		func_olsr_get_random_neigh $OUT_OLSR		# returns IP or EMPTY (!)
	;;
	get_random_pair)
		rm $OUT_OLSR
		func_olsr_get_random_pair_from_mesh_evalable "$2"	# fixme! max_cost not yet implemented
	;;
	get_cost2node)
		rm $OUT_OLSR
		func_olsr_get_cost_to_specific_node_evalable "$2"
	;;
	plain)
		cat $OUT_OLSR
		rm $OUT_OLSR
	;;
	help)
		echo "Usage: $0 (meshrdf | evalable | get_nlq | best_wifi_nlq | check4nonwifi | check4wifi | check4good_non_tunnel_neigh | get_random | get_random_pair [max_cost] | get_cost2node node | plain | <empty>)"
		rm $OUT_OLSR
	;;
	*)
		[ -z "$1" ] && {
			func_olsr_output_neigh_humanreadable $OUT_OLSR		# fixme! +gps +distance +olsrd/ff/fff-version?
			exit
		}
		
		[ -n "$( echo "$1" | sed -n 's/^\([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\)$/\1/p' )" ] && {
			wget -qO - "http://$1/cgi-bin-tool_fff+?OPT=neigh"
			exit
		}
		
		# fixme!
		# neigh 172 = neigh 10.63.172.1
		
		[ -n "$( nslookup "$1" | sed -ne '5{s/^Address:[^0-9]*\([0-9\.]*\)/\1/p}' )" ] && {
			wget -qO - "http://$1/cgi-bin-tool_fff+?OPT=neigh"
			exit
		}
	;;
esac
