Index: compat-wireless-2014-11-04/net/mac80211/rc80211_rhapsody_ht.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ compat-wireless-2014-11-04/net/mac80211/rc80211_rhapsody_ht.c	2015-02-13 16:12:26.159172304 +0100
@@ -0,0 +1,1435 @@
+/*
+ * Copyright (C) 2015 Thomas Huehn <thomas@inet.tu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on minstrel-ht.c:
+ *   Copyright (C) 2010-20014 Felix Fietkau <nbd@openwrt.org>
+ *   Sponsored by OpenWRT.org
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer,
+ *      without modification.
+ *   2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *      similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
+ *      redistribution must be conditioned upon including a substantially
+ *      similar Disclaimer requirement for further binary redistribution.
+ *   3. Neither the names of the above-listed copyright holders nor the names
+ *      of any contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *   Alternatively, this software may be distributed under the terms of the
+ *   GNU General Public License ("GPL") version 2 as published by the Free
+ *   Software Foundation.
+ *
+ *   NO WARRANTY
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
+ *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ *   THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
+ *   OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ *   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *   THE POSSIBILITY OF SUCH DAMAGES.
+ */
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/debugfs.h>
+#include <linux/random.h>
+#include <linux/moduleparam.h>
+#include <linux/ieee80211.h>
+#include <net/mac80211.h>
+#include "rate.h"
+#include "rc80211_rhapsody.h"
+#include "rc80211_rhapsody_ht.h"
+
+#define AVG_PKT_SIZE	1200
+
+/* Number of bits for an average sized packet */
+#define MCS_NBITS (AVG_PKT_SIZE << 3)
+
+/* Number of symbols for a packet with (bps) bits per symbol */
+#define MCS_NSYMS(bps) DIV_ROUND_UP(MCS_NBITS, (bps))
+
+/* Transmission time (nanoseconds) for a packet containing (syms) symbols */
+#define MCS_SYMBOL_TIME(sgi, syms)					\
+	(sgi ?								\
+	  ((syms) * 18000 + 4000) / 5 :	/* syms * 3.6 us */		\
+	  ((syms) * 1000) << 2		/* syms * 4 us */		\
+	)
+
+/* Transmit duration for the raw data part of an average sized packet */
+#define MCS_DURATION(streams, sgi, bps) MCS_SYMBOL_TIME(sgi, MCS_NSYMS((streams) * (bps)))
+
+#define BW_20			0
+#define BW_40			1
+#define BW_80			2
+
+/*
+ * Define group sort order: HT40 -> SGI -> #streams
+ */
+#define GROUP_IDX(_streams, _sgi, _ht40)	\
+	RHAPSODY_HT_GROUP_0 +			\
+	RHAPSODY_MAX_STREAMS * 2 * _ht40 +	\
+	RHAPSODY_MAX_STREAMS * _sgi +	\
+	_streams - 1
+
+/* MCS rate information for an MCS group */
+#define MCS_GROUP(_streams, _sgi, _ht40)				\
+	[GROUP_IDX(_streams, _sgi, _ht40)] = {				\
+	.streams = _streams,						\
+	.flags =							\
+		IEEE80211_TX_RC_MCS |					\
+		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
+		(_ht40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),		\
+	.duration = {							\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26),		\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 108 : 52),		\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 162 : 78),		\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 216 : 104),	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 324 : 156),	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 432 : 208),	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 486 : 234),	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 540 : 260)		\
+	}								\
+}
+
+#define VHT_GROUP_IDX(_streams, _sgi, _bw)				\
+	(RHAPSODY_VHT_GROUP_0 +						\
+	 RHAPSODY_MAX_STREAMS * 2 * (_bw) +				\
+	 RHAPSODY_MAX_STREAMS * (_sgi) +				\
+	 (_streams) - 1)
+
+#define BW2VBPS(_bw, r3, r2, r1)					\
+	(_bw == BW_80 ? r3 : _bw == BW_40 ? r2 : r1)
+
+#define VHT_GROUP(_streams, _sgi, _bw)					\
+	[VHT_GROUP_IDX(_streams, _sgi, _bw)] = {			\
+	.streams = _streams,						\
+	.flags =							\
+		IEEE80211_TX_RC_VHT_MCS |				\
+		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
+		(_bw == BW_80 ? IEEE80211_TX_RC_80_MHZ_WIDTH :		\
+		 _bw == BW_40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),	\
+	.duration = {							\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw,  117,  54,  26)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw,  234, 108,  52)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw,  351, 162,  78)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw,  468, 216, 104)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw,  702, 324, 156)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw,  936, 432, 208)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw, 1053, 486, 234)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw, 1170, 540, 260)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw, 1404, 648, 312)),		\
+		MCS_DURATION(_streams, _sgi,				\
+			     BW2VBPS(_bw, 1560, 720, 346))		\
+	}								\
+}
+
+#define CCK_DURATION(_bitrate, _short, _len)		\
+	(1000 * (10 /* SIFS */ +			\
+	 (_short ? 72 + 24 : 144 + 48) +		\
+	 (8 * (_len + 4) * 10) / (_bitrate)))
+
+#define CCK_ACK_DURATION(_bitrate, _short)			\
+	(CCK_DURATION((_bitrate > 10 ? 20 : 10), false, 60) +	\
+	 CCK_DURATION(_bitrate, _short, AVG_PKT_SIZE))
+
+#define CCK_DURATION_LIST(_short)			\
+	CCK_ACK_DURATION(10, _short),			\
+	CCK_ACK_DURATION(20, _short),			\
+	CCK_ACK_DURATION(55, _short),			\
+	CCK_ACK_DURATION(110, _short)
+
+#define CCK_GROUP					\
+	[RHAPSODY_CCK_GROUP] = {			\
+		.streams = 0,				\
+		.flags = 0,				\
+		.duration = {				\
+			CCK_DURATION_LIST(false),	\
+			CCK_DURATION_LIST(true)		\
+		}					\
+	}
+
+#ifdef CPTCFG_MAC80211_RC_RHAPSODY_BLUES_VHT
+static bool rhapsody_vht_only = true;
+module_param(rhapsody_vht_only, bool, 0644);
+MODULE_PARM_DESC(rhapsody_vht_only,
+		 "Use only VHT rates when VHT is supported by sta.");
+#endif
+
+/*
+ * To enable sufficiently targeted rate sampling, MCS rates are divided into
+ * groups, based on the number of streams and flags (HT40, SGI) that they
+ * use.
+ *
+ * Sortorder has to be fixed for GROUP_IDX macro to be applicable:
+ * BW -> SGI -> #streams
+ */
+const struct mcs_group rhapsody_mcs_groups[] = {
+	MCS_GROUP(1, 0, BW_20),
+	MCS_GROUP(2, 0, BW_20),
+#if RHAPSODY_MAX_STREAMS >= 3
+	MCS_GROUP(3, 0, BW_20),
+#endif
+
+	MCS_GROUP(1, 1, BW_20),
+	MCS_GROUP(2, 1, BW_20),
+#if RHAPSODY_MAX_STREAMS >= 3
+	MCS_GROUP(3, 1, BW_20),
+#endif
+
+	MCS_GROUP(1, 0, BW_40),
+	MCS_GROUP(2, 0, BW_40),
+#if RHAPSODY_MAX_STREAMS >= 3
+	MCS_GROUP(3, 0, BW_40),
+#endif
+
+	MCS_GROUP(1, 1, BW_40),
+	MCS_GROUP(2, 1, BW_40),
+#if RHAPSODY_MAX_STREAMS >= 3
+	MCS_GROUP(3, 1, BW_40),
+#endif
+
+	CCK_GROUP,
+
+#ifdef CPTCFG_MAC80211_RC_RHAPSODY_BLUES_VHT
+	VHT_GROUP(1, 0, BW_20),
+	VHT_GROUP(2, 0, BW_20),
+#if RHAPSODY_MAX_STREAMS >= 3
+	VHT_GROUP(3, 0, BW_20),
+#endif
+
+	VHT_GROUP(1, 1, BW_20),
+	VHT_GROUP(2, 1, BW_20),
+#if RHAPSODY_MAX_STREAMS >= 3
+	VHT_GROUP(3, 1, BW_20),
+#endif
+
+	VHT_GROUP(1, 0, BW_40),
+	VHT_GROUP(2, 0, BW_40),
+#if RHAPSODY_MAX_STREAMS >= 3
+	VHT_GROUP(3, 0, BW_40),
+#endif
+
+	VHT_GROUP(1, 1, BW_40),
+	VHT_GROUP(2, 1, BW_40),
+#if RHAPSODY_MAX_STREAMS >= 3
+	VHT_GROUP(3, 1, BW_40),
+#endif
+
+	VHT_GROUP(1, 0, BW_80),
+	VHT_GROUP(2, 0, BW_80),
+#if RHAPSODY_MAX_STREAMS >= 3
+	VHT_GROUP(3, 0, BW_80),
+#endif
+
+	VHT_GROUP(1, 1, BW_80),
+	VHT_GROUP(2, 1, BW_80),
+#if RHAPSODY_MAX_STREAMS >= 3
+	VHT_GROUP(3, 1, BW_80),
+#endif
+#endif
+};
+
+static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
+
+static void
+rhapsody_ht_update_rates(struct rhapsody_priv *rp, struct rhapsody_ht_sta *ri);
+
+/*
+ * Some VHT MCSes are invalid (when Ndbps / Nes is not an integer)
+ * e.g for MCS9@20MHzx1Nss: Ndbps=8x52*(5/6) Nes=1
+ *
+ * Returns the valid mcs map for struct rhapsody_mcs_group_data.supported
+ */
+static u16
+rhapsody_get_valid_vht_rates(int bw, int nss, __le16 mcs_map)
+{
+	u16 mask = 0;
+
+	if (bw == BW_20) {
+		if (nss != 3 && nss != 6)
+			mask = BIT(9);
+	} else if (bw == BW_80) {
+		if (nss == 3 || nss == 7)
+			mask = BIT(6);
+		else if (nss == 6)
+			mask = BIT(9);
+	} else {
+		WARN_ON(bw != BW_40);
+	}
+
+	switch ((le16_to_cpu(mcs_map) >> (2 * (nss - 1))) & 3) {
+	case IEEE80211_VHT_MCS_SUPPORT_0_7:
+		mask |= 0x300;
+		break;
+	case IEEE80211_VHT_MCS_SUPPORT_0_8:
+		mask |= 0x200;
+		break;
+	case IEEE80211_VHT_MCS_SUPPORT_0_9:
+		break;
+	default:
+		mask = 0x3ff;
+	}
+
+	return 0x3ff & ~mask;
+}
+
+/*
+ * Look up an MCS group index based on mac80211 rate information
+ */
+static int
+rhapsody_ht_get_group_idx(struct ieee80211_tx_rate *rate)
+{
+	return GROUP_IDX((rate->idx / 8) + 1,
+			 !!(rate->flags & IEEE80211_TX_RC_SHORT_GI),
+			 !!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH));
+}
+
+static int
+rhapsody_vht_get_group_idx(struct ieee80211_tx_rate *rate)
+{
+	return VHT_GROUP_IDX(ieee80211_rate_get_vht_nss(rate),
+			     !!(rate->flags & IEEE80211_TX_RC_SHORT_GI),
+			     !!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) +
+			     2*!!(rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH));
+}
+
+static struct rhapsody_rate_stats *
+rhapsody_ht_get_stats(struct rhapsody_priv *rp, struct rhapsody_ht_sta *ri,
+		      struct ieee80211_tx_rate *rate)
+{
+	int group, idx;
+
+	if (rate->flags & IEEE80211_TX_RC_MCS) {
+		group = rhapsody_ht_get_group_idx(rate);
+		idx = rate->idx % 8;
+	} else if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {
+		group = rhapsody_vht_get_group_idx(rate);
+		idx = ieee80211_rate_get_vht_mcs(rate);
+	} else {
+		group = RHAPSODY_CCK_GROUP;
+
+		for (idx = 0; idx < ARRAY_SIZE(rp->cck_rates); idx++)
+			if (rate->idx == rp->cck_rates[idx])
+				break;
+
+		/* short preamble */
+		if (!(ri->groups[group].supported & BIT(idx)))
+			idx += 4;
+	}
+	return &ri->groups[group].rates[idx];
+}
+
+static inline struct rhapsody_rate_stats *
+rhapsody_get_ratestats(struct rhapsody_ht_sta *ri, int index)
+{
+	return &ri->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];
+}
+
+/*
+ * Return current throughput based on the average A-MPDU length, taking into
+ * account the expected number of retransmissions and their expected length
+ */
+int
+rhapsody_ht_get_tp_avg(struct rhapsody_ht_sta *ri, int group, int rate)
+{
+	struct rhapsody_rate_stats *rrs;
+	unsigned int nsecs = 0;
+	unsigned int tmp_prob_ewma, tp_avg;
+
+	rrs = &ri->groups[group].rates[rate];
+	tmp_prob_ewma = rrs->prob_ewma;
+
+	/* do not account throughput if sucess prob is below 10% */
+	if (rrs->prob_ewma < RHAPSODY_FRAC(10, 100)) {
+		tp_avg = 0;
+		return tp_avg;
+	}
+
+	/*
+	 * For the throughput calculation, limit the probability value to 90% to
+	 * account for collision related packet error rate fluctuation
+	 */
+	if (rrs->prob_ewma > RHAPSODY_FRAC(90, 100))
+		tmp_prob_ewma = RHAPSODY_FRAC(90, 100);
+
+	if (group != RHAPSODY_CCK_GROUP)
+		nsecs = 1000 * ri->overhead / RHAPSODY_TRUNC(ri->avg_ampdu_len);
+
+	nsecs += rhapsody_mcs_groups[group].duration[rate];
+
+	/* prob is scaled - see RHAPSODY_FRAC above */
+	tp_avg = RHAPSODY_TRUNC(100000 * ((tmp_prob_ewma * 1000) / nsecs));
+
+	return tp_avg;
+}
+
+/*
+ * Return max. potential lossless throughput based on the average A-MPDU
+ */
+int
+rhapsody_ht_get_tp_max(struct rhapsody_ht_sta *ri, int group, int rate)
+{
+	unsigned int nsecs = 0;
+	unsigned int tp_max;
+
+	if (group != RHAPSODY_CCK_GROUP)
+		nsecs = 1000 * ri->overhead / RHAPSODY_TRUNC(ri->avg_ampdu_len);
+
+	nsecs += rhapsody_mcs_groups[group].duration[rate];
+	tp_max = 100000000 / nsecs;
+
+	return tp_max;
+}
+
+
+/*
+ * Find & sort topmost throughput rates
+ *
+ * If multiple rates provide equal throughput the sorting is based on their
+ * current success probability. Higher success probability is preferred among
+ * MCS groups, CCK rates do not provide aggregation and are therefore at last.
+ */
+static void
+rhapsody_ht_sort_best_tp_rates(struct rhapsody_ht_sta *ri, u16 index,
+			       u16 *tp_list)
+{
+	int cur_group, cur_idx, cur_tp_avg, cur_prob;
+	int tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;
+	int j = MAX_THR_RATES;
+
+	cur_group = index / MCS_GROUP_RATES;
+	cur_idx = index  % MCS_GROUP_RATES;
+	cur_tp_avg = rhapsody_ht_get_tp_avg(ri, cur_group, cur_idx);
+	cur_prob = ri->groups[cur_group].rates[cur_idx].prob_ewma;
+
+	do {
+		tmp_group = tp_list[j - 1] / MCS_GROUP_RATES;
+		tmp_idx = tp_list[j - 1] % MCS_GROUP_RATES;
+		tmp_tp_avg = rhapsody_ht_get_tp_avg(ri, tmp_group, tmp_idx);
+		tmp_prob = ri->groups[tmp_group].rates[tmp_idx].prob_ewma;
+		if (cur_tp_avg < tmp_tp_avg ||
+		    (cur_tp_avg == tmp_tp_avg && cur_prob <= tmp_prob))
+			break;
+		j--;
+	} while (j > 0);
+
+	if (j < MAX_THR_RATES - 1) {
+		memmove(&tp_list[j + 1], &tp_list[j], (sizeof(*tp_list) *
+		       (MAX_THR_RATES - (j + 1))));
+	}
+	if (j < MAX_THR_RATES)
+		tp_list[j] = index;
+}
+
+/*
+ * Find and set the topmost probability rate per sta and per group
+ */
+static void
+rhapsody_ht_set_best_prob_rate(struct rhapsody_ht_sta *ri, u16 index)
+{
+	struct rhapsody_mcs_group_data *rg;
+	struct rhapsody_rate_stats *rrs;
+	int tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;
+	int max_tp_group, cur_tp_avg, cur_group, cur_idx;
+	int max_group_prob_rate_group, max_group_prob_rate_idx;
+	int max_group_prob_rate_tp_avg;
+
+	cur_group = index / MCS_GROUP_RATES;
+	cur_idx = index % MCS_GROUP_RATES;
+	rg = &ri->groups[index / MCS_GROUP_RATES];
+	rrs = &rg->rates[index % MCS_GROUP_RATES];
+
+	tmp_group = ri->max_prob_rate / MCS_GROUP_RATES;
+	tmp_idx = ri->max_prob_rate % MCS_GROUP_RATES;
+	tmp_tp_avg = rhapsody_ht_get_tp_avg(ri, tmp_group, tmp_idx);
+	tmp_prob = ri->groups[tmp_group].rates[tmp_idx].prob_ewma;
+
+	/* if max_tp_rate[0] is from MCS_GROUP max_prob_rate get selected from
+	 * MCS_GROUP as well as CCK_GROUP rates do not allow aggregation */
+	max_tp_group = ri->max_tp_rate[0] / MCS_GROUP_RATES;
+	if((index / MCS_GROUP_RATES == RHAPSODY_CCK_GROUP) &&
+	    (max_tp_group != RHAPSODY_CCK_GROUP))
+		return;
+
+	if (rrs->prob_ewma > RHAPSODY_FRAC(75, 100)) {
+		cur_tp_avg = rhapsody_ht_get_tp_avg(ri, cur_group, cur_idx);
+		if (cur_tp_avg > tmp_tp_avg)
+			ri->max_prob_rate = index;
+
+		max_group_prob_rate_group = rg->max_group_prob_rate /
+								MCS_GROUP_RATES;
+		max_group_prob_rate_idx = rg->max_group_prob_rate %
+								MCS_GROUP_RATES;
+		max_group_prob_rate_tp_avg = rhapsody_ht_get_tp_avg(ri,
+						max_group_prob_rate_group,
+						max_group_prob_rate_idx);
+		if (cur_tp_avg > max_group_prob_rate_tp_avg)
+			rg->max_group_prob_rate = index;
+	} else {
+		if (rrs->prob_ewma > tmp_prob)
+			ri->max_prob_rate = index;
+		if (rrs->prob_ewma > rg->rates[rg->max_group_prob_rate].prob_ewma)
+			rg->max_group_prob_rate = index;
+	}
+}
+
+
+/*
+ * Assign new rate set per sta and use CCK rates only if the fastest
+ * rate (max_tp_rate[0]) is from CCK group. This prohibits such sorted
+ * rate sets where MCS and CCK rates are mixed, because CCK rates can
+ * not use aggregation.
+ */
+static void
+rhapsody_ht_assign_best_tp_rates(struct rhapsody_ht_sta *ri,
+				 u16 tmp_mcs_tp_rate[MAX_THR_RATES],
+				 u16 tmp_cck_tp_rate[MAX_THR_RATES])
+{
+	unsigned int tmp_group, tmp_idx, tmp_cck_tp, tmp_mcs_tp;
+	int i;
+
+	tmp_group = tmp_cck_tp_rate[0] / MCS_GROUP_RATES;
+	tmp_idx = tmp_cck_tp_rate[0] % MCS_GROUP_RATES;
+	tmp_cck_tp = rhapsody_ht_get_tp_avg(ri, tmp_group, tmp_idx);
+
+	tmp_group = tmp_mcs_tp_rate[0] / MCS_GROUP_RATES;
+	tmp_idx = tmp_mcs_tp_rate[0] % MCS_GROUP_RATES;
+	tmp_mcs_tp = rhapsody_ht_get_tp_avg(ri, tmp_group, tmp_idx);
+
+	if (tmp_cck_tp > tmp_mcs_tp) {
+		for(i = 0; i < MAX_THR_RATES; i++) {
+			rhapsody_ht_sort_best_tp_rates(ri, tmp_cck_tp_rate[i],
+						       tmp_mcs_tp_rate);
+		}
+	}
+
+}
+
+/*
+ * Try to increase robustness of max_prob rate by decrease number of
+ * streams if possible.
+ */
+static inline void
+rhapsody_ht_prob_rate_reduce_streams(struct rhapsody_ht_sta *ri)
+{
+	struct rhapsody_mcs_group_data *rg;
+	int tmp_max_streams, group, tmp_idx;
+	int tmp_tp = 0;
+
+	tmp_max_streams = rhapsody_mcs_groups[ri->max_tp_rate[0] /
+			  MCS_GROUP_RATES].streams;
+	for (group = 0; group < ARRAY_SIZE(rhapsody_mcs_groups); group++) {
+		rg = &ri->groups[group];
+		if (!rg->supported || group == RHAPSODY_CCK_GROUP)
+			continue;
+
+		tmp_idx = rg->max_group_prob_rate % MCS_GROUP_RATES;
+
+		if (tmp_tp < rhapsody_ht_get_tp_avg(ri, group, tmp_idx) &&
+		   (rhapsody_mcs_groups[group].streams < tmp_max_streams)) {
+				ri->max_prob_rate = rg->max_group_prob_rate;
+				tmp_tp = rhapsody_ht_get_tp_avg(ri, group,
+								tmp_idx);
+		}
+	}
+}
+
+/*
+ * Update rate statistics and select new primary rates
+ *
+ * Rules for rate selection:
+ *  - max_prob_rate must use only one stream, as a tradeoff between delivery
+ *    probability and throughput during strong fluctuations
+ *  - as long as the max prob rate has a probability of more than 75%, pick
+ *    higher throughput rates, even if the probablity is a bit lower
+ */
+static void
+rhapsody_ht_update_stats(struct rhapsody_priv *rp, struct rhapsody_ht_sta *ri)
+{
+	struct rhapsody_mcs_group_data *rg;
+	struct rhapsody_rate_stats *rrs;
+	int group, i, j;
+	u16 tmp_mcs_tp_rate[MAX_THR_RATES], tmp_group_tp_rate[MAX_THR_RATES];
+	u16 tmp_cck_tp_rate[MAX_THR_RATES], index;
+
+	if (ri->ampdu_packets > 0) {
+		ri->avg_ampdu_len = rhapsody_ewma(ri->avg_ampdu_len,
+			RHAPSODY_FRAC(ri->ampdu_len, ri->ampdu_packets), EWMA_LEVEL);
+		ri->ampdu_len = 0;
+		ri->ampdu_packets = 0;
+	}
+
+	ri->sample_slow = 0;
+	ri->sample_count = 0;
+
+	/* Initialize global rate indexes */
+	for(j = 0; j < MAX_THR_RATES; j++){
+		tmp_mcs_tp_rate[j] = 0;
+		tmp_cck_tp_rate[j] = 0;
+	}
+
+	/* Find best rate sets within all MCS groups*/
+	for (group = 0; group < ARRAY_SIZE(rhapsody_mcs_groups); group++) {
+
+		rg = &ri->groups[group];
+		if (!rg->supported)
+			continue;
+
+		ri->sample_count++;
+
+		/* (re)Initialize group rate indexes */
+		for(j = 0; j < MAX_THR_RATES; j++)
+			tmp_group_tp_rate[j] = group;
+
+		for (i = 0; i < MCS_GROUP_RATES; i++) {
+			if (!(rg->supported & BIT(i)))
+				continue;
+
+			index = MCS_GROUP_RATES * group + i;
+
+			rrs = &rg->rates[i];
+			rrs->retry_updated = false;
+			rhapsody_calc_rate_stats(rrs);
+
+			if (rhapsody_ht_get_tp_avg(ri, group, i) == 0)
+				continue;
+
+			/* Find max throughput rate set */
+			if (group != RHAPSODY_CCK_GROUP) {
+				rhapsody_ht_sort_best_tp_rates(ri, index,
+							       tmp_mcs_tp_rate);
+			} else if (group == RHAPSODY_CCK_GROUP) {
+				rhapsody_ht_sort_best_tp_rates(ri, index,
+							       tmp_cck_tp_rate);
+			}
+
+			/* Find max throughput rate set within a group */
+			rhapsody_ht_sort_best_tp_rates(ri, index,
+						       tmp_group_tp_rate);
+
+			/* Find max probability rate per group and global */
+			rhapsody_ht_set_best_prob_rate(ri, index);
+		}
+
+		memcpy(rg->max_group_tp_rate, tmp_group_tp_rate,
+		       sizeof(rg->max_group_tp_rate));
+	}
+
+	/* Assign new rate set per sta */
+	rhapsody_ht_assign_best_tp_rates(ri, tmp_mcs_tp_rate, tmp_cck_tp_rate);
+	memcpy(ri->max_tp_rate, tmp_mcs_tp_rate, sizeof(ri->max_tp_rate));
+
+	/* Try to increase robustness of max_prob_rate*/
+	rhapsody_ht_prob_rate_reduce_streams(ri);
+
+	/* try to sample all available rates during each interval */
+	ri->sample_count *= 8;
+
+#ifdef CPTCFG_MAC80211_DEBUGFS
+	/* use fixed index if set */
+	if (rp->fixed_rate_idx != -1) {
+		for (i = 0; i < 4; i++)
+			ri->max_tp_rate[i] = rp->fixed_rate_idx;
+		ri->max_prob_rate = rp->fixed_rate_idx;
+	}
+#endif
+
+	/* Reset update timer */
+	ri->last_stats_update = jiffies;
+}
+
+static bool
+rhapsody_ht_txstat_valid(struct rhapsody_priv *rp, struct ieee80211_tx_rate *rate)
+{
+	if (rate->idx < 0)
+		return false;
+
+	if (!rate->count)
+		return false;
+
+	if (rate->flags & IEEE80211_TX_RC_MCS ||
+	    rate->flags & IEEE80211_TX_RC_VHT_MCS)
+		return true;
+
+	return rate->idx == rp->cck_rates[0] ||
+	       rate->idx == rp->cck_rates[1] ||
+	       rate->idx == rp->cck_rates[2] ||
+	       rate->idx == rp->cck_rates[3];
+}
+
+static void
+rhapsody_set_next_sample_idx(struct rhapsody_ht_sta *ri)
+{
+	struct rhapsody_mcs_group_data *rg;
+
+	for (;;) {
+		ri->sample_group++;
+		ri->sample_group %= ARRAY_SIZE(rhapsody_mcs_groups);
+		rg = &ri->groups[ri->sample_group];
+
+		if (!rg->supported)
+			continue;
+
+		if (++rg->index >= MCS_GROUP_RATES) {
+			rg->index = 0;
+			if (++rg->column >= ARRAY_SIZE(sample_table))
+				rg->column = 0;
+		}
+		break;
+	}
+}
+
+static void
+rhapsody_downgrade_rate(struct rhapsody_ht_sta *ri, u16 *idx, bool primary)
+{
+	int group, orig_group;
+
+	orig_group = group = *idx / MCS_GROUP_RATES;
+	while (group > 0) {
+		group--;
+
+		if (!ri->groups[group].supported)
+			continue;
+
+		if (rhapsody_mcs_groups[group].streams >
+		    rhapsody_mcs_groups[orig_group].streams)
+			continue;
+
+		if (primary)
+			*idx = ri->groups[group].max_group_tp_rate[0];
+		else
+			*idx = ri->groups[group].max_group_tp_rate[1];
+		break;
+	}
+}
+
+static void
+rhapsody_aggr_check(struct ieee80211_sta *pubsta, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	u16 tid;
+
+	if (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)
+		return;
+
+	if (unlikely(!ieee80211_is_data_qos(hdr->frame_control)))
+		return;
+
+	if (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))
+		return;
+
+	tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;
+	if (likely(sta->ampdu_mlme.tid_tx[tid]))
+		return;
+
+	ieee80211_start_tx_ba_session(pubsta, tid, 5000);
+}
+
+static void
+rhapsody_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
+                      struct ieee80211_sta *sta, void *priv_sta,
+                      struct ieee80211_tx_info *info)
+{
+	struct rhapsody_ht_sta_priv *rsp = priv_sta;
+	struct rhapsody_ht_sta *ri = &rsp->ht;
+	struct ieee80211_tx_rate *ar = info->status.rates;
+	struct rhapsody_rate_stats *rate, *rate2;
+	struct rhapsody_priv *rp = priv;
+	bool last, update = false;
+	int i;
+
+	if (!rsp->is_ht)
+		return mac80211_rhapsody.tx_status_noskb(priv, sband, sta,
+							 &rsp->legacy, info);
+
+	/* This packet was aggregated but doesn't carry status info */
+	if ((info->flags & IEEE80211_TX_CTL_AMPDU) &&
+	    !(info->flags & IEEE80211_TX_STAT_AMPDU))
+		return;
+
+	if (!(info->flags & IEEE80211_TX_STAT_AMPDU)) {
+		info->status.ampdu_ack_len =
+			(info->flags & IEEE80211_TX_STAT_ACK ? 1 : 0);
+		info->status.ampdu_len = 1;
+	}
+
+	ri->ampdu_packets++;
+	ri->ampdu_len += info->status.ampdu_len;
+
+	if (!ri->sample_wait && !ri->sample_tries && ri->sample_count > 0) {
+		ri->sample_wait = 16 + 2 * RHAPSODY_TRUNC(ri->avg_ampdu_len);
+		ri->sample_tries = 1;
+		ri->sample_count--;
+	}
+
+	if (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)
+		ri->sample_packets += info->status.ampdu_len;
+
+	last = !rhapsody_ht_txstat_valid(rp, &ar[0]);
+	for (i = 0; !last; i++) {
+		last = (i == IEEE80211_TX_MAX_RATES - 1) ||
+		       !rhapsody_ht_txstat_valid(rp, &ar[i + 1]);
+
+		rate = rhapsody_ht_get_stats(rp, ri, &ar[i]);
+
+		if (last)
+			rate->success += info->status.ampdu_ack_len;
+
+		rate->attempts += ar[i].count * info->status.ampdu_len;
+	}
+
+	/*
+	 * check for sudden death of spatial multiplexing,
+	 * downgrade to a lower number of streams if necessary.
+	 */
+	rate = rhapsody_get_ratestats(ri, ri->max_tp_rate[0]);
+	if (rate->attempts > 30 &&
+	    RHAPSODY_FRAC(rate->success, rate->attempts) <
+	    RHAPSODY_FRAC(20, 100)) {
+		rhapsody_downgrade_rate(ri, &ri->max_tp_rate[0], true);
+		update = true;
+	}
+
+	rate2 = rhapsody_get_ratestats(ri, ri->max_tp_rate[1]);
+	if (rate2->attempts > 30 &&
+	    RHAPSODY_FRAC(rate2->success, rate2->attempts) <
+	    RHAPSODY_FRAC(20, 100)) {
+		rhapsody_downgrade_rate(ri, &ri->max_tp_rate[1], false);
+		update = true;
+	}
+
+	if (time_after(jiffies, ri->last_stats_update +
+				(rp->update_interval / 2 * HZ) / 1000)) {
+		update = true;
+		rhapsody_ht_update_stats(rp, ri);
+	}
+
+	if (update)
+		rhapsody_ht_update_rates(rp, ri);
+}
+
+static void
+rhapsody_calc_retransmit(struct rhapsody_priv *rp, struct rhapsody_ht_sta *ri,
+                         int index)
+{
+	struct rhapsody_rate_stats *rrs;
+	const struct mcs_group *group;
+	unsigned int tx_time, tx_time_rtscts, tx_time_data;
+	unsigned int cw = rp->cw_min;
+	unsigned int ctime = 0;
+	unsigned int t_slot = 9; /* FIXME */
+	unsigned int ampdu_len = RHAPSODY_TRUNC(ri->avg_ampdu_len);
+	unsigned int overhead = 0, overhead_rtscts = 0;
+
+	rrs = rhapsody_get_ratestats(ri, index);
+	if (rrs->prob_ewma < RHAPSODY_FRAC(1, 10)) {
+		rrs->retry_count = 1;
+		rrs->retry_count_rtscts = 1;
+		return;
+	}
+
+	rrs->retry_count = 2;
+	rrs->retry_count_rtscts = 2;
+	rrs->retry_updated = true;
+
+	group = &rhapsody_mcs_groups[index / MCS_GROUP_RATES];
+	tx_time_data = group->duration[index % MCS_GROUP_RATES] * ampdu_len / 1000;
+
+	/* Contention time for first 2 tries */
+	ctime = (t_slot * cw) >> 1;
+	cw = min((cw << 1) | 1, rp->cw_max);
+	ctime += (t_slot * cw) >> 1;
+	cw = min((cw << 1) | 1, rp->cw_max);
+
+	if (index / MCS_GROUP_RATES != RHAPSODY_CCK_GROUP) {
+		overhead = ri->overhead;
+		overhead_rtscts = ri->overhead_rtscts;
+	}
+
+	/* Total TX time for data and Contention after first 2 tries */
+	tx_time = ctime + 2 * (overhead + tx_time_data);
+	tx_time_rtscts = ctime + 2 * (overhead_rtscts + tx_time_data);
+
+	/* See how many more tries we can fit inside segment size */
+	do {
+		/* Contention time for this try */
+		ctime = (t_slot * cw) >> 1;
+		cw = min((cw << 1) | 1, rp->cw_max);
+
+		/* Total TX time after this try */
+		tx_time += ctime + overhead + tx_time_data;
+		tx_time_rtscts += ctime + overhead_rtscts + tx_time_data;
+
+		if (tx_time_rtscts < rp->segment_size)
+			rrs->retry_count_rtscts++;
+	} while ((tx_time < rp->segment_size) &&
+	         (++rrs->retry_count < rp->max_retry));
+}
+
+
+static void
+rhapsody_ht_set_rate(struct rhapsody_priv *rp, struct rhapsody_ht_sta *ri,
+                     struct ieee80211_sta_rates *ratetbl, int offset, int index)
+{
+	const struct mcs_group *group = &rhapsody_mcs_groups[index / MCS_GROUP_RATES];
+	struct rhapsody_rate_stats *rrs;
+	u8 idx;
+	u16 flags = group->flags;
+
+	rrs = rhapsody_get_ratestats(ri, index);
+	if (!rrs->retry_updated)
+		rhapsody_calc_retransmit(rp, ri, index);
+
+	if (rrs->prob_ewma < RHAPSODY_FRAC(20, 100) || !rrs->retry_count) {
+		ratetbl->rate[offset].count = 2;
+		ratetbl->rate[offset].count_rts = 2;
+		ratetbl->rate[offset].count_cts = 2;
+	} else {
+		ratetbl->rate[offset].count = rrs->retry_count;
+		ratetbl->rate[offset].count_cts = rrs->retry_count;
+		ratetbl->rate[offset].count_rts = rrs->retry_count_rtscts;
+	}
+
+	if (index / MCS_GROUP_RATES == RHAPSODY_CCK_GROUP)
+		idx = rp->cck_rates[index % ARRAY_SIZE(rp->cck_rates)];
+	else if (flags & IEEE80211_TX_RC_VHT_MCS)
+		idx = ((group->streams - 1) << 4) |
+		      ((index % MCS_GROUP_RATES) & 0xF);
+	else
+		idx = index % MCS_GROUP_RATES + (group->streams - 1) * 8;
+
+	if (offset > 0) {
+		ratetbl->rate[offset].count = ratetbl->rate[offset].count_rts;
+		flags |= IEEE80211_TX_RC_USE_RTS_CTS;
+	}
+
+	ratetbl->rate[offset].idx = idx;
+	ratetbl->rate[offset].flags = flags;
+}
+
+static void
+rhapsody_ht_update_rates(struct rhapsody_priv *rp, struct rhapsody_ht_sta *ri)
+{
+	struct ieee80211_sta_rates *rates;
+	int i = 0;
+
+	rates = kzalloc(sizeof(*rates), GFP_ATOMIC);
+	if (!rates)
+		return;
+
+	/* Start with max_tp_rate[0] */
+	rhapsody_ht_set_rate(rp, ri, rates, i++, ri->max_tp_rate[0]);
+
+	if (rp->hw->max_rates >= 3) {
+		/* At least 3 tx rates supported, use max_tp_rate[1] next */
+		rhapsody_ht_set_rate(rp, ri, rates, i++, ri->max_tp_rate[1]);
+	}
+
+	if (rp->hw->max_rates >= 2) {
+		/*
+		 * At least 2 tx rates supported, use max_prob_rate next */
+		rhapsody_ht_set_rate(rp, ri, rates, i++, ri->max_prob_rate);
+	}
+
+	rates->rate[i].idx = -1;
+	rate_control_set_rates(rp->hw, ri->sta, rates);
+}
+
+static inline int
+rhapsody_get_duration(int index)
+{
+	const struct mcs_group *group = &rhapsody_mcs_groups[index / MCS_GROUP_RATES];
+	return group->duration[index % MCS_GROUP_RATES];
+}
+
+static int
+rhapsody_get_sample_rate(struct rhapsody_priv *rp, struct rhapsody_ht_sta *ri)
+{
+	struct rhapsody_rate_stats *rrs;
+	struct rhapsody_mcs_group_data *rg;
+	unsigned int sample_dur, sample_group, cur_max_tp_streams;
+	int sample_idx = 0;
+
+	if (ri->sample_wait > 0) {
+		ri->sample_wait--;
+		return -1;
+	}
+
+	if (!ri->sample_tries)
+		return -1;
+
+	sample_group = ri->sample_group;
+	rg = &ri->groups[sample_group];
+	sample_idx = sample_table[rg->column][rg->index];
+	rhapsody_set_next_sample_idx(ri);
+
+	if (!(rg->supported & BIT(sample_idx)))
+		return -1;
+
+	rrs = &rg->rates[sample_idx];
+	sample_idx += sample_group * MCS_GROUP_RATES;
+
+	/*
+	 * Sampling might add some overhead (RTS, no aggregation)
+	 * to the frame. Hence, don't use sampling for the currently
+	 * used rates.
+	 */
+	if (sample_idx == ri->max_tp_rate[0] ||
+	    sample_idx == ri->max_tp_rate[1] ||
+	    sample_idx == ri->max_prob_rate)
+		return -1;
+
+	/*
+	 * Do not sample if the probability is already higher than 95%
+	 * to avoid wasting airtime.
+	 */
+	if (rrs->prob_ewma > RHAPSODY_FRAC(95, 100))
+		return -1;
+
+	/*
+	 * Make sure that lower rates get sampled only occasionally,
+	 * if the link is working perfectly.
+	 */
+
+	cur_max_tp_streams = rhapsody_mcs_groups[ri->max_tp_rate[0] /
+		MCS_GROUP_RATES].streams;
+	sample_dur = rhapsody_get_duration(sample_idx);
+	if (sample_dur >= rhapsody_get_duration(ri->max_tp_rate[1]) &&
+	    (cur_max_tp_streams - 1 <
+	     rhapsody_mcs_groups[sample_group].streams ||
+	     sample_dur >= rhapsody_get_duration(ri->max_prob_rate))) {
+		if (rrs->sample_skipped < 20)
+			return -1;
+
+		if (ri->sample_slow++ > 2)
+			return -1;
+	}
+	ri->sample_tries--;
+
+	return sample_idx;
+}
+
+static void
+rhapsody_ht_check_cck_shortpreamble(struct rhapsody_priv *rp,
+				    struct rhapsody_ht_sta *ri, bool val)
+{
+	u8 supported = ri->groups[RHAPSODY_CCK_GROUP].supported;
+
+	if (!supported || !ri->cck_supported_short)
+		return;
+
+	if (supported & (ri->cck_supported_short << (val * 4)))
+		return;
+
+	supported ^= ri->cck_supported_short | (ri->cck_supported_short << 4);
+	ri->groups[RHAPSODY_CCK_GROUP].supported = supported;
+}
+
+static void
+rhapsody_ht_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,
+                     struct ieee80211_tx_rate_control *txrc)
+{
+	const struct mcs_group *sample_group;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);
+	struct ieee80211_tx_rate *rate = &info->status.rates[0];
+	struct rhapsody_ht_sta_priv *rsp = priv_sta;
+	struct rhapsody_ht_sta *ri = &rsp->ht;
+	struct rhapsody_priv *rp = priv;
+	int sample_idx;
+
+	if (rate_control_send_low(sta, priv_sta, txrc))
+		return;
+
+	if (!rsp->is_ht)
+		return mac80211_rhapsody.get_rate(priv, sta, &rsp->legacy, txrc);
+
+	if (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&
+		ri->max_prob_rate / MCS_GROUP_RATES != RHAPSODY_CCK_GROUP)
+		rhapsody_aggr_check(sta, txrc->skb);
+
+	info->flags |= ri->tx_flags;
+	rhapsody_ht_check_cck_shortpreamble(rp, ri, txrc->short_preamble);
+
+#ifdef CPTCFG_MAC80211_DEBUGFS
+	if (rp->fixed_rate_idx != -1)
+		return;
+#endif
+
+	/* Don't use EAPOL frames for sampling on non-mrr hw */
+	if (rp->hw->max_rates == 1 &&
+	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
+		sample_idx = -1;
+	else
+		sample_idx = rhapsody_get_sample_rate(rp, ri);
+
+	ri->total_packets++;
+
+	/* wraparound */
+	if (ri->total_packets == ~0) {
+		ri->total_packets = 0;
+		ri->sample_packets = 0;
+	}
+
+	if (sample_idx < 0)
+		return;
+
+	sample_group = &rhapsody_mcs_groups[sample_idx / MCS_GROUP_RATES];
+	info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
+	rate->count = 1;
+
+	if (sample_idx / MCS_GROUP_RATES == RHAPSODY_CCK_GROUP) {
+		int idx = sample_idx % ARRAY_SIZE(rp->cck_rates);
+		rate->idx = rp->cck_rates[idx];
+	} else if (sample_group->flags & IEEE80211_TX_RC_VHT_MCS) {
+		ieee80211_rate_set_vht(rate, sample_idx % MCS_GROUP_RATES,
+				       sample_group->streams);
+	} else {
+		rate->idx = sample_idx % MCS_GROUP_RATES +
+			    (sample_group->streams - 1) * 8;
+	}
+
+	rate->flags = sample_group->flags;
+}
+
+static void
+rhapsody_ht_update_cck(struct rhapsody_priv *rp, struct rhapsody_ht_sta *ri,
+		       struct ieee80211_supported_band *sband,
+		       struct ieee80211_sta *sta)
+{
+	int i;
+
+	if (sband->band != IEEE80211_BAND_2GHZ)
+		return;
+
+	if (!(rp->hw->flags & IEEE80211_HW_SUPPORTS_HT_CCK_RATES))
+		return;
+
+	ri->cck_supported = 0;
+	ri->cck_supported_short = 0;
+	for (i = 0; i < 4; i++) {
+		if (!rate_supported(sta, sband->band, rp->cck_rates[i]))
+			continue;
+
+		ri->cck_supported |= BIT(i);
+		if (sband->bitrates[i].flags & IEEE80211_RATE_SHORT_PREAMBLE)
+			ri->cck_supported_short |= BIT(i);
+	}
+
+	ri->groups[RHAPSODY_CCK_GROUP].supported = ri->cck_supported;
+}
+
+static void
+rhapsody_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
+			struct cfg80211_chan_def *chandef,
+                        struct ieee80211_sta *sta, void *priv_sta)
+{
+	struct rhapsody_priv *rp = priv;
+	struct rhapsody_ht_sta_priv *rsp = priv_sta;
+	struct rhapsody_ht_sta *ri = &rsp->ht;
+	struct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;
+	u16 sta_cap = sta->ht_cap.cap;
+	struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;
+	int use_vht;
+	int n_supported = 0;
+	int ack_dur;
+	int stbc;
+	int i;
+
+	/* fall back to the old rhapsody for legacy stations */
+	if (!sta->ht_cap.ht_supported)
+		goto use_legacy;
+
+	BUILD_BUG_ON(ARRAY_SIZE(rhapsody_mcs_groups) != RHAPSODY_GROUPS_NB);
+
+#ifdef CPTCFG_MAC80211_RC_RHAPSODY_BLUES_VHT
+	if (vht_cap->vht_supported)
+		use_vht = vht_cap->vht_mcs.tx_mcs_map != cpu_to_le16(~0);
+	else
+#endif
+	use_vht = 0;
+
+	rsp->is_ht = true;
+	memset(ri, 0, sizeof(*ri));
+
+	ri->sta = sta;
+	ri->last_stats_update = jiffies;
+
+	ack_dur = ieee80211_frame_duration(sband->band, 10, 60, 1, 1, 0);
+	ri->overhead = ieee80211_frame_duration(sband->band, 0, 60, 1, 1, 0);
+	ri->overhead += ack_dur;
+	ri->overhead_rtscts = ri->overhead + 2 * ack_dur;
+
+	ri->avg_ampdu_len = RHAPSODY_FRAC(1, 1);
+
+	/* When using MRR, sample more on the first attempt, without delay */
+	if (rp->has_mrr) {
+		ri->sample_count = 16;
+		ri->sample_wait = 0;
+	} else {
+		ri->sample_count = 8;
+		ri->sample_wait = 8;
+	}
+	ri->sample_tries = 4;
+
+	/* TODO tx_flags for vht - ATM the RC API is not fine-grained enough */
+	if (!use_vht) {
+		stbc = (sta_cap & IEEE80211_HT_CAP_RX_STBC) >>
+			IEEE80211_HT_CAP_RX_STBC_SHIFT;
+		ri->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;
+
+		if (sta_cap & IEEE80211_HT_CAP_LDPC_CODING)
+			ri->tx_flags |= IEEE80211_TX_CTL_LDPC;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ri->groups); i++) {
+		u32 gflags = rhapsody_mcs_groups[i].flags;
+		int bw, nss;
+
+		ri->groups[i].supported = 0;
+		if (i == RHAPSODY_CCK_GROUP) {
+			rhapsody_ht_update_cck(rp, ri, sband, sta);
+			continue;
+		}
+
+		if (gflags & IEEE80211_TX_RC_SHORT_GI) {
+			if (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH) {
+				if (!(sta_cap & IEEE80211_HT_CAP_SGI_40))
+					continue;
+			} else {
+				if (!(sta_cap & IEEE80211_HT_CAP_SGI_20))
+					continue;
+			}
+		}
+
+		if (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH &&
+		    sta->bandwidth < IEEE80211_STA_RX_BW_40)
+			continue;
+
+		nss = rhapsody_mcs_groups[i].streams;
+
+		/* Mark MCS > 7 as unsupported if STA is in static SMPS mode */
+		if (sta->smps_mode == IEEE80211_SMPS_STATIC && nss > 1)
+			continue;
+
+		/* HT rate */
+		if (gflags & IEEE80211_TX_RC_MCS) {
+#ifdef CPTCFG_MAC80211_RC_RHAPSODY_BLUES_VHT
+			if (use_vht && rhapsody_vht_only)
+				continue;
+#endif
+			ri->groups[i].supported = mcs->rx_mask[nss - 1];
+			if (ri->groups[i].supported)
+				n_supported++;
+			continue;
+		}
+
+		/* VHT rate */
+		if (!vht_cap->vht_supported ||
+		    WARN_ON(!(gflags & IEEE80211_TX_RC_VHT_MCS)) ||
+		    WARN_ON(gflags & IEEE80211_TX_RC_160_MHZ_WIDTH))
+			continue;
+
+		if (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH) {
+			if (sta->bandwidth < IEEE80211_STA_RX_BW_80 ||
+			    ((gflags & IEEE80211_TX_RC_SHORT_GI) &&
+			     !(vht_cap->cap & IEEE80211_VHT_CAP_SHORT_GI_80))) {
+				continue;
+			}
+		}
+
+		if (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+			bw = BW_40;
+		else if (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH)
+			bw = BW_80;
+		else
+			bw = BW_20;
+
+		ri->groups[i].supported = rhapsody_get_valid_vht_rates(bw, nss,
+				vht_cap->vht_mcs.tx_mcs_map);
+
+		if (ri->groups[i].supported)
+			n_supported++;
+	}
+
+	if (!n_supported)
+		goto use_legacy;
+
+	/* create an initial rate table with the lowest supported rates */
+	rhapsody_ht_update_stats(rp, ri);
+	rhapsody_ht_update_rates(rp, ri);
+
+	return;
+
+use_legacy:
+	rsp->is_ht = false;
+	memset(&rsp->legacy, 0, sizeof(rsp->legacy));
+	rsp->legacy.r = rsp->ratelist;
+	rsp->legacy.sample_table = rsp->sample_table;
+	return mac80211_rhapsody.rate_init(priv, sband, chandef, sta,
+					   &rsp->legacy);
+}
+
+static void
+rhapsody_ht_rate_init(void *priv, struct ieee80211_supported_band *sband,
+		      struct cfg80211_chan_def *chandef,
+                      struct ieee80211_sta *sta, void *priv_sta)
+{
+	rhapsody_ht_update_caps(priv, sband, chandef, sta, priv_sta);
+}
+
+static void
+rhapsody_ht_rate_update(void *priv, struct ieee80211_supported_band *sband,
+			struct cfg80211_chan_def *chandef,
+                        struct ieee80211_sta *sta, void *priv_sta,
+                        u32 changed)
+{
+	rhapsody_ht_update_caps(priv, sband, chandef, sta, priv_sta);
+}
+
+static void *
+rhapsody_ht_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)
+{
+	struct ieee80211_supported_band *sband;
+	struct rhapsody_ht_sta_priv *rsp;
+	struct rhapsody_priv *rp = priv;
+	struct ieee80211_hw *hw = rp->hw;
+	int max_rates = 0;
+	int i;
+
+	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
+		sband = hw->wiphy->bands[i];
+		if (sband && sband->n_bitrates > max_rates)
+			max_rates = sband->n_bitrates;
+	}
+
+	rsp = kzalloc(sizeof(*rsp), gfp);
+	if (!rsp)
+		return NULL;
+
+	rsp->ratelist = kzalloc(sizeof(struct rhapsody_rate) * max_rates, gfp);
+	if (!rsp->ratelist)
+		goto error;
+
+	rsp->sample_table = kmalloc(SAMPLE_COLUMNS * max_rates, gfp);
+	if (!rsp->sample_table)
+		goto error1;
+
+	return rsp;
+
+error1:
+	kfree(rsp->ratelist);
+error:
+	kfree(rsp);
+	return NULL;
+}
+
+static void
+rhapsody_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
+{
+	struct rhapsody_ht_sta_priv *rsp = priv_sta;
+
+	kfree(rsp->sample_table);
+	kfree(rsp->ratelist);
+	kfree(rsp);
+}
+
+static void *
+rhapsody_ht_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
+{
+	return mac80211_rhapsody.alloc(hw, debugfsdir);
+}
+
+static void
+rhapsody_ht_free(void *priv)
+{
+	mac80211_rhapsody.free(priv);
+}
+
+static u32 rhapsody_ht_get_expected_throughput(void *priv_sta)
+{
+	struct rhapsody_ht_sta_priv *rsp = priv_sta;
+	struct rhapsody_ht_sta *ri = &rsp->ht;
+	int i, j, tp_avg;
+
+	if (!rsp->is_ht)
+		return mac80211_rhapsody.get_expected_throughput(priv_sta);
+
+	i = ri->max_tp_rate[0] / MCS_GROUP_RATES;
+	j = ri->max_tp_rate[0] % MCS_GROUP_RATES;
+
+	/* convert tp_avg from pkt per second in kbps */
+	tp_avg = rhapsody_ht_get_tp_avg(ri, i, j) * AVG_PKT_SIZE * 8 / 1024;
+
+	return tp_avg;
+}
+
+static const struct rate_control_ops mac80211_rhapsody_ht = {
+	.name = "rhapsody_ht",
+	.tx_status_noskb = rhapsody_ht_tx_status,
+	.get_rate = rhapsody_ht_get_rate,
+	.rate_init = rhapsody_ht_rate_init,
+	.rate_update = rhapsody_ht_rate_update,
+	.alloc_sta = rhapsody_ht_alloc_sta,
+	.free_sta = rhapsody_ht_free_sta,
+	.alloc = rhapsody_ht_alloc,
+	.free = rhapsody_ht_free,
+#ifdef CPTCFG_MAC80211_DEBUGFS
+	.add_sta_debugfs = rhapsody_ht_add_sta_debugfs,
+	.remove_sta_debugfs = rhapsody_ht_remove_sta_debugfs,
+#endif
+	.get_expected_throughput = rhapsody_ht_get_expected_throughput,
+};
+
+
+static void __init init_sample_table(void)
+{
+	int col, i, new_idx;
+	u8 rnd[MCS_GROUP_RATES];
+
+	memset(sample_table, 0xff, sizeof(sample_table));
+	for (col = 0; col < SAMPLE_COLUMNS; col++) {
+		prandom_bytes(rnd, sizeof(rnd));
+		for (i = 0; i < MCS_GROUP_RATES; i++) {
+			new_idx = (i + rnd[i]) % MCS_GROUP_RATES;
+			while (sample_table[col][new_idx] != 0xff)
+				new_idx = (new_idx + 1) % MCS_GROUP_RATES;
+
+			sample_table[col][new_idx] = i;
+		}
+	}
+}
+
+int __init
+rc80211_rhapsody_ht_init(void)
+{
+	init_sample_table();
+	return ieee80211_rate_control_register(&mac80211_rhapsody_ht);
+}
+
+void
+rc80211_rhapsody_ht_exit(void)
+{
+	ieee80211_rate_control_unregister(&mac80211_rhapsody_ht);
+}
Index: compat-wireless-2014-11-04/net/mac80211/rc80211_rhapsody_ht.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ compat-wireless-2014-11-04/net/mac80211/rc80211_rhapsody_ht.h	2015-02-13 16:12:26.159172304 +0100
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2015 Thomas Huehn <thomas@inet.tu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on minstrel_ht.h:
+ *   Copyright (C) 2010-20014 Felix Fietkau <nbd@openwrt.org>
+ *   Sponsored by OpenWRT.org
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer,
+ *      without modification.
+ *   2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *      similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
+ *      redistribution must be conditioned upon including a substantially
+ *      similar Disclaimer requirement for further binary redistribution.
+ *   3. Neither the names of the above-listed copyright holders nor the names
+ *      of any contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *   Alternatively, this software may be distributed under the terms of the
+ *   GNU General Public License ("GPL") version 2 as published by the Free
+ *   Software Foundation.
+ *
+ *   NO WARRANTY
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
+ *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ *   THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
+ *   OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ *   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *   THE POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __RC_RHAPSODY_HT_H
+#define __RC_RHAPSODY_HT_H
+
+/*
+ * The number of streams can be changed to 2 to reduce code
+ * size and memory footprint.
+ */
+#define RHAPSODY_MAX_STREAMS		3
+#define RHAPSODY_HT_STREAM_GROUPS	4 /* BW(=2) * SGI(=2) */
+#ifdef CPTCFG_MAC80211_RC_RHAPSODY_BLUES_VHT
+#define RHAPSODY_VHT_STREAM_GROUPS	6 /* BW(=3) * SGI(=2) */
+#else
+#define RHAPSODY_VHT_STREAM_GROUPS	0
+#endif
+
+#define RHAPSODY_HT_GROUPS_NB	(RHAPSODY_MAX_STREAMS *		\
+				 RHAPSODY_HT_STREAM_GROUPS)
+#define RHAPSODY_VHT_GROUPS_NB	(RHAPSODY_MAX_STREAMS *		\
+				 RHAPSODY_VHT_STREAM_GROUPS)
+#define RHAPSODY_CCK_GROUPS_NB	1
+#define RHAPSODY_GROUPS_NB	(RHAPSODY_HT_GROUPS_NB +	\
+				 RHAPSODY_VHT_GROUPS_NB +	\
+				 RHAPSODY_CCK_GROUPS_NB)
+
+#define RHAPSODY_HT_GROUP_0	0
+#define RHAPSODY_CCK_GROUP	(RHAPSODY_HT_GROUP_0 + RHAPSODY_HT_GROUPS_NB)
+#define RHAPSODY_VHT_GROUP_0	(RHAPSODY_CCK_GROUP + 1)
+
+#ifdef CPTCFG_MAC80211_RC_RHAPSODY_BLUES_VHT
+#define MCS_GROUP_RATES		10
+#else
+#define MCS_GROUP_RATES		8
+#endif
+
+struct mcs_group {
+	u32 flags;
+	unsigned int streams;
+	unsigned int duration[MCS_GROUP_RATES];
+};
+
+extern const struct mcs_group rhapsody_mcs_groups[];
+
+struct rhapsody_mcs_group_data {
+	u8 index;
+	u8 column;
+
+	/* bitfield of supported MCS rates of this group */
+	u16 supported;
+
+	/* sorted rate set within a MCS group*/
+	u16 max_group_tp_rate[MAX_THR_RATES];
+	u16 max_group_prob_rate;
+
+	/* MCS rate statistics */
+	struct rhapsody_rate_stats rates[MCS_GROUP_RATES];
+};
+
+struct rhapsody_ht_sta {
+	struct ieee80211_sta *sta;
+
+	/* ampdu length (average, per sampling interval) */
+	unsigned int ampdu_len;
+	unsigned int ampdu_packets;
+
+	/* ampdu length (EWMA) */
+	unsigned int avg_ampdu_len;
+
+	/* overall sorted rate set */
+	u16 max_tp_rate[MAX_THR_RATES];
+	u16 max_prob_rate;
+
+	/* time of last status update */
+	unsigned long last_stats_update;
+
+	/* overhead time in usec for each frame */
+	unsigned int overhead;
+	unsigned int overhead_rtscts;
+
+	unsigned int total_packets;
+	unsigned int sample_packets;
+
+	/* tx flags to add for frames for this sta */
+	u32 tx_flags;
+
+	u8 sample_wait;
+	u8 sample_tries;
+	u8 sample_count;
+	u8 sample_slow;
+
+	/* current MCS group to be sampled */
+	u8 sample_group;
+
+	u8 cck_supported;
+	u8 cck_supported_short;
+
+	/* MCS rate group info and statistics */
+	struct rhapsody_mcs_group_data groups[RHAPSODY_GROUPS_NB];
+};
+
+struct rhapsody_ht_sta_priv {
+	union {
+		struct rhapsody_ht_sta ht;
+		struct rhapsody_sta_info legacy;
+	};
+#ifdef CPTCFG_MAC80211_DEBUGFS
+	struct dentry *dbg_stats;
+	struct dentry *dbg_stats_csv;
+#endif
+	void *ratelist;
+	void *sample_table;
+	bool is_ht;
+};
+
+void rhapsody_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+void rhapsody_ht_remove_sta_debugfs(void *priv, void *priv_sta);
+int rhapsody_ht_get_tp_avg(struct rhapsody_ht_sta *ri, int group, int rate);
+int rhapsody_ht_get_tp_max(struct rhapsody_ht_sta *ri, int group, int rate);
+
+#endif
Index: compat-wireless-2014-11-04/net/mac80211/rc80211_rhapsody_ht_debugfs.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ compat-wireless-2014-11-04/net/mac80211/rc80211_rhapsody_ht_debugfs.c	2015-02-13 16:13:00.595869491 +0100
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2015 Thomas Huehn <thomas@inet.tu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on minstrel_ht_debugfs.c:
+ *   Copyright (C) 2010-20014 Felix Fietkau <nbd@openwrt.org>
+ *   Sponsored by OpenWRT.org
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer,
+ *      without modification.
+ *   2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *      similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
+ *      redistribution must be conditioned upon including a substantially
+ *      similar Disclaimer requirement for further binary redistribution.
+ *   3. Neither the names of the above-listed copyright holders nor the names
+ *      of any contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *   Alternatively, this software may be distributed under the terms of the
+ *   GNU General Public License ("GPL") version 2 as published by the Free
+ *   Software Foundation.
+ *
+ *   NO WARRANTY
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
+ *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ *   THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
+ *   OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ *   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *   THE POSSIBILITY OF SUCH DAMAGES.
+ */
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/debugfs.h>
+#include <linux/ieee80211.h>
+#include <linux/export.h>
+#include <net/mac80211.h>
+#include "rc80211_rhapsody.h"
+#include "rc80211_rhapsody_ht.h"
+
+static char *
+rhapsody_ht_stats_dump(struct rhapsody_ht_sta *ri, int i, char *p)
+{
+	const struct mcs_group *mg;
+	unsigned int j, tp_max, tp_avg, prob, eprob, tx_time;
+	char htmode = '2';
+	char gimode = 'L';
+	u32 gflags;
+
+	if (!ri->groups[i].supported)
+		return p;
+
+	mg = &rhapsody_mcs_groups[i];
+	gflags = mg->flags;
+
+	if (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+		htmode = '4';
+	else if (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH)
+		htmode = '8';
+	if (gflags & IEEE80211_TX_RC_SHORT_GI)
+		gimode = 'S';
+
+	for (j = 0; j < MCS_GROUP_RATES; j++) {
+		struct rhapsody_rate_stats *rrs = &ri->groups[i].rates[j];
+		static const int bitrates[4] = { 10, 20, 55, 110 };
+		int idx = i * MCS_GROUP_RATES + j;
+
+		if (!(ri->groups[i].supported & BIT(j)))
+			continue;
+
+		if (gflags & IEEE80211_TX_RC_MCS) {
+			p += sprintf(p, "HT%c0  ", htmode);
+			p += sprintf(p, "%cGI  ", gimode);
+			p += sprintf(p, "%d  ", mg->streams);
+		} else if (gflags & IEEE80211_TX_RC_VHT_MCS) {
+			p += sprintf(p, "VHT%c0 ", htmode);
+			p += sprintf(p, "%cGI ", gimode);
+			p += sprintf(p, "%d  ", mg->streams);
+		} else {
+			p += sprintf(p, "CCK    ");
+			p += sprintf(p, "%cP  ", j < 4 ? 'L' : 'S');
+			p += sprintf(p, "1 ");
+		}
+
+		*(p++) = (idx == ri->max_tp_rate[0]) ? 'A' : ' ';
+		*(p++) = (idx == ri->max_tp_rate[1]) ? 'B' : ' ';
+		*(p++) = (idx == ri->max_tp_rate[2]) ? 'C' : ' ';
+		*(p++) = (idx == ri->max_tp_rate[3]) ? 'D' : ' ';
+		*(p++) = (idx == ri->max_prob_rate) ? 'P' : ' ';
+
+		if (gflags & IEEE80211_TX_RC_MCS) {
+			p += sprintf(p, "  MCS%-2u", (mg->streams - 1) * 8 + j);
+		} else if (gflags & IEEE80211_TX_RC_VHT_MCS) {
+			p += sprintf(p, "  MCS%-1u/%1u", j, mg->streams);
+		} else {
+			int r = bitrates[j % 4];
+
+			p += sprintf(p, "   %2u.%1uM", r / 10, r % 10);
+		}
+
+		p += sprintf(p, "  %3u  ", idx);
+
+		/* tx_time[rate(i)] in usec */
+		tx_time = DIV_ROUND_CLOSEST(mg->duration[j], 1000);
+		p += sprintf(p, "%6u  ", tx_time);
+
+		tp_max = rhapsody_ht_get_tp_max(ri, i, j);
+		tp_avg = rhapsody_ht_get_tp_avg(ri, i, j);
+		prob = RHAPSODY_TRUNC(rrs->cur_prob * 1000);
+		eprob = RHAPSODY_TRUNC(rrs->prob_ewma * 1000);
+
+		p += sprintf(p, "%4u.%1u   %4u.%1u   %3u.%1u    %3u.%1u"
+				"     %3u.%1u %3u   %3u %-3u   "
+				"%9llu   %-9llu\n",
+				tp_max / 10, tp_max % 10,
+				tp_avg / 10, tp_avg % 10,
+				eprob / 10, eprob % 10,
+				rrs->prob_ewmsd / 10, rrs->prob_ewmsd % 10,
+				prob / 10, prob % 10,
+				rrs->retry_count,
+				rrs->last_success,
+				rrs->last_attempts,
+				(unsigned long long)rrs->succ_hist,
+				(unsigned long long)rrs->att_hist);
+	}
+
+	return p;
+}
+
+static int
+rhapsody_ht_stats_open(struct inode *inode, struct file *file)
+{
+	struct rhapsody_ht_sta_priv *rsp = inode->i_private;
+	struct rhapsody_ht_sta *ri = &rsp->ht;
+	struct rhapsody_debugfs_info *rs;
+	unsigned int i;
+	int ret;
+	char *p;
+
+	if (!rsp->is_ht) {
+		inode->i_private = &rsp->legacy;
+		ret = rhapsody_stats_open(inode, file);
+		inode->i_private = rsp;
+		return ret;
+	}
+
+	rs = kmalloc(32768, GFP_KERNEL);
+	if (!rs)
+		return -ENOMEM;
+
+	file->private_data = rs;
+	p = rs->buf;
+
+	p += sprintf(p, "\n");
+	p += sprintf(p, "              best   ____________rate__________    "
+			"______statistics______    ________last_______    "
+			"______sum-of________\n");
+	p += sprintf(p, "mode guard #  rate  [name   idx airtime  max_tp]  "
+			"[ ø(tp) ø(prob) sd(prob)]  [prob.|retry|suc|att]  [#success | "
+			"#attempts]\n");
+
+	p = rhapsody_ht_stats_dump(ri, RHAPSODY_CCK_GROUP, p);
+	for (i = 0; i < RHAPSODY_CCK_GROUP; i++)
+		p = rhapsody_ht_stats_dump(ri, i, p);
+	for (i++; i < ARRAY_SIZE(ri->groups); i++)
+		p = rhapsody_ht_stats_dump(ri, i, p);
+
+	p += sprintf(p, "\nTotal packet count::    ideal %d      "
+			"lookaround %d\n",
+			max(0, (int) ri->total_packets - (int) ri->sample_packets),
+			ri->sample_packets);
+	p += sprintf(p, "Average # of aggregated frames per A-MPDU: %d.%d\n",
+		RHAPSODY_TRUNC(ri->avg_ampdu_len),
+		RHAPSODY_TRUNC(ri->avg_ampdu_len * 10) % 10);
+	rs->len = p - rs->buf;
+	WARN_ON(rs->len + sizeof(*rs) > 32768);
+
+	return nonseekable_open(inode, file);
+}
+
+static const struct file_operations rhapsody_ht_stat_fops = {
+	.owner = THIS_MODULE,
+	.open = rhapsody_ht_stats_open,
+	.read = rhapsody_stats_read,
+	.release = rhapsody_stats_release,
+	.llseek = no_llseek,
+};
+
+static char *
+rhapsody_ht_stats_csv_dump(struct rhapsody_ht_sta *ri, int i, char *p,
+			    struct timeval tv)
+{
+	const struct mcs_group *mg;
+	unsigned int j, tp_max, tp_avg, prob, eprob, tx_time;
+	char htmode = '2';
+	char gimode = 'L';
+	u32 gflags;
+
+	if (!ri->groups[i].supported)
+		return p;
+
+	mg = &rhapsody_mcs_groups[i];
+	gflags = mg->flags;
+
+	if (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+		htmode = '4';
+	else if (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH)
+		htmode = '8';
+	if (gflags & IEEE80211_TX_RC_SHORT_GI)
+		gimode = 'S';
+
+	for (j = 0; j < MCS_GROUP_RATES; j++) {
+		struct rhapsody_rate_stats *rrs = &ri->groups[i].rates[j];
+		static const int bitrates[4] = { 10, 20, 55, 110 };
+		int idx = i * MCS_GROUP_RATES + j;
+
+		if (!(ri->groups[i].supported & BIT(j)))
+			continue;
+
+		p += sprintf(p, "%ld.%.6ld,", tv.tv_sec, tv.tv_usec);
+
+		if (gflags & IEEE80211_TX_RC_MCS) {
+			p += sprintf(p, "HT%c0,", htmode);
+			p += sprintf(p, "%cGI,", gimode);
+			p += sprintf(p, "%d,", mg->streams);
+		} else if (gflags & IEEE80211_TX_RC_VHT_MCS) {
+			p += sprintf(p, "VHT%c0,", htmode);
+			p += sprintf(p, "%cGI,", gimode);
+			p += sprintf(p, "%d,", mg->streams);
+		} else {
+			p += sprintf(p, "CCK,");
+			p += sprintf(p, "%cP,", j < 4 ? 'L' : 'S');
+			p += sprintf(p, "1,");
+		}
+
+		p += sprintf(p, "%s" ,((idx == ri->max_tp_rate[0]) ? "A," : ","));
+		p += sprintf(p, "%s" ,((idx == ri->max_tp_rate[1]) ? "B," : ","));
+		p += sprintf(p, "%s" ,((idx == ri->max_tp_rate[2]) ? "C," : ","));
+		p += sprintf(p, "%s" ,((idx == ri->max_tp_rate[3]) ? "D," : ","));
+		p += sprintf(p, "%s" ,((idx == ri->max_prob_rate) ? "P," : ","));
+
+		if (gflags & IEEE80211_TX_RC_MCS) {
+			p += sprintf(p, "MCS%-2u,", (mg->streams - 1) * 8 + j);
+		} else if (gflags & IEEE80211_TX_RC_VHT_MCS) {
+			p += sprintf(p, "MCS%-1u/%1u,", j, mg->streams);
+		} else {
+			int r = bitrates[j % 4];
+			p += sprintf(p, "%2u.%1uM,", r / 10, r % 10);
+		}
+
+		p += sprintf(p, "%u,", idx);
+		tx_time = DIV_ROUND_CLOSEST(mg->duration[j], 1000);
+		p += sprintf(p, "%u,", tx_time);
+
+		tp_max = rhapsody_ht_get_tp_max(ri, i, j);
+		tp_avg = rhapsody_ht_get_tp_avg(ri, i, j);
+		prob = RHAPSODY_TRUNC(rrs->cur_prob * 1000);
+		eprob = RHAPSODY_TRUNC(rrs->prob_ewma * 1000);
+
+		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u.%u,%u.%u,%u,%u,"
+				"%u,%llu,%llu,",
+				tp_max / 10, tp_max % 10,
+				tp_avg / 10, tp_avg % 10,
+				eprob / 10, eprob % 10,
+				rrs->prob_ewmsd / 10, rrs->prob_ewmsd % 10,
+				prob / 10, prob % 10,
+				rrs->retry_count,
+				rrs->last_success,
+				rrs->last_attempts,
+				(unsigned long long)rrs->succ_hist,
+				(unsigned long long)rrs->att_hist);
+		p += sprintf(p, "%d,%d,%d.%d\n",
+				max(0, (int) ri->total_packets -
+				(int) ri->sample_packets),
+				ri->sample_packets,
+				RHAPSODY_TRUNC(ri->avg_ampdu_len),
+				RHAPSODY_TRUNC(ri->avg_ampdu_len * 10) % 10);
+	}
+
+	return p;
+}
+
+static int
+rhapsody_ht_stats_csv_open(struct inode *inode, struct file *file)
+{
+	struct rhapsody_ht_sta_priv *rsp = inode->i_private;
+	struct rhapsody_ht_sta *ri = &rsp->ht;
+	struct rhapsody_debugfs_info *rs;
+	struct timeval tv;
+	unsigned int i;
+	int ret;
+	char *p;
+
+	do_gettimeofday(&tv);
+
+	if (!rsp->is_ht) {
+		inode->i_private = &rsp->legacy;
+		ret = rhapsody_stats_csv_open(inode, file);
+		inode->i_private = rsp;
+		return ret;
+	}
+
+	rs = kmalloc(32768, GFP_KERNEL);
+
+	if (!rs)
+		return -ENOMEM;
+
+	file->private_data = rs;
+
+	p = rs->buf;
+
+	p = rhapsody_ht_stats_csv_dump(ri, RHAPSODY_CCK_GROUP, p, tv);
+	for (i = 0; i < RHAPSODY_CCK_GROUP; i++)
+		p = rhapsody_ht_stats_csv_dump(ri, i, p, tv);
+	for (i++; i < ARRAY_SIZE(ri->groups); i++)
+		p = rhapsody_ht_stats_csv_dump(ri, i, p, tv);
+
+	rs->len = p - rs->buf;
+	WARN_ON(rs->len + sizeof(*rs) > 32768);
+
+	return nonseekable_open(inode, file);
+}
+
+static const struct file_operations rhapsody_ht_stat_csv_fops = {
+	.owner = THIS_MODULE,
+	.open = rhapsody_ht_stats_csv_open,
+	.read = rhapsody_stats_read,
+	.release = rhapsody_stats_release,
+	.llseek = no_llseek,
+};
+
+void
+rhapsody_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir)
+{
+	struct rhapsody_ht_sta_priv *rsp = priv_sta;
+
+	rsp->dbg_stats = debugfs_create_file("rhapsody_stats", S_IRUGO, dir, rsp,
+			&rhapsody_ht_stat_fops);
+	rsp->dbg_stats_csv = debugfs_create_file("rhapsody_stats_csv", S_IRUGO,
+			     dir, rsp, &rhapsody_ht_stat_csv_fops);
+}
+
+void
+rhapsody_ht_remove_sta_debugfs(void *priv, void *priv_sta)
+{
+	struct rhapsody_ht_sta_priv *rsp = priv_sta;
+
+	debugfs_remove(rsp->dbg_stats);
+	debugfs_remove(rsp->dbg_stats_csv);
+}
