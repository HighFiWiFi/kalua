Index: compat-wireless-2014-11-04/net/mac80211/rc80211_minstrel.c
===================================================================
--- compat-wireless-2014-11-04.orig/net/mac80211/rc80211_minstrel.c	2015-02-05 17:54:19.986697464 +0100
+++ compat-wireless-2014-11-04/net/mac80211/rc80211_minstrel.c	2015-02-05 17:54:19.982697383 +0100
@@ -143,8 +143,8 @@
 {
 	int j = MAX_THR_RATES;
 
-	while (j > 0 && (minstrel_get_tp_avg(&mi->r[i]) >
-				minstrel_get_tp_avg(&mi->r[tp_list[j - 1]])))
+	while (j > 0 && (minstrel_get_tp_5_percent_quantile(&mi->r[i]) >
+			 minstrel_get_tp_5_percent_quantile(&mi->r[tp_list[j - 1]])))
 		j--;
 	if (j < MAX_THR_RATES - 1)
 		memmove(&tp_list[j + 1], &tp_list[j], MAX_THR_RATES - (j + 1));
@@ -152,6 +152,34 @@
 		tp_list[j] = i;
 }
 
+/* find & return topmost probability rate */
+static inline int
+minstrel_get_best_prob_rate(struct minstrel_sta_info *mi, int i)
+{
+	struct minstrel_rate *mr = &mi->r[i];
+	int cur_tp, prob_tp;
+	u8 tmp_prob_rate = 0;
+
+	/* To determine the most robust rate (max_prob_rate) used at
+	 * 3rd mmr stage we distinct between two cases:
+	 * (1) if any success probabilitiy >= 95%, out of those rates
+	 * choose the maximum throughput rate as max_prob_rate
+	 * (2) if all success probabilities < 95%, the rate with
+	 * highest success probability is chosen as max_prob_rate */
+	if (minstrel_get_prob_5_percent_quantile(mr) >= MINSTREL_FRAC(95,100)) {
+		cur_tp = minstrel_get_tp_5_percent_quantile(mr);
+		prob_tp = minstrel_get_tp_5_percent_quantile(&mi->r[tmp_prob_rate]);
+		if (cur_tp >= prob_tp)
+			tmp_prob_rate = i;
+	} else {
+		if (minstrel_get_prob_5_percent_quantile(mr) >=
+		    minstrel_get_prob_5_percent_quantile(&mi->r[tmp_prob_rate]))
+			tmp_prob_rate = i;
+	}
+
+	return tmp_prob_rate;
+}
+
 static void
 minstrel_set_rate(struct minstrel_sta_info *mi, struct ieee80211_sta_rates *ratetbl,
 		  int offset, int idx)
@@ -236,7 +264,7 @@
 {
 	u8 tmp_tp_rate[MAX_THR_RATES];
 	u8 tmp_prob_rate = 0;
-	int i, tmp_cur_tp, tmp_prob_tp;
+	int i;
 
 	for (i = 0; i < MAX_THR_RATES; i++)
 	    tmp_tp_rate[i] = 0;
@@ -263,23 +291,9 @@
 		if (!mr->adjusted_retry_count)
 			mr->adjusted_retry_count = 2;
 
+		/* find fastest rate set and most robust rate */
 		minstrel_sort_best_tp_rates(mi, i, tmp_tp_rate);
-
-		/* To determine the most robust rate (max_prob_rate) used at
-		 * 3rd mmr stage we distinct between two cases:
-		 * (1) if any success probabilitiy >= 95%, out of those rates
-		 * choose the maximum throughput rate as max_prob_rate
-		 * (2) if all success probabilities < 95%, the rate with
-		 * highest success probability is chosen as max_prob_rate */
-		if (mrs->prob_ewma >= MINSTREL_FRAC(95, 100)) {
-			tmp_cur_tp = minstrel_get_tp_avg(mr);
-			tmp_prob_tp = minstrel_get_tp_avg(&mi->r[tmp_prob_rate]);
-			if (tmp_cur_tp >= tmp_prob_tp)
-				tmp_prob_rate = i;
-		} else {
-			if (mrs->prob_ewma >= mi->r[tmp_prob_rate].stats.prob_ewma)
-				tmp_prob_rate = i;
-		}
+		tmp_prob_rate = minstrel_get_best_prob_rate(mi, i);
 	}
 
 	/* Assign the new rate set */
Index: compat-wireless-2014-11-04/net/mac80211/rc80211_minstrel_ht.c
===================================================================
--- compat-wireless-2014-11-04.orig/net/mac80211/rc80211_minstrel_ht.c	2015-02-05 17:54:19.986697464 +0100
+++ compat-wireless-2014-11-04/net/mac80211/rc80211_minstrel_ht.c	2015-02-05 17:58:50.616163292 +0100
@@ -420,14 +420,20 @@
 
 	cur_group = index / MCS_GROUP_RATES;
 	cur_idx = index  % MCS_GROUP_RATES;
-	cur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx);
-	cur_prob = mi->groups[cur_group].rates[cur_idx].prob_ewma;
+	cur_tp_avg = minstrel_ht_get_tp_5_percent_quantile(mi, cur_group,
+							   cur_idx);
+	cur_prob = minstrel_ht_get_prob_5_percent_quantile(mi, cur_group,
+							   cur_idx);
 
 	do {
 		tmp_group = tp_list[j - 1] / MCS_GROUP_RATES;
 		tmp_idx = tp_list[j - 1] % MCS_GROUP_RATES;
-		tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx);
-		tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
+		tmp_tp_avg = minstrel_ht_get_tp_5_percent_quantile(mi,
+								   tmp_group,
+								   tmp_idx);
+		tmp_prob = minstrel_ht_get_prob_5_percent_quantile(mi,
+								   tmp_group,
+								   cur_idx);
 		if (cur_tp_avg < tmp_tp_avg ||
 		    (cur_tp_avg == tmp_tp_avg && cur_prob <= tmp_prob))
 			break;
@@ -449,21 +455,23 @@
 minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 index)
 {
 	struct minstrel_mcs_group_data *mg;
-	struct minstrel_rate_stats *mrs;
-	int tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;
-	int max_tp_group, cur_tp_avg, cur_group, cur_idx;
+	int tmp_group, tmp_idx, tmp_tp, tmp_prob;
+	int max_tp_group, cur_tp, cur_group, cur_idx, cur_prob;
 	int max_group_prob_rate_group, max_group_prob_rate_idx;
-	int max_group_prob_rate_tp_avg;
+	int max_group_prob_rate_tp, max_group_prob_rate_prob;
 
+	/* candidate rate that_is compared to the current_max_prob one */
 	cur_group = index / MCS_GROUP_RATES;
 	cur_idx = index % MCS_GROUP_RATES;
 	mg = &mi->groups[index / MCS_GROUP_RATES];
-	mrs = &mg->rates[index % MCS_GROUP_RATES];
-
+	cur_prob = minstrel_ht_get_prob_5_percent_quantile(mi, cur_group,
+							   cur_idx);
+	/* current max_prob_rate */
 	tmp_group = mi->max_prob_rate / MCS_GROUP_RATES;
 	tmp_idx = mi->max_prob_rate % MCS_GROUP_RATES;
-	tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx);
-	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
+	tmp_tp = minstrel_ht_get_tp_5_percent_quantile(mi, tmp_group, tmp_idx);
+	tmp_prob = minstrel_ht_get_prob_5_percent_quantile(mi, tmp_group,
+							   tmp_idx);
 
 	/* if max_tp_rate[0] is from MCS_GROUP max_prob_rate get selected from
 	 * MCS_GROUP as well as CCK_GROUP rates do not allow aggregation */
@@ -472,24 +480,34 @@
 	    (max_tp_group != MINSTREL_CCK_GROUP))
 		return;
 
-	if (mrs->prob_ewma > MINSTREL_FRAC(75, 100)) {
-		cur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx);
-		if (cur_tp_avg > tmp_tp_avg)
+	/* if success prob. > 75% sort best_prob_rate by throughput */
+	if (cur_prob > 750) {
+		cur_tp = minstrel_ht_get_tp_5_percent_quantile(mi, cur_group,
+							       cur_idx);
+		if (cur_tp > tmp_tp)
 			mi->max_prob_rate = index;
 
 		max_group_prob_rate_group = mg->max_group_prob_rate /
 								MCS_GROUP_RATES;
 		max_group_prob_rate_idx = mg->max_group_prob_rate %
 								MCS_GROUP_RATES;
-		max_group_prob_rate_tp_avg = minstrel_ht_get_tp_avg(mi,
-						max_group_prob_rate_group,
-						max_group_prob_rate_idx);
-		if (cur_tp_avg > max_group_prob_rate_tp_avg)
+		max_group_prob_rate_tp = minstrel_ht_get_tp_5_percent_quantile(mi,
+							max_group_prob_rate_group,
+							max_group_prob_rate_idx);
+		if (cur_tp > max_group_prob_rate_tp)
 			mg->max_group_prob_rate = index;
 	} else {
-		if (mrs->prob_ewma > tmp_prob)
+		if (cur_prob > tmp_prob)
 			mi->max_prob_rate = index;
-		if (mrs->prob_ewma > mg->rates[mg->max_group_prob_rate].prob_ewma)
+
+		max_group_prob_rate_group = mg->max_group_prob_rate /
+								MCS_GROUP_RATES;
+		max_group_prob_rate_idx = mg->max_group_prob_rate %
+								MCS_GROUP_RATES;
+		max_group_prob_rate_prob = minstrel_ht_get_prob_5_percent_quantile(mi,
+							max_group_prob_rate_group,
+							max_group_prob_rate_idx);
+		if (cur_prob > max_group_prob_rate_prob)
 			mg->max_group_prob_rate = index;
 	}
 }
@@ -511,11 +529,13 @@
 
 	tmp_group = tmp_cck_tp_rate[0] / MCS_GROUP_RATES;
 	tmp_idx = tmp_cck_tp_rate[0] % MCS_GROUP_RATES;
-	tmp_cck_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx);
+	tmp_cck_tp = minstrel_ht_get_tp_5_percent_quantile(mi, tmp_group,
+							   tmp_idx);
 
 	tmp_group = tmp_mcs_tp_rate[0] / MCS_GROUP_RATES;
 	tmp_idx = tmp_mcs_tp_rate[0] % MCS_GROUP_RATES;
-	tmp_mcs_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx);
+	tmp_mcs_tp = minstrel_ht_get_tp_5_percent_quantile(mi, tmp_group,
+							   tmp_idx);
 
 	if (tmp_cck_tp > tmp_mcs_tp) {
 		for(i = 0; i < MAX_THR_RATES; i++) {
@@ -523,7 +543,6 @@
 						       tmp_mcs_tp_rate);
 		}
 	}
-
 }
 
 /*
@@ -534,7 +553,7 @@
 minstrel_ht_prob_rate_reduce_streams(struct minstrel_ht_sta *mi)
 {
 	struct minstrel_mcs_group_data *mg;
-	int tmp_max_streams, group, tmp_idx;
+	int tmp_max_streams, group, cur_idx, cur_tp;
 	int tmp_tp = 0;
 
 	tmp_max_streams = minstrel_mcs_groups[mi->max_tp_rate[0] /
@@ -544,13 +563,13 @@
 		if (!mg->supported || group == MINSTREL_CCK_GROUP)
 			continue;
 
-		tmp_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
+		cur_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
+		cur_tp = minstrel_ht_get_tp_5_percent_quantile(mi, group, cur_idx);
 
-		if (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx) &&
+		if (tmp_tp < cur_tp &&
 		   (minstrel_mcs_groups[group].streams < tmp_max_streams)) {
 				mi->max_prob_rate = mg->max_group_prob_rate;
-				tmp_tp = minstrel_ht_get_tp_avg(mi, group,
-								tmp_idx);
+				tmp_tp = cur_tp;
 		}
 	}
 }
