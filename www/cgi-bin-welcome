#!/bin/sh

. /etc/functions_base_fff+

func_network_inet_seems_stable ()		# fixme! also check path to gateway (add wireless costs/hops)
{						# fixme! apply these checks regulary
	[ -z "$( ip route list exact 0/0 table main )" ] && return 1

	. /tmp/gateway_check_recent 2>/dev/null && [ "$COST_INT" 2>/dev/null -gt 8000 ] && return 1
	return 0
}

[ -n "$(nvram get fff_weblogin)" ] && {
	func_need http log
	eval $(_http query_string_sanitize)

	if [ "$REQUEST_METHOD" = "POST" ]; then

		if [ -n "$FORM_RULES" ]; then				# rules accepted	// fixme! more abstraction (client signal/rssi)
			func_need pfilter weblogin old vars_old
			MAC="$( fkt_get_mac_from_local_ip $REMOTE_ADDR )"
			SIGNAL="$( wl rssi $MAC 2>/dev/null | cut -d' ' -f3 )"		# not possible from LAN or WAN
			
			_log do weblogin_try daemon info "ip: '$REMOTE_ADDR' mac: '$MAC' user: '$FORM_USER' pass: '$FORM_PASS' signal: '$SIGNAL' lang: '$FORM_LANG'"

			# fixme! empty mac of REMOTE_ADDR -> redirect to real = nonlocal gateway ( ipsystem $REMOTE_ADDR | grep ^WIFI_ADDR )

			if func_weblogin_check_login "$FORM_USER" "$FORM_PASS" "$MAC" "$SIGNAL" ; then
				fkt_definitions
				
				if func_pfilter_user_unsplash "$MAC" "$REMOTE_ADDR" ; then
					_log do weblogin_success daemon alert "mac: '$MAC'"
				else
					_log do weblogin_no_success daemon alert "mac: '$MAC'"	
				fi
				
				_http redirect 302 landing_page
			else
				func_weblogin_check_login "$FORM_USER" "$FORM_PASS" "$MAC" "$SIGNAL" "plaintext"	# for plain logging on gateway
				_log do weblogin_failed daemon info "ip: '$REMOTE_ADDR'"
				func_weblogin_output_loginpage "$FORM_LANG" "$SHOW_RULES" "true"
			fi
		else						# fixme! send error(s!) to show (user,pass,rules,inetconnection...)
			func_need weblogin
			_log do weblogin_norules daemon info "ip: '$REMOTE_ADDR'"
			func_weblogin_output_loginpage "$FORM_LANG" "$SHOW_RULES" "false" "true"
		fi
	else
		if [ "$REDIRECTED" = "1" ]; then
			
			func_need weblogin

			if func_network_inet_seems_stable; then
				_log do weblogin_splash daemon info "ip: '$REMOTE_ADDR' lang: '${FORM_LANG}'"
				func_weblogin_output_loginpage "$FORM_LANG" "$SHOW_RULES"
			else
				_log do weblogin_inet_unstable daemon alert "inet_broken - lang: '$FORM_LANG' cost_int: '$COST_INT' default_route: '$( ip route list exact 0/0 table main )'"	# fixme! send_sms?
				func_weblogin_output_loginpage "$FORM_LANG" "inet_broken"
			fi
		else
			_log do weblogin_redirect daemon info "ip: '$REMOTE_ADDR' query: '$QUERY_STRING'"
			_http redirect 302 ip_incoming_interface
		fi
	fi

	exit
}

func_need vars_old old log http pfilter welcome

# _log do show_method_get daemon info "is '$QUERY_STRING'"

fkt_decide_usecase				# examine if user is already logged in or not
fkt_decide_mode					# assigns mode by examining remote-IP-address

case $MODE in
	REDIRECT_LAN|REDIRECT_WIFI)
	
		func_need weblogin
		func_weblogin_output_gate_page
		exit
	
		if [ "$MODE" = "REDIRECT_LAN" ]; then		# fixme! ip -o route get 10.63.167.70 | sed -n 's/^.*src \([0-9\.]*\).*/\1/p;q'
			_http redirect 302 ip_lan
		else
			_http redirect 302 ip_wifi
		fi
	;;
	SERVICE)
		fkt_print_html_header
		fkt_print_html_message_service
		fkt_print_html_footer
	;;
	WIFI|LAN)									# fixme! akzeptiere nutzungsbedingungen fehlt noch
		fkt_print_html_header
		
		MAC="$( fkt_get_mac_from_local_ip $REMOTE_ADDR )"
		IP=$REMOTE_ADDR								# fixme! really needed?
		
		fkt_definitions
		[ -z "$( fkt_list_locally_registered_users | grep -i $MAC )" ] && {
			fkt_print_html_link_to_usermanagement
		}
		
		if [ "$MODE" = "WIFI" ]; then
			fkt_print_html_message_wifi
		else
			fkt_print_html_message_lan
		fi
		
		fkt_print_wiki "$WIKI_ARTICLE_1" "$WIKI_ARTICLE_1_HEADLINE"
		fkt_print_news "$LATEST_NEWS_URL" "$LATEST_NEWS_HEADLINE"
		fkt_print_wiki "$WIKI_ARTICLE_2" "$WIKI_ARTICLE_2_HEADLINE"
										# fixme! nvram get fff_ethers_auth = BLACKLIST || WHITELIST !

		if [ "$( fkt_check_if_user_with_mac_is_locally_blacklisted $MAC )" = "true" ]; then
			
			fkt_print_html_you_are_blacklistet
		else
			if fkt_list_user_macs | grep -q -i $MAC ; then
			
				if [ "$( fkt_get_used_traffic_limit_from_user_with_mac_in_percent $MAC )" -gt 100 ] && [ "$( fkt_check_if_mac_is_admin $MAC )" = "false" ]; then
					fkt_print_html_user_over_limit
				else
					if [ "$( fkt_check_if_user_with_mac_is_redirected $MAC )" = "true" ]; then
						fkt_print_html_button
					else
						fkt_print_html_alread_logged_in
					fi
				fi
			else
				fkt_print_html_button
			fi
		fi
		
		fkt_print_html_footer
	;;
	WAN|REDIRECT_WAN)
		fkt_deliver_indexpage	
	;;
	BUTTON)							# fixme! print network / social-rules!
		fkt_print_html_header				# fixme! an attacker can refresh the POST-values in browser and again surf 15mins 8-)
		fkt_definitions					# same packet-filter vars...
		
		MAC="$( fkt_get_mac_from_local_ip $REMOTE_ADDR )"
		
		fkt_list_user_macs | grep -q -i $MAC								# already shaped?
		
		if [ "$?" -eq 0 ]; then										# user already shaped, but redirected (over night kick off...)
			fkt_control_redirect_for_user_with_mac_and_ip nosplash $MAC $REMOTE_ADDR >/dev/null
		else												# user is really new
			func_activate_reserved_user_chain $MAC $REMOTE_ADDR || {
				fkt_add_user_with_mac_and_ip $MAC $REMOTE_ADDR
			}
		fi
	
		fkt_print_html_message_welcome
		fkt_print_image_of_inet_gw
		fkt_print_html_footer			# fixme: maybe redirect to: "http://www.google.de/search?q=www.weimarnetz.de" ???
	;;
	*) 					# remote user is from mesh or localhost
		fkt_deliver_indexpage
	;;
esac
