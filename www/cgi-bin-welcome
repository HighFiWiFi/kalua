#!/bin/sh

. /etc/functions_base_fff+

func_network_inet_seems_stable ()		# fixme! also check path to gateway (add wireless costs/hops)
{						# fixme! apply these checks regulary
	[ -z "$( ip route list exact 0/0 table main )" ] && return 1

	. /tmp/gateway_check_recent 2>/dev/null && [ "$COST_INT" 2>/dev/null -gt 8000 ] && return 1
	return 0
}

case "$(nvram get fff_profile)" in
	*|elephant_mesh|elephant_ap|galerie_mesh|galerie_ap)
		func_need http log

		if [ "$REQUEST_METHOD" = "POST" ]; then
	
			eval $(func_http_sanitize_query_string)
			
			if [ -n "$FORM_RULES" ]; then
				func_need pfilter weblogin old vars_old
				MAC="$( fkt_get_mac_from_local_ip $REMOTE_ADDR )"
				func_log weblogin_try daemon info "ip: '$REMOTE_ADDR' mac: '$MAC' user: '$FORM_USER' pass: '$FORM_PASS'"

				# empty mac? redirect to real = nonlocal gateway ( ipsystem $REMOTE_ADDR | grep ^WIFI_ADDR )

				func_weblogin_check_login "$FORM_USER" "$FORM_PASS" "$MAC" && {
					fkt_definitions
					func_pfilter_user_unsplash "$MAC" "$REMOTE_ADDR" && {
						func_log weblogin_success daemon alert "mac: '$MAC'"
						func_http_redirect 302 landing_page
						exit
					}
				}
				
				func_log weblogin_failed daemon info "ip: '$REMOTE_ADDR'"
				func_weblogin_output_login_error
			else						# fixme! send error to show (user,pass,rules,inetconnection...)
				func_log weblogin_norules daemon info "ip: '$REMOTE_ADDR'"
				func_http_redirect 302 ip_wifi
			fi
		else
			if [ "$QUERY_STRING" != "REDIRECTED=1" ]; then
				func_log weblogin_redirect daemon info "ip: '$REMOTE_ADDR'"
				func_http_redirect 302 ip_wifi
			else
				func_need weblogin
			
				if func_network_inet_seems_stable; then
					func_log weblogin_splash daemon info "ip: '$REMOTE_ADDR'"
					func_weblogin_output_loginpage
				else
					func_log weblogin_inet_unstable daemon info "inet_broken"
					func_weblogin_output_errorpage inet_broken "cost_int: '$COST_INT' default_route: '$( ip route list exact 0/0 table main )'"
				fi
			fi
		fi
		
		exit
	;;
esac

func_need vars_old old log http pfilter welcome

# func_log show_method_get daemon info "is '$QUERY_STRING'"

fkt_decide_usecase				# examine if user is already logged in or not
fkt_decide_mode					# assigns mode by examining remote-IP-address

case $MODE in
	REDIRECT_LAN|REDIRECT_WIFI)
	
		func_need weblogin
		func_weblogin_output_gate_page
		exit
	
		if [ "$MODE" = "REDIRECT_LAN" ]; then		# fixme! ip -o route get 10.63.167.70 | sed -n 's/^.*src \([0-9\.]*\).*/\1/p;q'
			func_http_redirect 302 ip_lan
		else
			func_http_redirect 302 ip_wifi
		fi
	;;
	SERVICE)
		fkt_print_html_header
		fkt_print_html_message_service
		fkt_print_html_footer
	;;
	WIFI|LAN)									# fixme! akzeptiere nutzungsbedingungen fehlt noch
		fkt_print_html_header
		
		MAC="$( fkt_get_mac_from_local_ip $REMOTE_ADDR )"
		IP=$REMOTE_ADDR								# fixme! really needed?
		
		fkt_definitions
		[ -z "$( fkt_list_locally_registered_users | grep -i $MAC )" ] && {
			fkt_print_html_link_to_usermanagement
		}
		
		if [ "$MODE" = "WIFI" ]; then
			fkt_print_html_message_wifi
		else
			fkt_print_html_message_lan
		fi
		
		fkt_print_wiki "$WIKI_ARTICLE_1" "$WIKI_ARTICLE_1_HEADLINE"
		fkt_print_news "$LATEST_NEWS_URL" "$LATEST_NEWS_HEADLINE"
		fkt_print_wiki "$WIKI_ARTICLE_2" "$WIKI_ARTICLE_2_HEADLINE"
										# fixme! nvram get fff_ethers_auth = BLACKLIST || WHITELIST !

		if [ "$( fkt_check_if_user_with_mac_is_locally_blacklisted $MAC )" = "true" ]; then
			
			fkt_print_html_you_are_blacklistet
		else
			if fkt_list_user_macs | grep -q -i $MAC ; then
			
				if [ "$( fkt_get_used_traffic_limit_from_user_with_mac_in_percent $MAC )" -gt 100 ] && [ "$( fkt_check_if_mac_is_admin $MAC )" = "false" ]; then
					fkt_print_html_user_over_limit
				else
					if [ "$( fkt_check_if_user_with_mac_is_redirected $MAC )" = "true" ]; then
						fkt_print_html_button
					else
						fkt_print_html_alread_logged_in
					fi
				fi
			else
				fkt_print_html_button
			fi
		fi
		
		fkt_print_html_footer
	;;
	WAN|REDIRECT_WAN)
		fkt_deliver_indexpage	
	;;
	BUTTON)							# fixme! print network / social-rules!
		fkt_print_html_header				# fixme! an attacker can refresh the POST-values in browser and again surf 15mins 8-)
		fkt_definitions					# same packet-filter vars...
		
		MAC="$( fkt_get_mac_from_local_ip $REMOTE_ADDR )"
		
		fkt_list_user_macs | grep -q -i $MAC								# already shaped?
		
		if [ "$?" -eq 0 ]; then										# user already shaped, but redirected (over night kick off...)
			fkt_control_redirect_for_user_with_mac_and_ip nosplash $MAC $REMOTE_ADDR >/dev/null
		else												# user is really new
			func_activate_reserved_user_chain $MAC $REMOTE_ADDR || {
				fkt_add_user_with_mac_and_ip $MAC $REMOTE_ADDR
			}
		fi
	
		fkt_print_html_message_welcome
		fkt_print_image_of_inet_gw
		fkt_print_html_footer			# fixme: maybe redirect to: "http://www.google.de/search?q=www.weimarnetz.de" ???
	;;
	*) 					# remote user is from mesh or localhost
		fkt_deliver_indexpage
	;;
esac
