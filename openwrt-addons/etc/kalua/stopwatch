#!/bin/sh

_stopwatch_start()
{
	local job="${1:-unset}"
	local keyword="$2"		# e.g. global
	local up rest file

	if [ "$keyword" = 'global' ]; then
		file="/tmp/STOPWATCH_${job}"
	else
		file="/tmp/STOPWATCH_${job}_$$"
	fi

	read up rest </proc/uptime
	# 61332.59 -> 6133259
	echo "${up%.*}${up#*.}" >$file
}

_stopwatch_seconds2humanreadable()
{
	local integer="$1"
	local humanreadable min sec hours days

	min=$(( $integer / 60 ))
	sec=$(( $integer % 60 ))

	if   [ $min -gt 1440 ]; then
		days=$(( $min / 1440 ))
		min=$(( $min % 1440 ))
		hours=$(( $min / 60 ))
		min=$(( $min % 60 ))
		humanreadable="${days}d ${hours}h ${min}min ${sec}sec"
	elif [ $min -gt 60 ]; then
		hours=$(( $min / 60 ))
		min=$(( $min % 60 ))
		humanreadable="${hours}h ${min}min ${sec}sec"
	elif [ $min -gt 0 ]; then
		humanreadable="${min}min ${sec}sec"
	else
		humanreadable="${sec}sec"
	fi

	echo "$humanreadable"
}

_stopwatch_stop()		# OUT1: centyseconds = seconds/100
{
	local funcname='stopwatch_stop'
	local CONTEXT="${1:-unset}"
	local option="$2"				# e.g. quiet|nolog|speed|interim
	local object_count="$3"				# e.g. 32
	local object_type="$4"				# e.g. tickets

	local up rest DIFF humanreadable file logprio
	local START END OUT INTEGER REST message speed
	local logprio='info'

	read up rest </proc/uptime

	  if [ -e "/tmp/STOPWATCH_${CONTEXT}" ]; then
		file="/tmp/STOPWATCH_${CONTEXT}"
	elif [ -e "/tmp/STOPWATCH_${CONTEXT}_$$" ]; then
		file="/tmp/STOPWATCH_${CONTEXT}_$$"
	else
		_log do $funcname daemon info "timefile '/tmp/STOPWATCH_${CONTEXT}'* not found - abort"
		return 1
	fi

	read START <"$file"
	[ "$option" = 'interim' ] || rm "$file"
	END="${up%.*}${up#*.}"

	OUT="$(( $END - $START ))"
	REST="$(( $OUT % 100 ))"
	[ $REST -lt 10 ] && REST="0$REST"
	INTEGER="$(( $OUT / 100 ))"

	[ $INTEGER -gt 60 ] && {
		humanreadable="$( _stopwatch seconds2humanreadable $INTEGER )"
		humanreadable=" (${humanreadable})"
	}

	[ -n "$object_type" -a -n "$object_count" ] && {
		# 32 tickets / 12.12sec -> 3200 / 1212 = 2.64
		speed="$(( ${object_count}00 / $OUT )).$(( ${object_count}00 % $OUT ))"
		message=" ($speed $object_type/sec)"
	}

	[ "$option" = 'speed' ] && echo "$speed" && return 0
	[ "$option" = 'nolog' ] || _log do $funcname daemon $logprio "task '$CONTEXT' lasts $INTEGER.$REST seconds${humanreadable}${message}"
	[ "$option" = 'quiet' ] || echo "$OUT"
}
