_vpn_innercity_master_vtund_write_config()
{
	local config="${1:-/tmp/vtund.conf}"
	local password="${2:-ff}"
	local node=2
	local node_max=1024

	cat >"$config" <<EOF
default {
	type ether ;
	compress no ;
	encrypt no ;
	keepalive yes ;
	multi killold ;
	stat no ;
}
EOF

	while [ $node -lt $node_max ]; do {

		cat >>"$config" <<EOF

Node$node {
	device tap$node ;
	passwd $password ;

	up {   program ". /tmp/loader; _vpn; _vpn innercity_master_iface up   %%" wait; } ;
	down { program ". /tmp/loader; _vpn; _vpn innercity_master_iface down %%" wait; } ;
}
EOF
		node=$(( node + 1 ))
	} done
}

_vpn_innercity_master_vtund()
{
	local funcname='vpn_innercity_master_vtund'
	local action="$1"	# check_on_server|fire|start|stop|restart
	local config="${2:-/tmp/vtund.conf}"
	local line

	case "$action" in
		check_on_server)
			if [ -e "$config" ]; then
				lsof | fgrep '/dev/net/tun' | grep -q ^'olsrd' && {
					line="$( ps ax | grep 'vpn_innercity_master_iface up' | grep -v 'grep' )"
					[ -n "$line" ] && {
						_log do $funcname daemon alert "hanging task: $line"
						set -- line
						kill $1
					}

					_olsr daemon restart 'blocked /dev/net/tun'
				}
			else
				_vpn innercity_master_vtund start
			fi
		;;
		fire)
			/usr/local/sbin/vtund -f "$config" -P 5001 -s
		;;
		start)
			_vpn innercity_master_vtund_write_config
			_vpn innercity_master_vtund fire
		;;
		stop)
			killall vtund
		;;
		restart)
			_vpn innercity_master_vtund stop
			_vpn innercity_master_vtund fire
		;;
	esac
}

_vpn_innercity_master_iface()
{
	local funcname='vpn_innercity_master_iface'
	local action="$1"	# up|down
	local dev="$2"		# e.g. tap276

	while ! mkdir "/tmp/lock-$funcname"; do {
		_log do $funcname daemon alert "locked: $action/$dev must wait for '$( cat "/tmp/lock-$funcname/info" )'"
		sleep 1
	} done
	echo "action: $action dev: $dev" >"/tmp/lock-$funcname/info"
	_log do $funcname daemon alert "[START] action: $action dev: $dev"

	local limit=8		# throttling
	local limit_burst=5
	local mask=30
	local mtu=1450

	if [ "$action" = 'up' ]; then
		local remote_nodenumber="${dev//tap/}"		# tap276 -> 276
		local tunnel_ip_here="$( _ipsystem getvar 'WIFIVPNSERVERADR' $remote_nodenumber )"

		ip address add $tunnel_ip_here/$mask dev $dev
		ip link set dev $dev mtu $mtu up
		$IPT -I INPUT  -p udp --dport 698 -i $dev -j DROP
		$IPT -I INPUT  -p udp --dport 698 -i $dev -m limit --limit $limit/s --limit-burst $limit_burst -j ACCEPT
		$IPT -I INPUT  -p udp --dport 698 -i $dev -s $tunnel_ip_here -j ACCEPT
		$IPT -I OUTPUT -p udp --dport 698 -o $dev -j DROP
		$IPT -I OUTPUT -p udp --dport 698 -o $dev -m limit --limit $limit/s --limit-burst $limit_burst -j ACCEPT
		$IPT -I FORWARD -i $dev -j ACCEPT
		$IPT -I FORWARD -o $dev -j ACCEPT

		mkdir /tmp/FREIFUNK_TUNNEL && {
			$IPT -t nat -I POSTROUTING -s 10.0.0.0/8 ! -d 10.0.0.0/8 -j MASQUERADE
			# TODO: activate forwarding in kernel
		}

		grep -q "\"$dev\"" "$olsrd_config" || {
			sed -i "s/Interface /Interface \"$dev\" /" "$olsrd_config"
		}

		pidof olsrd >/dev/null || _olsr daemon start "$funcname() not active yet"
	else
		ip link set dev $dev down
		$IPT -D FORWARD -o $dev -j ACCEPT
		$IPT -D FORWARD -i $dev -j ACCEPT
		$IPT -D OUTPUT -p udp --dport 698 -o $dev -m limit --limit $limit/s --limit-burst $limit_burst -j ACCEPT
		$IPT -D OUTPUT -p udp --dport 698 -o $dev -j DROP
		$IPT -D INPUT  -p udp --dport 698 -i $dev -m limit --limit $limit/s --limit-burst $limit_burst -j ACCEPT
		$IPT -D INPUT  -p udp --dport 698 -i $dev -j DROP
	fi

	rm -fR "/tmp/lock-$funcname"
	_log do $funcname daemon alert "[READY] action: $action dev: $dev"
}

_vpn_hideandseek_master_get()
{
	# the effective inet_offering node
	echo '/tmp/GATEWAY_CHECK_RECENT_GATEWAY_IP_ONLY'
}

_vpn_hideandseek_user_list()
{
	local table_name='hideandseek'

	ls -1 "/tmp/$table_name-"* | cut -d'-' -f2
}

_vpn_hideandseek_user_probe()
{
	local ip="$1"
	local table_name='hideandseek'

	test -e "/tmp/$table_name-$ip"
}

_vpn_hideandseek_user_add()
{
	local funcname='vpn_hideandseek_user_add'
	local ip="$1"
	local mask="${2:-32}"

	local table_name='hideandseek'
	local table_id=50
	local tunnel_dev='tap0'
	local user_id myhna
	local markerfile="/tmp/$table_name-$ip"

	# already applied?
	[ -e "$markerfile" ] && return 0

	if _net local_inet_offer >/dev/null; then
		grep -q ^"$table_id $table_name" '/etc/iproute2/rt_tables' || {
			echo "$table_id $table_name" >>'/etc/iproute2/rt_tables'
		}

		[ -e "/tmp/$funcname" ] || {
			#         0 = table local
			#       ... = table hideandseek *this*
			#     32766 = table main
			#     32767 = table default
			echo '20000' >/tmp/$funcname
			ip route add default via "$( _ipsystem getvar WIFIVPNSERVERADR )" dev "$tunnel_dev" table "$table_name"
		}

		read user_id <"/tmp/$funcname"
		echo "$user_id" >"$markerfile"
		_watch counter "/tmp/$funcname" increment 2

		ip rule add from "$ip/$mask" prio "$user_id" table "$table_name"
		ip rule add to   "$ip/$mask" prio "$(( user_id + 1 ))" lookup main
		ip route flush cache

		_log do $funcname daemon info "activated for $ip"
	else
		:
		# delegate
	fi
}

_vpn_hideandseek_user_disable()
{
	:
	# TODO: call during bad/lost tunnel and automatically reenable if tunnel up again
}

_vpn_hideandseek_user_del()
{
	local funcname='vpn_hideandseek_user_del'
	local ip="$1"
	local mask="${2:-32}"

	local user_id
	local table_name='hideandseek'
	local markerfile="/tmp/$table_name-$ip"

	if [ -e "$markerfile" ]; then
		read user_id <"$markerfile"
	else
		return 0
	fi

	ip rule del from "$ip/$mask" prio "$user_id" table "$table_name"
	ip rule del to   "$ip/$mask" prio "$(( user_id + 1 ))" lookup main
	ip route flush cache
	rm "$markerfile"

	_log do $funcname daemon info "deleted $ip"
}

_vpn_hideandseek_master_vtund_write_config()
{
	local file="${1:-/tmp/vtund.conf}"
	local name="Node$NODENUMBER"

	[ -e "$file" ] || cat >"$file" <<EOF
$name {
	passwd ff ;
	type ether ;
	persist yes ;

	up {   program "ifup   innercityvpn" wait; };
	down { program "ifdown innercityvpn" wait; };
}
EOF
}

_vpn_hideandseek_vtund()
{
	local action="$1"	# check_on_client|fire|start|stop|restart
	local config="${2:-/tmp/vtund.conf}"
	local server='4.v.weimarnetz.de'
	local server_port='5001'
	local name="Node$NODENUMBER"

	case "$action" in
		check_on_client)
			if _vpn hideandseek_master_vtund_write_config; then
				# config written
				_vpn hideandseek_vtund fire
			else
				# config already there
				:
			fi
		;;
		fire)
			vtund -f "$config" "$name" "$server" -P "$server_port"
		;;
		start)
			_vpn hideandseek_master_vtund_write_config
			_vpn hideandseek_vtund fire
		;;
		stop)
			killall vtund
		;;
		restart)
			_vpn hideandseek_vtund stop
			_vpn hideandseek_vtund fire
		;;
	esac
}

_vpn_x()
{
if [ -e '/tmp/vtund.sh' ]; then
	# todo: use a function and more varnames
	# maybe better?: grep "tap[0-9]:" /proc/net/dev
	if pidof vtund >/dev/null; then
		logread >'/tmp/logread.out'

		dev_has_probs()
		{
			if ip address show dev "$1" | grep -q 'inet6 '; then
				return 1
			else
				return 0
			fi
		}

		restart_vtund()
		{
			_log do check_vtund daemon alert "restarting: $1"
			killall vtund
			. '/tmp/vtund.sh'
		}

		if   dev_has_probs 'tap0'; then
			restart_vtund "dev is not fully up"
		elif grep -q 'Connection timed out' '/tmp/logread.out'; then
			[ $( grep "vtund\[[0-9]*\]:" '/tmp/logread.out' | grep 'Connection timed out' '/tmp/logread.out' | wc -l ) -gt 5 ] && {
				grep -q ' vtund: link_up ' '/tmp/logread.out' || {
					restart_vtund "our pubip has changed?"
				}
			}
		elif grep -q "Can't resolv server address" '/tmp/logread.out'; then
			[ $( grep "vtund\[[0-9]*\]:" '/tmp/logread.out' | grep "Can't resolv server address" '/tmp/logread.out' | wc -l ) -gt 5 ] && {
				restart_vtund "servers pubip has changed?"
			}
		fi

		rm '/tmp/logread.out'
	else
		_log do check_vtund daemon alert "starting up after crash"
		. '/tmp/vtund.sh'
	fi
else
	[ -e "/etc/vtund.conf" ] && {			# startup-code must be a comment at first line
		grep -q ^'# vtund ' "/etc/vtund.conf" && {
			head -n1 "/etc/vtund.conf" | cut -b 2- >"/tmp/vtund.sh"

			_log do check_vtund daemon info "starting up"
			. '/tmp/vtund.sh'
		}
	}
fi

}
