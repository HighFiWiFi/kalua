# ToDo:
# option einbauen, um einen task zu einer bestimmten Uhrzeit in der Zukunft ausfuehren zu lassen,
# z.b. +werbefilter-liste_update in 24h

_scheduler_queue_purge()
{
	_log do purge_queues daemon info "removing"
	rm $SCHEDULER_QUEUE

	return 0
}

_scheduler_queue_list()
{
	local funcname="scheduler_list_queue"
	local option="$1"
	local empty1 empty2

	_log do $funcname daemon debug "working with option: '$option'"

	echo "# actual,running queue: /tmp/scheduler.log"
	cat '/tmp/scheduler.log' 2>/dev/null || {
		echo -en "# empty!\n\n"
		empty1="true"
	}

	echo -en "\n# waiting queue: (important + normal)\n"
	cat $SCHEDULER_QUEUE 2>/dev/null || {
		echo -en "# empty!\n\n"
		empty2="true"
	}

	[ "$option" = "is_empty" ] && {
		if [ "${empty1}${empty2}" = "truetrue" ]; then
			return 0
		else
			return 1
		fi
	}
}

_scheduler_print_usage ()
{
	local FUNC="scheduler_print_usage"
	
	_log do $FUNC daemon info "working"

	cat <<EOF
 
Sens:	 Adds program calls to a queue and executes all
	 these calls step by step. This prevents high
	 cpu-load and/or memory-consumption, but is not
	 executed at an exact timestamp.
 
Usage:	 $0 -option1 -option2 -optionN
 
Options: -a "TASK"   adds an TASK to queue, where TASK can be keyword
	 -A "TASK"   immediately runs TASK, does not respect cpu-load
	 -r          runs the queue, step by step
	 -l          lists running and waitung queue
	 -p	     purge all queues
	 -f	     overload check (last 5min)
	 -P	     gateway ping-test
	 -O	     fetch OLSR-table
	 -o	     special: checks for incoming olsr-packets and
		     restarts daemon with new conf if neccessary
	 -u	     check syslog for kernel-oops, reboot if needed
	 -w	     check mac80211_wifi for problems
	 -H	     build overload check /tmp/WELCOME_HELPER for uhttpd
	 -S "name"   load a set of scheduled services according to actual time

Example: $0 -s3 -a do_this -a do_that -r -a do_another_thing -r
 
	 This invokes a sleep for 3 seconds,
	 adds "do_this" to queue, then adds "do_that" to queue, then
	 runs the queue, then adds an user-defined program call to
	 queue, then runs the queue. Keywords must be defined in
	 _scheduler(). Ofcourse you should only use the queue, if
	 exact executing-time of your program does'nt really matter.
 
	 $0 -A "program1 arg1" -a "program2 arg1 arg2" -l
 
	 This immediately start "program1" with "arg1", than adds an
	 user-defined programm call with args and then lists all queues.
 
EOF
}

_scheduler_task2command ()
{
	local FUNC="scheduler_task2command"
	local TASK="$1"
	local COMMAND
	
	case "$TASK" in
			   rrdhelper)	COMMAND=". /tmp/loader; _wifi rrdhelper \$WIFIDEV" ;;
			  monitoring)	COMMAND="/usr/sbin/cron.monitoring" ;;
		    upgrade_packages)	COMMAND="/usr/sbin/cron.upgrade_packages" ;;
	       watch_hanging_command)	COMMAND=". /tmp/loader; for option in mv scp wget nc; do _watch hanging_command \$option; done" ;;
	            build_accounting)   COMMAND="wget -qO /tmp/accounting.tmp 'http://127.0.0.1/cgi-bin-tool_fff+?OPT=accounting&GUI=1'; mv /tmp/accounting.tmp /tmp/accounting.html" ;;
		        restart_olsr) 	COMMAND=". /tmp/loader; _olsr daemon restart olsrd_restart_scheduler_controlled" ;;
		        15min_checks)  	COMMAND="/etc/init.d/S69watch_olsrd_fff+" ;;
		     	 restart_vpn)	COMMAND="/etc/init.d/S52vpn_fff+ restart" ;;
		           1h_checks)	COMMAND="/usr/sbin/cron.hourly"; >/tmp/SEND_ALIVE_FAILED ;;
		       gateway_check)	COMMAND="/usr/sbin/cron.check_inet_gw_fff+" ;;	
	   			 vds)	COMMAND="/usr/sbin/cron.evaluate_ulogd_syslogemu_fff+" ;;
				   *)
					COMMAND="$TASK"
					TASK=

				        _log do $FUNC daemon debug "user defined: '$COMMAND'"
				;;
	esac
	
	echo "$COMMAND"
}

_scheduler_add()
{
	# remove this function, scheduler_run should take care of double entries

	local TASK="$1"
	local KEYWORD="$2"		# move2top|force
	local COMMAND counter
	local FUNC="scheduler_add"
	local logprio="debug"

	COMMAND="$( _scheduler task2command "$TASK" )" || return 0

	case "$KEYWORD" in
		move2top)
			if grep -q ^"$COMMAND" "$SCHEDULER_IMPORTANT_QUEUE"; then
				_log do $FUNC daemon $logprio "$KEYWORD - PID: '$$' - '$TASK' - already in queue, ignoring"
			else
				echo >>"$SCHEDULER_IMPORTANT" "$COMMAND	# $TASK"
			fi
		;;
		force)
			if [ "$( fgrep -s "$COMMAND" "$SCHEDULER_QUEUE" | wc -l )" -ge 2 ]; then
				_log do $FUNC daemon info "not adding '$COMMAND', already more then 2 times in queue"
			else
				echo >>"$SCHEDULER" "$COMMAND	# $TASK"
			fi
		;;
		*)
			# fixme! better begin search at line_start
			# but if we use regex, we have to escape special chars like * and .

			if fgrep -q "$COMMAND" "$SCHEDULER_QUEUE"; then
				_log do $FUNC daemon $logprio "PID:'$$' - '$TASK' - already in queue, ignoring"
			else
				echo >>"$SCHEDULER" "$COMMAND	# $TASK"
			fi
		;;
	esac
}

_scheduler_check_if_every_Nth_minute ()
{
	# some tasks should be repeated regulary, but NOT on the same
	# time on every node in the mesh. so we need a way the schedule
	# a script every X minutes based on uptime and not on daytime,so:
	# check every min, if uptime is divisor of X (without a rest)

	local UPTIME="$( _system uptime min )"	# e.g. uptime = 60 and
	local CARRYOVER="$(( $UPTIME % $1 ))"	# e.g. every = 55 min : 60 % 55 = 5 
	
	[ "$CARRYOVER" -eq 0 ] && {
		_log do scheduler_check_if_every_Nth_minute daemon debug "call '$2' for ${1}th minute, uptime: $UPTIME"
		return 0
	}

	return 1
}

_scheduler_wait_till_cpuload_is_low()
{
	local funcname='scheduler_wait_till_cpuload_is_low'
	local task="$1"

	while _system load 1min quiet; test $LOAD -gt 80 ; do {
		_log do $funcname daemon debug "PID: $$ - load: $LOAD - waiting 30 sec for '$task'"
		sleep 30
	} done
}

_scheduler_allow_run()
{
	local funcname="scheduler_allow_run"
	local lockfile="$1"

	[ -e "$lockfile" ] && {
		if [ $( _file age "$lockfile" sec ) -gt 3600 ]; then
			_log do $funcname daemon alert "removing lockfile, which seems to be left by accident"
			rm "$lockfile"
		else
			return 1
		fi
	}

	if [ -e "/tmp/START_SYSUPGRADE" ]; then
		return 1
	else
		return 0
	fi
}

_scheduler_run()
{
	local funcname='scheduler_run'
	local file line
	local logfile='/tmp/scheduler.log'

	_scheduler allow_run "$logfile"

	for file in $SCHEDULER_QUEUE; do {
		while read line; do {
			if fgrep -sq "$line" "$logfile"; then
				_log do $funcname daemon debug "ignoring twin '$line'"
			else
				echo "$line" >>"$logfile"
				_scheduler wait_till_cpuload_is_low "$line"

				# working lines:
				# file arg1 ... argN
				# . file
				# _function arg1 ... argN
				# does not work by simply executing: $line - needs: eval $line
				# ( _list show >/tmp/bla )
				# _list show >/tmp/bla
				# _list show | logger
				# _list show; _list show

				_log do $funcname daemon debug "[START] '$line'"
				case "$line" in
					*'|'*|*'<'*|*'>'*|*';'*)
						eval $line
					;;
					*)
						$line
					;;
				esac

#				set -- $line
#				case "$( type "$1" )" in
#					# this is not enough:
#					# test e.g. '. /tmp/loader; _list show >/tmp/bla'
#					# we can also include a file, e.g. if the filename end with X?
#					"$1 is a shell function")
#						eval $@
#					;;
#					*)
#						/bin/sh -c "$line"	# exec? or simply?: $line
#					;;
#				esac
				_log do $funcname daemon debug "[READY] '$line'"
			fi
		} done <"$file" && rm "$file"
	} done

	rm "$logfile"
}
