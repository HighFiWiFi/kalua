#!/bin/sh
#if /sbin/uci get system.@system[0].hostname >/dev/console; then	# test something essential
if true; then								# will be activated during cron-startup
	read UP REST </proc/uptime
	read LOAD REST </proc/loadavg
else
	UP=999999
fi

[ ${UP%.*} -gt 129600 ] && {	# 36h
	rm "/tmp/CRON_IS_CAREFUL"
	  echo "REBOOT: overup - up: $UP"  >/dev/console
	( echo "REBOOT: overup - up: $UP" >>/www/everlasting_syslog.txt; sync ) &
	/bin/sleep 5

	echo "c" >/proc/sysrq-trigger
	/sbin/reboot
}

if [ -e "/tmp/CRON_PSWORK" ]; then
	  echo "REBOOT: pswork - up: $UP"  >/dev/console
	( echo "REBOOT: pswork - up: $UP" >>/www/everlasting_syslog.txt; sync ) &
	/bin/sleep 5

	echo "c" >/proc/sysrq-trigger
	/sbin/reboot -f
else
	case "$LOAD" in
		0.*)
			ps >"/tmp/CRON_PSWORK"		# test something essential
		;;
#		*)
#			case "$REST" in
#				*'1/3'*|*'2/3'*)	# from loadavg: normal is ~33...39 tasks with 1 or 2 running tasks
#				;;
#				*)
#					touch '/tmp/CRON_PSWORK'
#					ps >/dev/console
#				;;
#			esac
#		;;
	esac
fi

# uncomment to collect 1) date 2) lockstatus 3) network-traffic and 4) freemem/uptime/load 5) taskcount and 6) dump into '/tmp/CRONSTATUS'
#1# REST="$( date ) "
#2# [ -e /tmp/CRON_LOCK ] && REST="$REST [LOCKED] "
#3# while read L;do case $L in *wlan*)set $L;REST="$REST $1 rx:$2/$3 tx:${10}/${11} ";;esac;done</proc/net/dev
#4# while read L;do case $L in MemFree:*)set $L;M=$2;;Buffers:*)set $L;REST="$REST mem:$((($M+$2)*1024)) up:$UP load:$LOAD";break;esac;done</proc/meminfo
#5# REST="$REST tasks: $( wc -l </tmp/CRON_PSWORK )"
#6# echo "$REST" >>/tmp/CRONSTATUS
#7# see /etc/kalua/scheduler: scheduler_add() and uncomment the last line in function
#8# see /usr/bin/scheduler: uncomment line on top
echo "up: $UP load: $LOAD rest: $REST" >/dev/console

rm "/tmp/CRON_PSWORK"

### PING_MONITORING_SERVER ###

case "$LOAD" in
	0.*)
### CALL_APPLYPROFILE ###
### CALL_ZRAMCHECK ###
### CALL_ZRAMREBOOT ###
### CALL_UBUSCHECKER ###
### CALL_WIFICHECK ###
### CALL_IRQ ###
### CALL_RRD ###
### CALL_WEBCAM ###
### WAIT_FOR_APPLY_PROFILE ###
### NOCRON_DURING_CLIENT_ACTION ###
### CALL_AUDIOPLAYER ###
	;;
esac

case "$LOAD" in
	1.00)
		. /usr/sbin/cron.check_klog

		if [ -e "/tmp/CRON_OVERLOAD" ]; then
			read I <"/tmp/CRON_OVERLOAD"
		else
			I=
		fi

		case "$I" in
			""|"#"*)
				. /tmp/loader
				_watch topusage_task "cron.minutely: load = $LOAD"
				rm "/tmp/CRON_OVERLOAD"
			;;
		esac
	;;
	1.0*|0.9*|0.8*)
		. /usr/sbin/cron.check_klog

		[ -e "/tmp/CRON_OVERLOAD" ] && {
			read I <"/tmp/CRON_OVERLOAD"
			case "$I" in
				"#"*)
					rm "/tmp/CRON_OVERLOAD"
					echo "ALERT: $( date ) loady_after_overload - load: $LOAD - I: $I - up: $UP" >>/dev/console
				;;
			esac
		}
	;;
	0*)
		. /usr/sbin/cron.check_klog
		[ -e "/tmp/CRON_OVERLOAD" ] && {
			read I <"/tmp/CRON_OVERLOAD"
			case "$I" in
				"#"*)
					rm "/tmp/CRON_OVERLOAD"
				;;
			esac
		}

		if [ -e "/tmp/CRON_LOCK" ]; then
			case "$LOAD" in
				0.00|0.01|0.02)
					echo -n '#' >>"/tmp/CRON_UNDERLOAD"
					read I <"/tmp/CRON_UNDERLOAD"
					[ ${#I} -gt 30 ] && {
						rm "/tmp/CRON_IS_CAREFUL"

						  echo "ALERT: $( date ) underload - load: $LOAD - I: $I - up: $UP"  >/dev/console
						( echo "ALERT: $( date ) underload - load: $LOAD - I: $I - up: $UP" >>/www/everlasting_syslog.txt; ps >>/www/everlasting_syslog.txt; sync ) &
						/bin/sleep 5

						echo "c" >/proc/sysrq-trigger
						/sbin/reboot -f
					}

					. /tmp/loader
					for PRG in mv scp nc wget; do {
						pidof $PRG && _watch hanging_command $PRG
					} done
				;;
				0.*)
					. /tmp/loader

					[ $(( $( _system date unixtime ) - $( _file unixtime "/tmp/CRON_LOCK" ) )) -gt 3600 -a ${UP%.*} -gt 3600 ] && {
						echo "ALERT: $( date ) very old lockfile: '$( ls -le '/tmp/CRON_LOCK' )'"  >/dev/console
						echo "ALERT: $( date ) very old lockfile: '$( ls -le '/tmp/CRON_LOCK' )'" >>/www/everlasting_syslog.txt
						sync
						/sbin/reboot -f
					}
				;;
			esac
		else
			[ -e "/tmp/CRON_UNDERLOAD" ] && rm "/tmp/CRON_UNDERLOAD"

			case "$( pidof dropbear )" in						# REM
				*" "*)								# REM
				;;								# REM
				*)								# REM
#					trap "rm /tmp/CRON_LOCK; exit" INT TERM EXIT
					>/tmp/CRON_LOCK

					/usr/bin/scheduler -U -S newstyle -O -P -f -H -w
					. /tmp/loader
					_scheduler run

					rm /tmp/CRON_LOCK
#					trap - INT TERM EXIT
				;;								# REM
			esac									# REM
		fi
	;;
	*)
		if [ -e "/tmp/CRON_OVERLOAD" ]; then
			read I <"/tmp/CRON_OVERLOAD"
		else
			echo -n '#' >>"/tmp/CRON_OVERLOAD"
			I="#"
		fi

		# dont complain the first 30 mins
		[ ${UP%.*} -lt 1800 ] && I=

		case "$I" in
			"#"*)
				echo -n '#' >>"/tmp/CRON_OVERLOAD"

				case ${#I} in
					0|1|2|3|4)
					;;
					5)
						# maybe a script attack
						killall dropbear && echo "ALERT: overload_$I - $LOAD - up: $UP - killed dropbear" >/dev/console
					;;
					6|7|8|9|10|1*|2*)
						. /tmp/loader
						_watch space_tmpfs
						_watch topusage_task "cron.minutely: load = $LOAD I=$I"
						[ -n "$LOWMEM" ] && echo "#" >"/tmp/CRON_OVERLOAD"

						echo "ALERT: overload_$I - $LOAD - up: $UP" >>/www/everlasting_syslog.txt
						[ ${#I} -eq 7 ] && top -b -n1 >>/www/everlasting_syslog.txt
					;;
					*)
						rm "/tmp/CRON_IS_CAREFUL"

						  echo "REBOOT: overload - $LOAD - up: $UP"  >/dev/console
						( echo "REBOOT: overload - $LOAD - up: $UP" >>/www/everlasting_syslog.txt; sync ) &
						/bin/sleep 5

						echo "c" >/proc/sysrq-trigger
						/sbin/reboot -f
					;;
				esac
			;;
		esac
	;;
esac

[ -e /tmp/service_olsrd_nowatching ] || {
	[ ${UP%.*} -gt 600 ] && {
		pidof olsrd >/dev/null || {
			sleep 90
			pidof olsrd >/dev/null || {
				reboot
			}
		}
	}
}

# read UP2 REST </proc/uptime; REST=$(( ${UP2%.*} - ${UP%.*} )); test $REST -gt 58 && echo "ALERT: $( date ) longexec: $REST sec, up: $UP load: $LOAD" >>/www/everlasting_syslog.txt
