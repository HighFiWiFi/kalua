FUNC_PACKAGES=1

# func_ipkg_make_free_space
# func_ipkg_is_essential
# func_ipkg_list_installed_backwards
# func_ipkg_repos_list_files
# func_ipkg_update
# func_ipkg_install
# func_ipkg_remove
# func_ipkg_is_installed
# func_ipkg_is_not_installed
# func_packages_install
# func_packages_upgrade
# func_packages_version
# func_packages_get_newer_version


func_ipkg_make_free_space ()
{
	local FUNC="ipkg_make_free_space"
	local SPACE_WISH="$1"
	local FREE=0
	local IPK

	for IPK in $( func_ipkg_list_installed_backwards ); do {
	
		FREE="$( func_system_flash_free )"
		func_log $FUNC daemon debug "now $FREE kb"
	
		[ $FREE -gt $SPACE_WISH ] && {
			func_log $FUNC daemon debug "ready"
			break
		}
	
		func_ipkg_is_essential $IPK || {			# prevents chicken egg-problem
			func_log $FUNC daemon alert "removing '$IPK'"
			func_ipkg_remove $IPK
		}
	} done
}

func_ipkg_is_essential ()	# fixme! how to determine, if package is part of a meta-package? maybe this
{				#	 doesn't matter, removing meta-packages doesn't effect child-packages
	local PACKAGE="$1"
	
	case $PACKAGE in
		freifunk-pppoecd-*) return 0 ;;		# PPPoE
		      kmod-madwifi) return 0 ;;		# atheros
		             iwlib) return 0 ;;		# atheros
		    wireless-tools) return 0 ;;		# atheros
		     madwifi-tools) return 0 ;;		# atheros
				ip) return 0 ;;		# base
				wl) return 0 ;;		# base
			  wificonf) return 0 ;;		# base
			    kernel) return 0 ;;		# base
			base-files) return 0 ;;		# base
		 freifunk-webadmin) return 0 ;;		# base
		   freifunk-upload) return 0 ;;		# base
		  freifunk-mtdkill) return 0 ;;		# base
		    freifunk-rdate) return 0 ;;		# base
		    freifunk-olsrd) return 0 ;;		# base
			  dropbear) return 0 ;;		# base
		       busybox-awk) return 0 ;;		# base
		                 *) return 1 ;;
	esac
}

func_ipkg_list_installed_backwards ()	# OUT1: string
{
	ipkg status |
	 sed -n 's/^Package: \(.*\)/\1/p' |
	  sed '1!G;h;$!d'
}

func_ipkg_repos_list_files ()	# OUT1: string
{
	cat /usr/lib/ipkg/lists/* 2>/dev/null || {
		echo
		return 1
	}
}

func_ipkg_update ()
{
	local FILE_LAST_FETCH="/tmp/ipkg_last_repository_update"
	local UNIXTIME_UPDATE=0
	local UNIXTIME_NOW="$( date +%s )"
	
	  if [ "$( func_ipkg_repos_list_files | wc -l )" -lt 100 ]; then
	  
	  	UNIXTIME_UPDATE=0

	elif [ -e $FILE_LAST_FETCH ]; then
	  
		UNIXTIME_UPDATE="$( cat $FILE_LAST_FETCH )"
	else
		UNIXTIME_UPDATE=0
	fi
	
	[ $(( ${UNIXTIME_NOW:-0} - ${UNIXTIME_UPDATE:-0} )) -gt 1800 ] && {
		ipkg update
		echo $UNIXTIME_NOW >$FILE_LAST_FETCH
	}
}

func_ipkg_install ()
{
	func_ipkg_update
	ipkg -force-defaults install "$1"
}

func_ipkg_remove ()
{
	local FUNC="ipkg_remove"
	local PACKAGE="$1"
	
	func_log $FUNC daemon debug "'$PACKAGE'"
	ipkg remove $PACKAGE
	
	[ ! -e /sbin/reboot ] && ln -s /rom/sbin/reboot /sbin/reboot	# loginutils
	[ -z "$( date 2>/dev/null )" ] && ln -s busybox /bin/date	# busybox-coreutils
}

func_ipkg_is_installed ()
{
	ipkg status "$1" | grep -q "Status: install ok installed" && return 0
	
	return 1
}

func_ipkg_is_not_installed ()
{
	ipkg status "$1" | grep -q "Status: install ok installed" || return 0

	return 1
}

func_packages_install ()	# hide package-manager from scripts
{
	local PACKAGE_NAME="$1"
	
	func_ipkg_install	$PACKAGE_NAME
	func_ipkg_is_installed	$PACKAGE_NAME || return 1

	return 0
}

func_packages_upgrade ()
{
	local PACKAGE_NAME="$1"
	local PACKAGE_VERSION_HERE=0
	local PACKAGE_VERSION_REPO=0
	
	echo
}

func_packages_version ()
{
	local PACKAGE_NAME="$1"
	local VERSION="$( ipkg status "$PACKAGE_NAME" | sed -n 's/^Version: \(.*\)/\1/p' )"

	[ -n "$VERSION" ] && {
		echo $VERSION
		return
	}

	return 1
}

func_packages_get_newer_version ()		# compare the values and return the newer one
{
	local VERSION_A="$1"
	local VERSION_B="$2"

	  if [ "$( func_packages_get_newer_version_normalize $VERSION_A )" -gt "$( func_packages_get_newer_version_normalize $VERSION_B )" ]; then
	
		echo -n "$VERSION_A"
	
	elif [ "$( func_packages_get_newer_version_normalize $VERSION_B )" -gt "$( func_packages_get_newer_version_normalize $VERSION_A )" ]; then

		echo -n "$VERSION_B"
	fi
}

func_packages_get_newer_version_normalize ()
{
	local VERSION="$1"
	local X Y Z N

	# bash can't calculate with floats, so we normalize to 100.000.000, e.g.:
	#
	# v  X.  Y.  Z
	# v  1.222.333 -> 001222333 (2 dots)
	# v111.222.333 -> 111222333 (2 dots)
	# v  4.222     -> 004222000 (1 dot)
	# v  5         ->   5000000 (0 dots)

	local DOTS="$( echo -n $VERSION | sed 's/[^\.]//g' )"
	
	case "${#DOTS}" in
		0)
			X="$VERSION"
		;;
		1)
			X=${VERSION%[.]*}
			Y=${VERSION#*.}
		;;
		2)
			N=${VERSION%[.]*}
			X=${N%[.]*}
			
			N=${VERSION#*.}
			Y=${N%[.]*}
			Z=${N#*.}
		;;
	esac

	for N in "$X" "$Y" "$Z"; do {
	
		case ${#N} in
			0)
				echo -n "000"
			;;
			1)
				echo -n "00$N"
			;;
			2)
				echo -n "0$N"
			;;
			*)
				echo -n "${N:=000}"
			;;
		esac
	} done
}

