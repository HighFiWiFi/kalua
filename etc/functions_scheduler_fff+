FUNC_SCHEDULER=1

# ToDo:
# option einbauen, um einen task zu einer bestimmten Uhrzeit in der Zukunft ausfuehren zu lassen,
# z.b. +werbefilter-liste_update in 24h

func_scheduler_vars ()
{
	FILE_SCHEDULER_TMP="/tmp/scheduler_queue_tmp_"		# scheduler_add() appends an counter to filename
	FILE_SCHEDULER="/tmp/scheduler_queue"			# HINT: it is also possible to (scp-)upload a file
	FILE_SCHEDULER_COPY="/tmp/scheduler_queue_copy"		#       called ${FILE_SCHEDULER_TMP}xyz for automatic
}								#       execution on many devices...

func_scheduler_list_queue ()
{
	local FUNC="scheduler_list_queue"

	func_log $FUNC daemon info "working"
	
	echo "# actual,running queue:"
	cat $FILE_SCHEDULER_COPY 2>/dev/null || echo -en "# empty!\n\n"
	
	echo -en "\n# waiting queue:\n"
	cat ${FILE_SCHEDULER_TMP}* 2>/dev/null || echo -en "# empty!\n\n"
}

func_scheduler_print_usage ()
{
	local FUNC="scheduler_print_usage"
	
	func_log $FUNC daemon info "working"

	cat <<EOF

Sens:    Adds program calls to a queue and executes all
 	 these calls step by step. This prevents high
	 cpu-load and/or memory-consumption, but is not
	 executed at an exact timestamp.
	 
Usage:   $0 -option1 -option2 -optionN

Options: -a "TASK"   adds an TASK to queue, where TASK can be keyword
         -A "TASK"   immediately runs TASK, but respect cpu-load
	 -r          runs the queue, step by step
	 -s "SEC"    sleeps for SEC seconds
	 -w          sends an heartbeat to the cron-watchdog 
	 -l          lists running and waitung queue
	 -p	     purge all queues
	 -o	     special: checks for incoming olsr-packets and
		     restarts daemon with new conf if neccessary

Example: $0 -s3 -w -a do_this -a do_that -r -a do_another_thing -r

	 This invokes a sleep for 3 seconds, runs the watchdog-heartbeat,
	 adds "do_this" to queue, then adds "do_that" to queue,
	 then runs the queue, then adds an user-defined
	 program call to queue, then runs the queue. Keywords
	 must be defined in scheduler_functions(). Ofcourse you
	 should only use the queue, if exact executing-time of
	 your program does'nt really matter.

	 $0 -A "program1 arg1" -a "program2 arg1 arg2" -l
	 
	 This immediately start "program1" with "arg1", than adds an
	 user-defined programm call with args and then lists all queues.

EOF
}

func_scheduler_task2command ()
{
	local FUNC="scheduler_task2command"
	local TASK="$1"
	local COMMAND
	
	case "$TASK" in
		    upgrade_packages)	func_scheduler_check_if_every_Nth_minute 360 upgrade_packages || return 1
		    			COMMAND="/usr/sbin/cron.upgrade_packages" ;;
	       watch_hanging_command)	COMMAND="/etc/init.d/S69watch_olsrd_fff+ watch_hanging_command" ;;
		    software_install)	COMMAND="/etc/init.d/S71auto_software_update_fff+ call" ;;
			  build_vars)	COMMAND="/usr/sbin/cron.build_vars build" ;;
	            build_accounting)   COMMAND="wget -qO /tmp/accounting.tmp 'http://127.0.0.1/cgi-bin-tool_fff+?OPT=accounting&GUI=1'; mv /tmp/accounting.tmp /tmp/accounting.html" ;;
		  recheck_wired_olsr)	COMMAND="/etc/init.d/S99an_olsr_dev_check_fff+ recheck" ;;
	  whitelist_update_every_15h)   func_scheduler_check_if_every_Nth_minute 891 whitelist_update || return 1
	  				COMMAND="/etc/local.fw-fff+ olsr_whitelist_update" ;;
	  whitelist_rebuild_every_3h)   func_scheduler_check_if_every_Nth_minute 173 whitelist_rebuild || return 1
	  				COMMAND="/etc/local.fw-fff+ olsr_whitelist_optimize" ;;
	       speedtest_every_40min)   func_scheduler_check_if_every_Nth_minute 40 speedtest || return 1
	       				COMMAND="/www/cgi-bin-speed r" ;;
		        restart_olsr) 	COMMAND="/etc/init.d/S53olsrd restart" ;;
		         1min_checks) 	COMMAND="/usr/sbin/cron.minutely" ;;
		        15min_checks)  	COMMAND="/etc/init.d/S69watch_olsrd_fff+" ;;
		     	 restart_vpn)	COMMAND="/etc/init.d/S52vpn_fff+ restart" ;;
		           1h_checks)	COMMAND="/usr/sbin/cron.hourly" ;;
		          24h_checks)	COMMAND="/usr/sbin/cron.daily" ;;
	       	      fwupdate_check) 	COMMAND="/etc/init.d/S01firmware_update_fff+ check" ;;
		       gateway_check)	COMMAND="/usr/sbin/cron.check_inet_gw_fff+" ;;	
		user_traff_broadcast)	COMMAND="/etc/local.fw-fff+ showuser_traff quiet spread randomwait" ;;
		    user_traff_reset)	COMMAND="/etc/local.fw-fff+ reset_all_daily_user_counters" ;;
		kick_user_over_limit)	COMMAND="/etc/local.fw-fff+ kickoverlimituser" ;;
		       kick_user_all)   COMMAND="/etc/local.fw-fff+ kickalluser" ;;
	   			 vds)	COMMAND="/usr/sbin/cron.evaluate_ulogd_syslogemu_fff+" ;;
	      build_service_announce)   COMMAND="/etc/init.d/S52build_services_fff+ start" ;;
	    rebuild_service_announce)   COMMAND="/etc/init.d/S52build_services_fff+ update" ;;
	    start_local_packetfilter)   COMMAND="/etc/local.fw-fff+ call" ;;
	      software_install_start)   COMMAND="/etc/init.d/S71auto_software_update_fff+ call" ;;
		      startup_helper)	COMMAND="/etc/init.d/S72filter_fff+ call" ;;
				   *)   COMMAND="$TASK"
				        func_log $FUNC daemon debug "user defined: '$COMMAND'" ;;
	esac
	
	echo "$COMMAND"
}

func_scheduler_add ()
{
	local TASK="$1"
	local KEYWORD="$2"
	local COMMAND="$( func_scheduler_task2command "$TASK" )" || return
	local COUNTER
	local FUNC="scheduler_add"

	if [ "$KEYWORD" = "move2top" ]; then		# insert on top, if not already in waiting_queue

		cat ${FILE_SCHEDULER_TMP}1000* 2>/dev/null | head -n1 | grep -q ^"$COMMAND" && {
		
			func_log $FUNC daemon debug "$KEYWORD - PID: '$$' - '$TASK' - already in queue, ignoring '$1'"
			return
		}
		
		COUNTER="$(( 1000000000 + $$ ))"
	else
		grep -q ^"$COMMAND" ${FILE_SCHEDULER_TMP}* $FILE_SCHEDULER_COPY 2>/dev/null && {
	
			func_log $FUNC daemon debug "PID:'$$' - '$TASK' - already in queue, ignoring '$1'"
			return
		}
		
		COUNTER="$( date +%s )"		# we need a monotonic + always_same_length-counter here, so better not use $$ (process-id)
	fi					# this is only true from 2001-Sep-10 ... 2038-Jan-19
	
	func_log $FUNC daemon debug "PID:'$$' +'$TASK'"
	echo "$COMMAND   # $TASK" >>${FILE_SCHEDULER_TMP}${COUNTER}
}

func_scheduler_check_if_every_Nth_minute ()
{
	# some tasks should be repeated regulary, but NOT on the same
	# time on every node in the mesh. so we need a way the schedule
	# a script every X minutes based on uptime and not on daytime,so:
	# check every min, if uptime is divisor of X (without a rest)

	local UPTIME="$( func_uptime min )"	# e.g. uptime = 60 and
	local CARRYOVER="$(( $UPTIME % $1 ))"	# e.g. every = 55 min : 60 % 55 = 5 
	
	[ "$CARRYOVER" -eq 0 ] && {
		func_log scheduler_check_if_every_Nth_minute daemon info "call '$2' for ${1}th minute, uptime: $UPTIME"
		return 0
	}

	return 1
}

func_scheduler_wait_till_cpuload_is_low ()
{
	local WAITING_TASK="$1"
	local FUNC="scheduler_wait_till_cpuload_is_low"
	local CPU_LOAD="$( func_system_get_load 1min )"
	local TARGET=60
	local WAIT
	
	while [ $CPU_LOAD -gt $TARGET ]; do {
		WAIT=$(( 5 + ($CPU_LOAD - $TARGET) / 2 ))
		func_log $FUNC daemon debug "PID:'$$' - load >=0.$TARGET ($CPU_LOAD) - waiting $WAIT sec (for '$WAITING_TASK')"
		TARGET=$(( $TARGET + 1 ))
		sleep $WAIT
		CPU_LOAD="$(func_system_get_load 1min)"
	} done
}

func_scheduler_run ()
{
	local FUNC="scheduler_run"
	local FILE
	local LINE
	local LOCKFILE="/tmp/lockfile_scheduler_is_running"

	[ -e $LOCKFILE ] && {
		func_log $FUNC daemon debug "already running - ignoring call"
		return 1
	}
	touch $LOCKFILE
							# this builds the running queue from temp_queue
	for FILE in ${FILE_SCHEDULER_TMP}*; do {
		while read LINE; do {
			func_log $FUNC daemon debug "fetching '$LINE' from file '$FILE'"
			echo "$LINE" >>$FILE_SCHEDULER
		} done <$FILE
		rm $FILE
	} done
	cp $FILE_SCHEDULER $FILE_SCHEDULER_COPY		# for checking of DUPs in running queue -> scheduler_add()
	
	while read LINE; do {
		func_scheduler_wait_till_cpuload_is_low "$LINE"
		func_log $FUNC daemon debug "running '$LINE'"
		/bin/sh -c "$LINE"
	} done <$FILE_SCHEDULER
	
	rm $FILE_SCHEDULER $FILE_SCHEDULER_COPY $LOCKFILE
}
