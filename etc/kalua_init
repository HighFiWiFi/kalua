#!/bin/sh

# this outputs an inital small loader which can be sourced for each 'class', e.g. for class 'wifi':
#
# idee: methode 'unload' ?
# idee: methode help?
# idee: $FUNCNAME fuellen ODER alle Vorkommen von FUNCNAME durch realen zur "compile-zeit" ersetzen
##### idee: funktionsausrufe innerhalb der klasse optimieren, d.h. innerhalb von _wifi wird der aufruf "_wifi txpwr_get" durch _wifi_txpwr_get ersetzt
# idee: passend zur klasse automatisch einen bestimmten variablensatz aktivieren (z.b. $INTRANET bei pfilter)?
# idee: statistik anzeigen lassen per befehl: sed -n "s/^\(.*\) ().*/\1/p" $BASEDIR/${CLASS} | wc -l | sed 's/ //g'
# idee: anzahl der maximalen argumente die in einem aufruf vorkommen klassenspezifisch dynamisch bestimmen
# idee: netparam ohne *MTU|BRC|OLSR|MSK|LO*
# todo: option zum entfernen aller logmeldungen? (bzw. nur log-debug)
# todo: lade-log an/aus (loader/realclass)
# idee: - trailing spaces oder tabs entfernen
# idee: - aufpassen, das dies nicht innerhalb von cat <<EOF EOF passiert

STARTTIME="$( date +%s )"
DEBUG="$1"		# debug or empty
STRIP="$2"		# strip or empty
BASEDIR="/etc/kalua"	# scriptbase, simply throw your 'class'-files here e.g. wifi
LOADER="/tmp/loader_$$"	# scripts can source this file and automatically use all 'classes'
LOADER_FINAL="/tmp/loader"
POOLDIR="/tmp/kalua"	# all function-scripts are rewritten (stripped) to this dir

mkdir -p "$POOLDIR"

echo  >"$LOADER" "# generated by $0"
echo >>"$LOADER" "export TZ='CET-1CEST-2,M3.5.0/2,M10.5.0/3'"
echo >>"$LOADER" "_(){ ls -1 $POOLDIR|sort|sed 's/^/_/';}"

max_arguments ()		# fixme! find a way to ignore internal class calls -> must be marked
{				# fixme! find a way to identify calls like _sanitizer do "string" arg1 arg2 arg3 argN
	local FILE="$1"		# fixme! find a way to count '$@', e.g. profile_local_include_vars
	local ARG KEY LIST
	
	while :; do {
		ARG=$(( ${ARG:-0} + 1 ))
		KEY=$ARG
		[ $ARG -gt 9 ] && KEY="{$ARG}"
		LIST="$LIST\"\$$KEY\" "
		fgrep -q "\$$ARG" "$FILE" && continue
		fgrep -q "\${${ARG}" "$FILE" && continue
		break
	} done

	echo "$LIST"
}
	
for CLASS in $( find $BASEDIR -type f ); do {
	CLASS="$( basename $CLASS )"			# generate loader and add methods 'show'+'include'

	MAX_ARGS="$( max_arguments "$BASEDIR/$CLASS" )"

	[ "$DEBUG" = "debug" ] && {
		DEBUG1=" logger \"realclass:$CLASS name:\$1 args:${MAX_ARGS#* } ;"
		DEBUG2=" logger -- \"--- loader:$CLASS name:\$1 args:${MAX_ARGS#* } ;"		# omit first ARG
	}

	cat >"$POOLDIR/${CLASS}" <<EOF
_${CLASS}(){ ${DEBUG1}_${CLASS}_\${1:-show} ${MAX_ARGS#* };}
_${CLASS}_show(){ sed -n '1,2ds/^\(.*\) ().*/\1/p' $POOLDIR/${CLASS} | sort ;}
_${CLASS}_include(){ :;}
EOF
	cat >>"$POOLDIR/${CLASS}" $BASEDIR/$CLASS	# copy all functions to pool

	[ "$STRIP" = "strip" ] && {
		sed -i	-e 's/ [ 	]*#.*//g' \
			-e 's/	[ 	]*#.*//g' \
			-e '/^#/d' \
			-e '/^	#/d' \
			-e 's/^[ 	]*//' \
			-e '/^$/d' 		"$POOLDIR/${CLASS}"	# strip inline comments, comments at line start, leading spaces/tabs, empty lines
	}

	sed -i "/_$CLASS ./s/_$CLASS /_${CLASS}_/g" "$POOLDIR/${CLASS}"		# make internal calls more efficient, e.g. in _wifi() all "_wifi arg" -> "_wifi_arg"

	echo -en >>"$LOADER" "_${CLASS}(){ . $POOLDIR/${CLASS};${DEBUG2}_${CLASS} $MAX_ARGS;}\n"
} done

[ -e /tmp/NETPARAM ] && {				# fixme! better concept needed
	. /tmp/NETPARAM
	
	while read LINE; do {
		echo >>"$LOADER" -n "${LINE};"
	} done </tmp/NETPARAM
	
	echo -en >>"$LOADER" "WIFI_DEVS=$WIFIDEV\n"
}

. /etc/variables_fff+
echo >>"$LOADER" "FFF_PLUS_VERSION=$FFF_PLUS_VERSION;FFF_VERSION=$FFF_VERSION"

mv "$LOADER" "$LOADER_FINAL"
. "$LOADER_FINAL"			# fixme! rely on external functions _log + _file ?

echo -n "$WIFIDEV" >/tmp/WIFIDEV	# is a hack for fast seeking our dev/ip
echo -n "$WIFIADR" >/tmp/WIFIADR

_log do "gen_loader" daemon info "generated '$LOADER_FINAL' (in $(( $( date +%s ) - $STARTTIME ))sec, using $( _file diskusage $POOLDIR ) bytes in $POOLDIR) - you MUST reinclude the new loader with '. $LOADER_FINAL' if this is an interactive shell"
