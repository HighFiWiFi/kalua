#!/bin/sh

. /tmp/loader

if [ -n "$FAILSAFE" ] || [ -n "$READONLY" ]; then exit; fi

_firmware_burn_if_exists () {
	_userdata_safe

	cp $FIRMWARE_IN_FLASH $FIRMWARE_IN_RAM
	/usr/sbin/firmware-burn $FIRMWARE_IN_RAM
	
	sleep 10                                        # normally not needed
	rm -f $FIRMWARE_IN_FLASH $FIRMWARE_IN_RAM       # normally not needed
	func_safe_reboot "firmware-burn not successful"
}

_userdata_safe () {
	# fff_restore_web_file="http://url1;full_path_to_destination1;http://url2;full_path_to_destination2"	# wget -O dest1 "http://url1"
	# fff_backup_on_device="full_path_file1;full_path_file2;full_path_file3"				# tar czf /tmp/configs.tgz file1 file2 file3
	# fff_restore_web_tagz=""										# tar xzf /tmp/webdata.tgz

	local FILE="/www/images/intro.jpg"
	local  MAX="30000"

	# test "$(cat $FILE | wc -c)" -gt "$MAX" && return
	# test "$(md5sum /rom/www/images/intro.jpg | cut -d" " -f1)" = "$(md5sum $FILE | cut -d" " -f1)" && return

	# nvram set fff_user="$(ipkg status | sed -n 's/^Package: \(.*\)/\1;/p')"		# all packages that are somehow (even maybe not fully) installed

	# nvram set fff_safe_pic="$(/www/cgi-bin/freifunk-upload -b2a <$FILE)"
	# nvram commit
}

_userdata_restore () {
	local FILE="/www/images/intro.jpg"
	local  OUT="$(nvram get fff_safe_pic)"
	
	test -z "$OUT" && return
	echo "$OUT" | /www/cgi-bin/freifunk-upload -a2b >"$FILE"
	nvram unset fff_safe_pic
	nvram commit
}

_software_list_build () {
	# we generate a list of all installed packages, and this
	# list gets installed after next flashing

	local DAEMON="_software_list_build"
	local LIST="$(ipkg status | sed -ne 's/^Package: \(.*\)/\1/p' | while read LINE; do printf "$LINE ";done)"

	_log do "$DAEMON" daemon info "generated this ipkg-list: $LIST"
	_log do "$DAEMON" daemon info "generated this ipkg-list: $LIST"

	nvram set fff_override_fw_ipkg="$LIST" commit
}

_firmware_check_for_newer () {
	local DAEMON="_firmware_check_for_newer"
	
	local URL_BETA_FW="$(    func_links_get_url_firmware beta )"
	local URL_TESTING_FW="$( func_links_get_url_firmware testing )"
	
	local RANDOM="$(dd if=/dev/urandom bs=2 count=1 2>&- | hexdump | if read line; then echo 0x${line#* }; fi)"
	local WAIT="$(( $RANDOM % 1234))"			# not all 600 routers should wgetting an 1mb-file from internet at the same time
	local WAIT_SHORT="$(( $RANDOM % 60))"			# not all 600 routers should wgetting the version.txt from internet at the same time
	local USERWISH=""
	local MODE="$(nvram get fff_autofwupdate)"

	if [ -n "$FORCE_USERWISH" ]; then
		MODE=$FORCE_USERWISH	
		FFF_PLUS_VERSION=0
	fi

	if [ -n "$NOPAUSE" ]; then
		_log do "$DAEMON" daemon info "invoked with \"nopause\"-switch, setting sleep-timers to zero"
		_log do "$DAEMON" daemon info "invoked with \"nopause\"-switch, setting sleep-timers to zero"
	
		WAIT=0
		WAIT_SHORT=0
	fi

	_log do "$DAEMON" daemon info "Sleeping for $WAIT_SHORT sec (\"jitter\"), before grabbing version"
	_log do "$DAEMON" daemon info "Sleeping for $WAIT_SHORT sec (\"jitter\"), before grabbing version"
	sleep $WAIT_SHORT
	local CURRENT="$( func_links_get_url_firmware version_current stable )"

	URL_FIRMWARE_CURRENT="$( func_links_get_url_firmware stable )"
	
	_log do "$DAEMON" daemon info "Sleeping for $WAIT_SHORT sec (\"jitter\"), before grabbing version"
	_log do "$DAEMON" daemon info "Sleeping for $WAIT_SHORT sec (\"jitter\"), before grabbing version"
	sleep $WAIT_SHORT
	local CURRENT_BETA="$( func_links_get_url_firmware version_current beta )"
	
	_log do "$DAEMON" daemon info "Sleeping for $WAIT_SHORT sec (\"jitter\"), before grabbing version"
	_log do "$DAEMON" daemon info "Sleeping for $WAIT_SHORT sec (\"jitter\"), before grabbing version"
	sleep $WAIT_SHORT
	local CURRENT_TESTING="$( func_links_get_url_firmware version_current testing )"

	_log do "$DAEMON" daemon info "Sleeping for $WAIT_SHORT sec (\"jitter\"), before grabbing main version"
	_log do "$DAEMON" daemon info "Sleeping for $WAIT_SHORT sec (\"jitter\"), before grabbing main version"
	sleep $WAIT_SHORT
	local CURRENT_MAIN="$( func_links_get_url_firmware version_installed )"
	
	local DOIT="0"

	_log do "$DAEMON" daemon info "my version:      $FFF_PLUS_VERSION"
	_log do "$DAEMON" daemon info "my version:      $FFF_PLUS_VERSION"
	_log do "$DAEMON" daemon info "current_stable:  $CURRENT"
	_log do "$DAEMON" daemon info "current_stable:  $CURRENT"
	_log do "$DAEMON" daemon info "current_beta:    $CURRENT_BETA"
	_log do "$DAEMON" daemon info "current_beta:    $CURRENT_BETA"
	_log do "$DAEMON" daemon info "current_testing: $CURRENT_TESTING"
	_log do "$DAEMON" daemon info "current_testing: $CURRENT_TESTING"
	_log do "$DAEMON" daemon info "current_main:    $CURRENT_MAIN"
	_log do "$DAEMON" daemon info "current_main:    $CURRENT_MAIN"
	_log do "$DAEMON" daemon info "update-mode:     $MODE"
	_log do "$DAEMON" daemon info "update-mode:     $MODE"

	test -z "$MODE"		 && USERWISH="stable"
	test "$MODE" = "stable"  && USERWISH="stable"
	test "$MODE" = "beta"	 && USERWISH="beta"
	test "$MODE" = "testing" && USERWISH="testing"

	if [ -n "$FORCE_USERWISH" ]; then
		DOIT=1
		USERWISH=$FORCE_USERWISH
	fi

	_log do "$DAEMON" daemon info "update-mode-conclusion: $USERWISH"
	_log do "$DAEMON" daemon info "update-mode-conclusion: $USERWISH"


	# fixme! we need some more work here:
	# situation could be: stable is newer than beta
	# we have to test: update? which of the installation canditates is the newest
	# DOIT=1 should be DOIT=versionnumber and only be altered of newer than before
	
	local RESULTING_UPDATEMODE="stable"

	if [ "$USERWISH" = "stable" ] && [ "$CURRENT" -gt "$FFF_PLUS_VERSION" ]; then DOIT=1; fi	# stable = stable
	
	  if [ "$USERWISH" = "beta" ] && [ "$CURRENT_BETA" -gt "$FFF_PLUS_VERSION" ]; then		# beta = beta and...

	  	DOIT="1"
	  	URL_FIRMWARE_CURRENT="$URL_BETA_FW"
		RESULTING_UPDATEMODE="beta"

	elif [ "$USERWISH" = "beta" ] && [ "$CURRENT" -gt "$FFF_PLUS_VERSION" ]; then			# ...stable
	
		DOIT="1"
	fi
	
	  if [ "$USERWISH" = "testing" ] && [ "$CURRENT_TESTING" -gt "$FFF_PLUS_VERSION" ]; then	# testing = testing and...

		DOIT="1"
		URL_FIRMWARE_CURRENT="$URL_TESTING_FW"
		RESULTING_UPDATEMODE="testing"
	
		if [ "$USERWISH" = "testing" ] && [ "$FFF_VERSION" = "$CURRENT_MAIN" ]; then		# doing incremental update
		
			_log do "$DAEMON" daemon info "main_myself: $FFF_VERSION main_server: $CURRENT_MAIN - doing incremental update"
			_log do "$DAEMON" daemon info "main_myself: $FFF_VERSION main_server: $CURRENT_MAIN - doing incremental update"
			$0 poor_mens_update
			DOIT=0
		fi
	
	elif [ "$USERWISH" = "testing" ] && [ "$CURRENT_BETA" -gt "$FFF_PLUS_VERSION" ]; then		# ...beta and...

		DOIT="1"
		URL_FIRMWARE_CURRENT="$URL_BETA_FW"
		RESULTING_UPDATEMODE="beta"
		
	elif [ "$USERWISH" = "testing" ] && [ "$CURRENT" -gt "$FFF_PLUS_VERSION" ]; then		# ...stable
		
		DOIT="1"
	fi

	_log do "$DAEMON" daemon info "download-url would be: \"$URL_FIRMWARE_CURRENT\""
	_log do "$DAEMON" daemon info "download-url would be: \"$URL_FIRMWARE_CURRENT\""

	if [ "$DOIT" = "1" ]; then
		_log do "$DAEMON" daemon info "New firmware detected! (my: $FFF_PLUS_VERSION  current:$CURRENT current-beta:$CURRENT_BETA current-testing:$CURRENT_TESTING)"
		_log do "$DAEMON" daemon info "New firmware detected! (my: $FFF_PLUS_VERSION  current:$CURRENT current-beta:$CURRENT_BETA current-testing:$CURRENT_TESTING)"

		if [ ! -z "$(nvram get fff_override_fw_ipkg)" ]; then					# safe the installed package list
			_software_list_build
		fi

		_log do "$DAEMON" daemon info "Sleeping for $WAIT sec (\"jitter\"), before downloading firmware"
		_log do "$DAEMON" daemon info "Sleeping for $WAIT sec (\"jitter\"), before downloading firmware"
		
		sleep $WAIT
			
		fkt_fetch_firmware

		_log do "$DAEMON" daemon info "Checking CRC"
		_log do "$DAEMON" daemon info "Checking CRC"

		local CHECK="$(/www/cgi-bin/freifunk-upload -c /www/fw.trx)"
		
		_log do "$DAEMON" daemon info "Checking server MD5"
		_log do "$DAEMON" daemon info "Checking server MD5"
		local FW_CRC_SERVER="$( func_links_get_url_firmware $RESULTING_UPDATEMODE crc )"
		_log do "$DAEMON" daemon info "Checking local MD5"
		_log do "$DAEMON" daemon info "Checking local MD5"
		local FW_CRC_REAL="$( md5sum /www/fw.trx | cut -d" " -f1 )"
		_log do "$DAEMON" daemon info "Comparing both MD5-crc's"
		_log do "$DAEMON" daemon info "Comparing both MD5-crc's"
		test "$FW_CRC_SERVER" = "$FW_CRC_REAL" && CHECK_MD5=ok

		if [ "$CHECK" = "ok" ] && [ "$CHECK_MD5" = "ok" ]; then
			_log do "$DAEMON" daemon info "CRC - ok, sleeping for $WAIT sec and rebooting"
			_log do "$DAEMON" daemon info "CRC - ok, sleeping for $WAIT sec and rebooting"
			sleep $WAIT
			func_safe_reboot "firmware-image successful downloaded"
		else
			_log do "$DAEMON" daemon info "CRC - error, removing download, abort."
			_log do "$DAEMON" daemon info "CRC - error, removing download, abort."
			rm -f "/www/fw.trx"						# not needed, above check does rm this
			rm -f "$SOFTWARE_FULLY_INSTALLED"				# to ensure, that we reinstall all packets
			func_safe_reboot "firmware-image download unsuccessful"
		fi
	else
		_log do "$DAEMON" daemon info "I'am up to date 8-)"
		_log do "$DAEMON" daemon info "I'am up to date 8-)"
	fi
}

fkt_install_latest_tarball () {
	local DAEMON="fkt_install_latest_tarball"
	local FILE="/tmp/tarball.tgz"
	local URL_FIRMWARE_TARBALL="$( func_links_get_url_firmware tarball )"
	
	_log do "$DAEMON" daemon info "fetching from \"$URL_FIRMWARE_TARBALL\""
	_log do "$DAEMON" daemon info "fetching from \"$URL_FIRMWARE_TARBALL\""
	
	wget -O $FILE "$URL_FIRMWARE_TARBALL"
	
	if [ "$?" -ne 0 ]; then
		_log do "$DAEMON" daemon info "error during download, aborting."
		_log do "$DAEMON" daemon info "error during download, aborting."
		return 1
	fi
	
	_log do "$DAEMON" daemon info "unpacking and overwriting existing files"
	_log do "$DAEMON" daemon info "unpacking and overwriting existing files"
	
	cd /
	tar xvzf $FILE

	_log do "$DAEMON" daemon info "removing download archiv"
	_log do "$DAEMON" daemon info "removing download archiv"
	rm -f $FILE

	_log do "$DAEMON" daemon info "patching banner-file for helping you to remember..."
	_log do "$DAEMON" daemon info "patching banner-file for helping you to remember..."
	
	echo "# manually updated with poormens method on $(date) to this version"	>>/etc/banner
	echo "# originally flashed version: $( grep ^Kit: /etc/freifunk-release )"	>>/etc/banner
	tail -n2 /etc/variables_fff+							>>/etc/banner
	echo "#"									>>/etc/banner 
	echo										>>/etc/banner
	
	_log do "$DAEMON" daemon info "done. reboot maybe not necessary."
	_log do "$DAEMON" daemon info "done. reboot maybe not necessary."
}

fkt_fetch_firmware ()
{
	local FUNC="fetch_firmware"
	local FREE_WANTED="1750"		# which means 1750-120 = 1630 useable kilobyte for image-file (should ne enough 8-) )
	local DAEMON="fkt_fetch_firmware"
	local DESTINATION="/www/fw.trx"
	local RETRY_COUNT=0
	local IPK
	local PACKAGES="$( ipkg status | grep Package: | cut -d" " -f2 | sed '1!G;h;$!d' )"	# newest package at first

	scheduler -p				# purge all queues
	/etc/init.d/S90webcam_fff+ stop	
	/etc/init.d/S52vpn_fff+ stop		# for safe uninstalling this package
	
	[ -e /tmp/LOWMEM ] && for IPK in $PACKAGES; do {			# firmware-download to flash only on lowmem-devices
		
		_log do "$DAEMON" daemon info "now free: $(func_system_flash_free) kb"
		_log do "$DAEMON" daemon info "now free: $(func_system_flash_free) kb"
		[ "$(func_system_flash_free)" -gt "$FREE_WANTED" ] && break
		_log do "$DAEMON" daemon info "removing package '$IPK'"
		_log do "$DAEMON" daemon info "removing package '$IPK'"
		
		func_ipkg_remove $IPK
	} done

	[ "$(func_system_flash_free)" -lt "$FREE_WANTED" ] && {
		_log do $FUNC daemon crit "could'nt free target-flash space, strange!"
		DESTINATION="/tmp/fw.trx"
		local FW_IN_RAM="true"
	}

	rm "$DESTINATION"
	while true; do {
		
		wget -c -O "$DESTINATION" "$URL_FIRMWARE_CURRENT" && {
			_log do $FUNC daemon info "download successful"
			break
		}

		scheduler -p
		
		[ "$(func_system_flash_free)" -lt 120 ] && {
			_log do $FUNC daemon crit "low flash space, during download?"
			DESTINATION="/tmp/fw.trx"
			local FW_IN_RAM="true"
			rm "$DESTINATION"
			RETRY_COUNT=0
		}
		
		RETRY_COUNT=$(( $RETRY_COUNT + 1 ))
		[ "$RETRY_COUNT" -gt 50 ] && {
			rm -f "$SOFTWARE_FULLY_INSTALLED"	# to ensure, that we reinstall all removed packages...
			rm -f "$DESTINATION"
			func_safe_reboot "firmware download unseccussful"	# fixme!
		}

		_log do $FUNC daemon info "something went wrong during download...retrying in 30 sec (try: $RETRY_COUNT)"
		sleep 30
	} done

	scheduler -p
	
	[ "$FW_IN_RAM" = "true" ] && {
		_log do $FUNC daemon info "burning firmware directly"
		/usr/sbin/firmware-burn "$DESTINATION"
		func_safe_reboot "firmware burning unsuccessful"
	}
	
	_log do "$DAEMON" daemon info "download ready."
	_log do "$DAEMON" daemon info "download ready."
}

. /tmp/loader

FIRMWARE_IN_FLASH="/www/fw.trx"
FIRMWARE_IN_RAM="/tmp/fw.trx"  

test "$2" = "nopause" && NOPAUSE=true
test "$3" = "forcemode" && FORCE_USERWISH=$4

case $1 in
        start)
		[ -e $FIRMWARE_IN_FLASH ] && {
			_userdata_restore
			_firmware_burn_if_exists
			return
		}
		
		_log do burn_firmware_if_exists daemon debug "no new firmwareimage found - do nothing"
	;;
	check_neighbour)
		# fixme! here should be a routine to check a random (good) neighbour for newer version
		_firmware_check_for_newer $URL_TO_CHECK $URL_TO_FETCH
	;;
	check)
		[ "$(nvram get fff_autofwupdate)" = "0" ] && {
			_log do "$0" daemon info "no execution, no automatic update"			
			_log do "$0" daemon info "no execution, no automatic update"			
			exit
		}
		
		_log do check daemon info "initiating test for new firmware"
		
		[ -e "$LOWFLASH" ] && {
			_log do check daemon info "LOW_FLASH-device - abort"
			exit
		}
		
			# checks to add:	//fixme!
			# fff_autofwupdate = 0			("fuck off, i do not thrust you!")
			# fff_autofwupdate = testing 		("i want to brick my router")
			# fff_autofwupdate = beta		("small fixes")
			# fff_autofwupdate = stable = unset	("great releases")
		
		_firmware_check_for_newer
	;;
	forcecheck)
		_firmware_check_for_newer
	;;
	pmu|poor_mens_update)
		fkt_install_latest_tarball && {
			_log do poormens_update daemon debug "successfully installed latest tarball - restarting some services"
			/etc/init.d/S41build_static_netparam start
			/etc/init.d/S51crond_fff+ restart
		
			_log do "poormens_update" daemon info "checking interface/settings"
			_log do "poormens_update" daemon info "checking interface/settings"
			/etc/init.d/S02check_interface_correctness_fff\+

			_log do "poormens_update" daemon info "checking dns/packetfilter-services"
			_log do "poormens_update" daemon info "checking dns/packetfilter-services"
			scheduler -a "/etc/init.d/S43ethers_fff+ start"
			scheduler -a "/etc/init.d/S45firewall restart"
			scheduler -a "/etc/init.d/S50dnsmasq restart"
		
			tail -n 6 /etc/banner

			_log do "poormens_update" daemon info "sending alive message"
			_log do "poormens_update" daemon info "sending alive message"
			scheduler -a "/etc/init.d/S69watch_olsrd_fff+ send_alive_message fast"
		
			_log do "poormens_update" daemon info "ready"
			_log do "poormens_update" daemon info "ready"
		}
	;;
	*)
		_log do print_usage daemon debug "working"
		echo "Usage: $0 ( start | check | forcecheck | pmu = poor_mens_update | [nopause] = do it as fast as possible without any sleeps [forcemode stable,beta,testing] )"
	;;
esac
