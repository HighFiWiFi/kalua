#!/bin/sh
. /tmp/loader

func_cron_daemon_start ()
{
	local FUNC="cron_daemon_start"
	
	pidof crond >/dev/null && {
		_log do $FUNC daemon debug "already started"
		return
	}
	
	/usr/sbin/crond -L /dev/null || {
		_log do $FUNC daemon debug "error"
		return
	}
	
	_log do $FUNC daemon info "daemon started"
}

func_cron_daemon_stop ()
{
	local FUNC="cron_daemon_stop"
	
	pidof crond >/dev/null && {
		_log do $FUNC daemon info "killing"
		killall crond
		return
	}
	
	_log do $FUNC daemon debug "no daemon running"
}

func_cron_start ()
{
	func_cron_config_write $1
	func_cron_daemon_start
}

func_cron_stop ()
{
	func_cron_daemon_stop
}

func_cron_status ()
{
	local FUNC="cron_status"
	
	pidof crond >/dev/null || {
		_log do $FUNC daemon debug "daemon is NOT running"
		return
	}
	
	_log do $FUNC daemon debug "daemon is running"
	func_cron_config_write status
}

func_cron_config_write ()
{
	local FUNC="cron_config_write"
	local CRONFILE

	if _uci is_oldstyle ; then
		CRONFILE="/var/spool/cron/crontabs/root"	
	else
		CRONFILE="/etc/crontabs/root"
	fi

	local CRONDIR="$( dirname $CRONFILE )"

	local VDS
	[ "$( uci get system.@vds[0].enabled )" = "1" ] && VDS="-a vds"

	local OWFS="$( which owfs >/dev/null && echo -n '-a owfs' )"
	local RRDHELPER="$( which rrdcollect >/dev/null && echo -n '-a rrdhelper' )"

	local ACCOUNTING
	[ -z "$( uci get system.@weblogin[0].enabled )" ] && ACCOUNTING="-a build_accounting"

	local LINE=""
	local PROFILE="$1"

	[ "$PROFILE" = "status" ] && {
		_log do $FUNC daemon debug "status: '$CRONFILE'"
		cat $CRONFILE
		return
	}

	
	  if [ "$PROFILE" = "nano" ]; then
	  
	  	PROFILE="nano"
	
	elif [ "$PROFILE" != "minimal" ] && [ ! -e /tmp/LOWMEM ] && [ -z "$FAILSAFE" ] && [ -n "$WIFI_DEVS" ] && [ -e "/www/SOFTWARE_FULLY_INSTALLED" ]; then
	
		PROFILE="standard"
	else
		PROFILE="minimal"
	fi

	[ ! -d $CRONDIR ] && mkdir -p $CRONDIR

	if [ "$PROFILE" = "minimal" ]; then

		_log do $FUNC daemon debug "profile = minimal"
		cat >$CRONFILE <<EOF
*    * * * * pidof cron.minutely >/dev/null || /usr/sbin/cron.minutely; pidof S69watch_olsrd_fff+ >/dev/null || /etc/init.d/S69watch_olsrd_fff+ watch_hanging_command
*/15 * * * * sleep 6; pidof S69watch_olsrd_fff+ >/dev/null || /etc/init.d/S69watch_olsrd_fff+ ; scheduler -a 1h_checks -a software_install -r
0    4 * * * scheduler -a fwupdate_check
EOF
	elif [ "$PROFILE" = "nano" ]; then
		_log do $FUNC daemon debug "profile = nano"
		cat >$CRONFILE <<EOF
* * * * * /usr/sbin/cron.minutely
EOF
	else
	
	# we try to call the scheduler each for each, not all at one point

		_log do $FUNC daemon debug "profile = standard"	
		cat >$CRONFILE <<EOF
*    * * * * pidof cron.minutely >/dev/null || /usr/sbin/cron.minutely
*    * * * * scheduler -O -P -u -o -s 17 $RRDHELPER -a speedtest_every_40min -a whitelist_rebuild_every_3h -a whitelist_update_every_15h -a upgrade_packages -r
*/15 * * * * sleep  8; scheduler -a gateway_check $VDS -a 15min_checks -a monitoring -a optimize_txpower -a user_traff_broadcast $ACCOUNTING -a kick_user_over_limit -A watch_hanging_command \$( [ "\$(date +%M)" = "00" ] && echo "-a 1h_checks -a restart_vpn" )
0    3 * * * sleep 12; scheduler -a rebuild_service_announce -a recheck_wired_olsr -a restart_olsr
0    4 * * * sleep 12; $TICKETS scheduler -a fwupdate_check -a splash4nonautounsplashed
0    6 * * * sleep 12; scheduler -a build_service_announce -a recheck_wired_olsr -a restart_olsr -a user_traff_reset -a kick_user_all
0    0 * * * sleep  8; scheduler -a 24h_checks
EOF
	fi

	# fixme! this load/time/mem-consuming:
	# stage1: only do 'echo "$CRONLINE" >/tmp/JOBS/$$_$keyword' and slowly fetch this with scheduler
	# stage2: only have cron.each_minute, which does a simple check, which jobs have to be scheduled

	while read LINE; do {
		_log do $FUNC daemon debug "+ '$LINE'"
	} done <$CRONFILE
}

case $1 in
	start)
		func_cron_start $2
	;;
	minimal)
		func_cron_start minimal
	;;
	stop)
		func_cron_stop	
	;;
	restart)
		func_cron_stop
		func_cron_start $2
	;;
	status)
		func_cron_status
	;;
	*)
		echo "Usage: $0 (stop | start [nano|minimal|standard] | restart [...] | status)"
	;;
esac

