#!/bin/sh
. /tmp/loader

func_cron_daemon_start ()
{
	local FUNC="cron_daemon_start"
	
	pidof crond >/dev/null && {
		_log do $FUNC daemon debug "already started"
		return 1
	}
	
	/usr/sbin/crond -L /dev/null || {
		_log do $FUNC daemon debug "error"
		return 1
	}
	
	_log do $FUNC daemon info "[OK] started"
}

cron_watchdog()
{
	local mode="$1"		# start|stop

	_uci is_oldstyle && return		# we have crondog.o on old devices

	local interval_sec=60
	local cronpid watchdog_id
	local watchdog_id_file="/tmp/cron_watchdog.id"

	case "$mode" in
		start)
			watchdog_id="$( _math random_integer 1 999999 )"
			echo $watchdog_id >$watchdog_id_file
			cronpid="$( _system get_first_pid crond )"

			cat >/tmp/.autorun <<EOF
#!/bin/sh
rm \$0

logger -s -t cron_watchdog -p daemon.info "checking each $interval_sec sec for crondpid $cronpid, see $watchdog_id_file"
sleep 50	# only work, when (mostly) nothing else is done (this script starts ~ at second :00)
logger -s -t cron_watchdog -p daemon.info "[OK] starting up"

while true
do
	if [ -e /tmp/cron_watchdog_please_end_yourself_$watchdog_id ]; then		# the new crond will send this
		rm /tmp/cron_watchdog_please_end_yourself_*
		. /tmp/loader
		_log do cron_watchdog daemon info "[OK] ending myself with ID $watchdog_id"
		exit
	else
		[ -d /proc/$cronpid ] || {
			. /tmp/loader
			_log do cron_watchdog daemon alert "no crond found, starting cron + watchdog"
			$0 start
			exit
		}
	fi

	sleep $interval_sec
done &
EOF
			chmod +x /tmp/.autorun
			cp /tmp/.autorun ${watchdog_id_file}.script.tmp.autorun
		;;
		stop)
			[ -e "$watchdog_id_file" ] && {
				read watchdog_id <$watchdog_id_file
				touch /tmp/cron_watchdog_please_end_yourself_$watchdog_id

				while [ -e /tmp/cron_watchdog_please_end_yourself_$watchdog_id ]; do {
					_log do cron_watchdog daemon debug "waiting for deletion of '/tmp/cron_watchdog_please_end_yourself_$watchdog_id'"
					sleep 10
				} done

				rm $watchdog_id_file ${watchdog_id_file}.script.tmp.autorun
				_log do cron_watchdog daemon info "[OK] old watchdog gone"
			}
		;;
	esac
}

func_cron_daemon_stop ()
{
	local FUNC="cron_daemon_stop"
	
	pidof crond >/dev/null && {
		_log do $FUNC daemon info "killing"
		killall crond
		return
	}

	_log do $FUNC daemon debug "no daemon running"
}

func_cron_start ()
{
	func_cron_config_write $1
	func_cron_daemon_start && cron_watchdog start
}

func_cron_stop ()
{
	cron_watchdog stop
	func_cron_daemon_stop
}

func_cron_status ()
{
	local FUNC="cron_status"
	
	pidof crond >/dev/null || {
		_log do $FUNC daemon debug "daemon is NOT running"
		return
	}
	
	_log do $FUNC daemon debug "daemon is running"
	func_cron_config_write status
}

func_cron_config_write ()
{
	local FUNC="cron_config_write"
	local CRONFILE

	if _uci is_oldstyle ; then
		CRONFILE="/var/spool/cron/crontabs/root"	
	else
		CRONFILE="/etc/crontabs/root"
	fi

	local CRONDIR="$( dirname $CRONFILE )"
	local OWFS="$( which owfs >/dev/null && echo -n '-a owfs' )"
	local LINE=""
	local PROFILE="$1"

	[ "$PROFILE" = "status" ] && {
		_log do $FUNC daemon debug "status: '$CRONFILE'"
		cat $CRONFILE
		return
	}

	_uci is_oldstyle || {
		PROFILE="newstyle"
	}

	  if [ "$PROFILE" = "newstyle" ]; then

		:
	
	elif [ "$PROFILE" = "nano" ]; then
	  
	  	PROFILE="nano"
	
	elif [ "$PROFILE" != "minimal" ] && [ ! -e /tmp/LOWMEM ] && [ -z "$FAILSAFE" ] && [ -n "$WIFI_DEVS" ] && [ -e "/www/SOFTWARE_FULLY_INSTALLED" ]; then
	
		PROFILE="standard"
	else
		PROFILE="minimal"
	fi

	[ ! -d $CRONDIR ] && mkdir -p $CRONDIR

	local RUN_QUEUE=". /tmp/loader; _scheduler run"

	_log do $FUNC daemon debug "profile = $PROFILE"


	if [ "$PROFILE" = "minimal" ]; then

		echo >$CRONFILE "* * * * * scheduler -S minimal; $RUN_QUEUE"

	elif [ "$PROFILE" = "nano" ]; then

		echo >$CRONFILE "* * * * * /usr/sbin/cron.minutely"

	elif [ "$PROFILE" = "newstyle" ]; then

		echo >$CRONFILE "* * * * * scheduler -S newstyle -O -P -f -H -w; $RUN_QUEUE"
	else
		echo >$CRONFILE "* * * * * scheduler -S oldstyle -O -P -f -u -o; $RUN_QUEUE"
	fi


	while read LINE; do {
		_log do $FUNC daemon debug "+ '$LINE'"
	} done <$CRONFILE
}

case $1 in
	start)
		func_cron_start $2
	;;
	minimal)
		func_cron_start minimal
	;;
	stop)
		func_cron_stop	
	;;
	restart)
		func_cron_stop
		func_cron_start $2
	;;
	status)
		func_cron_status
	;;
	*)
		echo "Usage: $0 (stop | start [nano|minimal|standard] | restart [...] | status)"
	;;
esac

