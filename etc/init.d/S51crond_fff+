#!/bin/sh
. /tmp/loader

func_cron_daemon_start ()
{
	local FUNC="cron_daemon_start"
	
	pidof crond >/dev/null && {
		_log do $FUNC daemon debug "already started"
		return
	}
	
	/usr/sbin/crond -L /dev/null || {
		_log do $FUNC daemon debug "error"
		return
	}
	
	_log do $FUNC daemon info "daemon started"
}

cron_watchdog()
{
	local mode="$1"		# start|stop

	_uci is_oldstyle && return		# we have crondog.o on old devices

	local interval_sec=60
	local cronpid watchdog_pid
	local watchdog_pidfile="/tmp/cron_watchdog.pid"

	case "$mode" in
		start)
			cronpid="$( pidof crond )"
			cronpid="${cronpid% *}"		# only first pid

			cat >/tmp/.autorun <<EOF
#!/bin/sh
rm \$0
echo \$\$ >$watchdog_pidfile
logger -s -t cron_watchdog -p daemon.info "checking each $interval_sec sec for pid of crond = $cronpid"

while true
do
	[ -e /tmp/cron_please_end_yourself_\$\$ ] && {
		rm /tmp/cron_watchdog_please_end_yourself_\$\$
		exit
	}

	[ -d /proc/$cronpid ] || {
		. /tmp/loader
		_log do cron_watchdog daemon alert "no crond found, restarting cron + watchdog"
		$0 restart
		exit
	}

	sleep $interval_sec
done &
EOF
			chmod +x /tmp/.autorun
			cp /tmp/.autorun ${watchdog_pidfile}.script.tmp.autorun
		;;
		stop)
			[ -e $watchdog_pidfile ] && {
				read watchdog_pid <$watchdog_pidfile
				rm $watchdog_pidfile ${watchdog_pidfile}.script.tmp.autorun
				# kill $watchdog_pid
				touch /tmp/cron_watchdog_please_end_yourself_$watchdog_pid

				while [ -e /proc/$watchdog_pid ]; do {
					_log do cron_watchdog daemon debug "waiting for ending of old watchdog PID $watchdog_pid"
					sleep 10
				} done

				_log do cron_watchdog daemon info "[OK] old watchdog PID $watchdog_pid is gone"
			}
		;;
	esac
}

func_cron_daemon_stop ()
{
	local FUNC="cron_daemon_stop"
	
	pidof crond >/dev/null && {
		_log do $FUNC daemon info "killing"
		killall crond
		return
	}
	
	_log do $FUNC daemon debug "no daemon running"
}

func_cron_start ()
{
	func_cron_config_write $1
	func_cron_daemon_start
	cron_watchdog start
}

func_cron_stop ()
{
	cron_watchdog stop
	func_cron_daemon_stop
}

func_cron_status ()
{
	local FUNC="cron_status"
	
	pidof crond >/dev/null || {
		_log do $FUNC daemon debug "daemon is NOT running"
		return
	}
	
	_log do $FUNC daemon debug "daemon is running"
	func_cron_config_write status
}

func_cron_config_write ()
{
	local FUNC="cron_config_write"
	local CRONFILE

	if _uci is_oldstyle ; then
		CRONFILE="/var/spool/cron/crontabs/root"	
	else
		CRONFILE="/etc/crontabs/root"
	fi

	local CRONDIR="$( dirname $CRONFILE )"
	local OWFS="$( which owfs >/dev/null && echo -n '-a owfs' )"
	local LINE=""
	local PROFILE="$1"

	[ "$PROFILE" = "status" ] && {
		_log do $FUNC daemon debug "status: '$CRONFILE'"
		cat $CRONFILE
		return
	}

	_uci is_oldstyle || {
		PROFILE="newstyle"
	}

	  if [ "$PROFILE" = "newstyle" ]; then

		:
	
	elif [ "$PROFILE" = "nano" ]; then
	  
	  	PROFILE="nano"
	
	elif [ "$PROFILE" != "minimal" ] && [ ! -e /tmp/LOWMEM ] && [ -z "$FAILSAFE" ] && [ -n "$WIFI_DEVS" ] && [ -e "/www/SOFTWARE_FULLY_INSTALLED" ]; then
	
		PROFILE="standard"
	else
		PROFILE="minimal"
	fi

	[ ! -d $CRONDIR ] && mkdir -p $CRONDIR

	_log do $FUNC daemon debug "profile = $PROFILE"

	if [ "$PROFILE" = "minimal" ]; then

		cat >$CRONFILE <<EOF
*    * * * * scheduler -S minimal; . /tmp/loader; _scheduler run
EOF
	elif [ "$PROFILE" = "nano" ]; then

		cat >$CRONFILE <<EOF
* * * * * /usr/sbin/cron.minutely
EOF

	elif [ "$PROFILE" = "newstyle" ]; then

		cat >$CRONFILE <<EOF
*    * * * * scheduler -S newstyle -O -P -f -H -w -R; . /tmp/loader; _scheduler run
EOF

	else
		cat >$CRONFILE <<EOF
*    * * * * scheduler -S oldstyle -O -P -f -u -o; . /tmp/loader; _scheduler run
EOF
	fi

	while read LINE; do {
		_log do $FUNC daemon debug "+ '$LINE'"
	} done <$CRONFILE
}

case $1 in
	start)
		func_cron_start $2
	;;
	minimal)
		func_cron_start minimal
	;;
	stop)
		func_cron_stop	
	;;
	restart)
		func_cron_stop
		func_cron_start $2
	;;
	status)
		func_cron_status
	;;
	*)
		echo "Usage: $0 (stop | start [nano|minimal|standard] | restart [...] | status)"
	;;
esac

