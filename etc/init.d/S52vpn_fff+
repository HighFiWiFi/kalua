#!/bin/sh
. /tmp/loader

# ToDo:
#	- limiting outgoing olsr-traffic (not wasting upload) ??

DIRTY=
[ "$( nvram get fff_vpn_active )" = "0" ]	&& DIRTY="fff_vpn_active set to 0"
[ -e "/tmp/LOWMEM" ]				&& DIRTY="lowmem"
[ -n "$FAILSAFE" ]				&& DIRTY="failsafe"
[ -n "$READONLY" ]				&& DIRTY="readonly"
[ ! -e "/www/SOFTWARE_FULLY_INSTALLED" ]		&& DIRTY="software not fully installed"

[ -n "$DIRTY" ] && {
	_log do init daemon debug "call: '$1' - abort: '$DIRTY'"
	exit
}

fkt_build_vars ()
{
	NODE_NUMBER="$( nvram get fff_node_number )"
	HOSTNAME="$( _system hostname_get )"
	[ -z "$HOSTNAME" ] && HOSTNAME="node$NODE_NUMBER"

	VPN_SERVER="$( nvram get fff_server_vpn_ip4 )"
	
	SERV="$( nvram get fff_server_vpn_dns )"	# _ip4|_ip6 fallback?
	CONF="/etc/local.olsrd.conf"
	KNOT=$NODE_NUMBER
	VTUN="/etc/vtund.conf"

	[ "$1" != "stop" ] && INETOFFER=$( _net local_inet_offer )
	
	eval "$( _ipsystem do )"
}

fkt_tunnel_conf_write ()
{
	local FUNC="tunnel_conf_write"
	local LINE=""
	local STATIC_ROUTE="$( func_get_static_route )"
	
	cat >$VTUN <<EOF
$HOSTNAME {
	passwd ff ;		# fixme! check MTU = 1450?
	type ether ;		# fixme! olsrd-bug: /32 interface needed?
	persist yes ;		# fimxe! add 'timeout 60' ?

	up {
		program "logger -p daemon.info -t $0_vtund.conf link_up %%:$HOSTNAME" ;
		program "ip address add $WIFIVPNCLIENTADR/$WIFIVPNPRE dev %% label %%:$HOSTNAME" ;
		program "ip address add $WIFIVPNCLIENTADR/32 dev %%" ;
		program "ip link set dev %% mtu 1450 up" ;
		program "ip route add $VPN_SERVER via $STATIC_ROUTE" ;		# + table local?
	} ;
		# fixme! static_route must only be valid for programs on this machine
	down {
		program "logger -p daemon.info -t $0_vtund.conf link_down %%:$HOSTNAME" ;
		program "ip route del $VPN_SERVER via $STATIC_ROUTE" ;
		program "ip link set dev %% down" ;
	} ;
}
EOF

	_log do $FUNC daemon debug "ready"
	while read LINE; do {
		_log do $FUNC daemon debug "${VTUN} +'$LINE'"
	} done <$VTUN
}

fkt_tunnel_conf_remove ()
{
	local FUNC="tunnel_conf_remove"

	[ -e $VTUN ] && {
		_log do $FUNC daemon debug "working"
		rm $VTUN
	}
}

fkt_tunnel_start ()
{
	local ERROR_INSTALL=false

	local FUNC="tunnel_start"
	
	[ ! -e "$VTUN" ] && {
		_log do $FUNC daemon debug "no configfile - abort"
		return
	}
	
	_system insmod tun || {
		_software package_install kmod-tun	# + 12 k
		_system insmod tun || return 1
	}
	
	_log do $FUNC daemon debug "starting vtun with config '$VTUN'"
	
	vtund $HOSTNAME $SERV 2>/dev/null || {

		_log do $FUNC daemon debug "error"	
		
		_software package_is_not_installed vtun	    && ERROR_INSTALL=true
		_software package_is_not_installed kmod-tun && ERROR_INSTALL=true
		
		if [ "$ERROR_INSTALL" = "true" ]; then
		
			_log do $FUNC daemon debug "vtund and/or kmod-tun not installed"
		
			fkt_tunnel_conf_remove
			
			_software make_free_space 1000
			_software package_install libopenssl	# +550 k
			_software package_install zlib		# +175 k
			_software package_install liblzo	# +52 k
			_software package_install vtun		# +36 k
								# ----
								# +825
		else
			vtund - 2>/dev/null | grep -q -i vtun || {
			
				_log do $FUNC daemon debug "vtund is installed, but has an serious problem"

				# under mysterious circumstances (e.g. low disk space during installing),
				# vtund claims to have a "bus error", so we should reinstall it
			
				_software package_remove  vtun
				_software package_remove  libopenssl
				_software package_install libopenssl
				_software package_install vtun
			}
		fi
		
		# cron-jobs trys later an vpn-restart
		
		return 1
	}
}

fkt_tunnel_stop ()
{
	local FUNC="tunnel_stop"
	
	pidof vtund >/dev/null && {

		_log do $FUNC daemon debug "killing tunnel-daemon"		
		killall vtund
		sleep 2
	
		pidof vtund >/dev/null && {

			_log do $FUNC daemon debug "daemon still alive, trying hard"
			killall -9 vtund
			sleep 2
			
			pidof vtund >/dev/null && {

				_log do $FUNC daemon debug "daemon still alive - error"
			}
		}
	}
}

fkt_olsr_conf_remove ()
{
	local FUNC="olsr_conf_remove"
	
	[ -e $CONF ] && {
		_log do $FUNC daemon debug "working"
		rm $CONF
	}	
}

fkt_olsr_conf_write ()
{
	local FUNC="olsr_conf_write"
	local LINE=""
	local INTERFACE="tap0"

	[ "$( _vpn_proto )" != "olsr" ] && INTERFACE=none		# fixme! this is dirty...
	
	SPEED=$( nvram get ff_olsrspeed )				# fixme! maybe multiply by 10? (lowering traffic)
	SPEED=${SPEED:=5}

        FEYE=$(nvram get ff_fisheye)
	if [ "0" != "$FEYE" ];then
		TCINT=$(( 2 * SPEED / 4 ))
		test $TCINT -eq 0 && TCINT=1
		COVER=7
		FEYE=1
	else
		TCINT=$(( 2 * SPEED ))
		COVER=3
		FEYE=0
	fi
						# these are the values for fff v1.6.34
	cat >$CONF <<EOF
Interface "$INTERFACE" {
	HelloInterval		$(( SPEED / 2 + 1 )).0
	HelloValidityTime	$(( 25 * SPEED )).0
	TcInterval		$TCINT.0
	TcValidityTime		$(( 100 * SPEED )).0
	MidInterval		$(( 5 * SPEED )).0
	MidValidityTime		$(( 100 * SPEED )).0
	HnaInterval		$(( 2 * SPEED )).0
	HnaValidityTime		$(( 25 * SPEED )).0
	Ip4Broadcast		$WIFIVPNSERVERADR
}
EOF

	_log do $FUNC daemon debug "ready"
	while read LINE; do {
		_log do $FUNC daemon debug "${CONF} +'$LINE'"
	} done <$CONF
}

func_get_static_route ()			# prevents tunneling over mesh, when local defgw gets broken
{
	local DEFAULT_GATEWAY_IP="$( ip route list exact 0/0 | head -n1 | cut -d" " -f3 )"
	
	case $INETOFFER in
		lan)
			echo -n "$DEFAULT_GATEWAY_IP dev $LANDEV"
		;;
		pppoe)
			echo -n "$( ip route list exact 0/0 dev ppp0 | head -n1 | cut -d" " -f3 ) dev ppp0"
		;;
		*)
			echo -n "$DEFAULT_GATEWAY_IP dev $WANDEV"
		;;
	esac
}

_vpn_proto ()						# defaults to 'olsr'
{
	local PROTO="$( nvram get fff_vpn_proto )"
	
	echo -n "${PROTO:-olsr}"			# fixme! none,olsr,batman,batman-adv,...
}

func_sending_request_to_vpnserver_for_participation ()
{
	local FUNC="sending_request_to_vpnserver_for_participation" 
	local OUTPUT=""
	local URL="http://$VPN_SERVER/freifunk/vpn/"
	local QUERY=""
	local ADMINMAIL="$( nvram get ff_adm_mail )"
	
	QUERY="${QUERY}?CLIENTIP=${WIFIVPNCLIENTADR}"
	QUERY="${QUERY}&SERVERIP=${WIFIVPNSERVERADR}"
	QUERY="${QUERY}&NAME=$HOSTNAME"
	QUERY="${QUERY}&PROTO=$( _vpn_proto )"
	QUERY="${QUERY}&EMAIL=$( _sanitizer do "${ADMINMAIL:=unset@box.local}" urlvalue )"
	QUERY="${QUERY}&COMMENT=city${FFF_CITY}_node${NODE_NUMBER}_profile$( nvram get fff_profile )"

	_log do $FUNC daemon debug "query: '${URL}${QUERY}'"
	
	OUTPUT="$( wget 2>/dev/null -O - "${URL}${QUERY}" )"	# fixme! encode unsafe URL chars (like email above)

	_log do $FUNC daemon debug "answer: '$OUTPUT'"
}

func_vpn_start ()
{
	local FUNC="func_vpn_start"

	[ $INETOFFER = "false" ] && {
		_log do $FUNC daemon debug "no local default gateway - abort"
		return 1
	}

	[ -z "$NODE_NUMBER" ] && {
		_log do $FUNC daemon debug "node not configured yet - abort"
		return 1
	}
		
	func_sending_request_to_vpnserver_for_participation
	fkt_tunnel_conf_remove
	fkt_tunnel_conf_write
	fkt_olsr_conf_remove
	fkt_olsr_conf_write
	fkt_tunnel_start && {
		pidof olsrd >/dev/null && {
			[ "$( _vpn_proto )" = "olsr" ] && {
				_scheduler add "restart_olsr"
				return
			}
		}
		_log do $FUNC daemon debug "olsr not up or olsr-proto unwished, no need for restart of olsrd"
	}
}

func_vpn_stop ()
{
 	fkt_tunnel_conf_remove
 	fkt_olsr_conf_remove
  	fkt_tunnel_stop
}

func_vpn_status ()
{
	FUNC="vpn_status"
	
	pidof vtund >/dev/null && {
		_log do $FUNC daemon debug "daemon running"

		grep -q ^"Interface .*tap0" /etc/olsrd.conf || {	# fixme! more abstraction: tun/tapXY + conf-filename
			_log do $FUNC daemon debug "daemon running but tunnel-device not used by olsr"
			return 1
		}
		_log do $FUNC daemon debug "tunnel-device is in olsr.conf"
		
		ps ax | grep vtund | grep -q connecting && {
			_log do $FUNC daemon debug "daemon running but connection seems broken"
			return 1
		}
		_log do $FUNC daemon debug "connection seems active"
		
		neigh | grep -q "==1==" || {				# fixme! implement: 'neigh has_tunnel_neigh'
			_log do $FUNC daemon debug "no tunnel-olsr neighs?"
			return 1
		}
		_log do $FUNC daemon debug "tunnel-olsr neigh available"
		
		return 0
	}
	
	_log do $FUNC daemon debug "daemon NOT running"
	return 1
}

case $1 in
	start)
		fkt_build_vars
		func_vpn_start
	;;
	stop)
		fkt_build_vars stop
		func_vpn_stop
 	;;
	restart)
		fkt_build_vars
		func_vpn_status && {
	
			[ "$INETOFFER" = "false" ] && {
				_log do restart daemon debug "no more inetoffer, stop running vpn"
				func_vpn_stop
				exit
			}
		
			[ "$2" != "--force" ] && {
				_log do restart daemon debug "ignoring call"
				exit
			}
		}
		
		func_vpn_stop
		func_vpn_start
      	;;
      	status)
      		func_vpn_status
      	;;
	*)
		echo "Usage: $0 (start|stop|restart (--force)|status)"
	;;
esac
