#!/bin/sh
exit
_usage ()
{
	echo "Usage: $0 (start|stop|restart)"
	return 1
}

_ip4_octet3 ()
{
	echo $1 | sed -n 's/^[0-9]*\.[0-9]*\.\([0-9]*\)\.[0-9]*/\1/p'
}

_list_get_obj ()
{
	local LIST="$1"
	local OBJCOUNT="$2"
	local COUNT=1
	local OBJ
	
	for OBJ in $LIST; do {
		if [ $COUNT -eq $OBJCOUNT ]; then
			echo -n $OBJ
			break
		else
			COUNT=$(( $COUNT + 1 ))
		fi
	} done
}

_global_vars ()			# wenn gateway = ich selbst, dann aus request-queue laden?
{
	[ "$1" = "stop" ] && TUNNEL_NO=0

	TUNNEL_NO=$(( ${TUNNEL_NO:-0} + 1 ))
	TUNNEL_DEV="siptunnel${TUNNEL_NO}"
	TUNNEL_MODE='ipip'					# gre

	TUNNEL_ENDPOINT_IP_REMOTE_LIST="10.63.26.129 10.63.154.193"

	TUNNEL_ENDPOINT_IP_REMOTE="$( _list_get_obj "$TUNNEL_ENDPOINT_IP_REMOTE_LIST" $TUNNEL_NO )" || return 1
	TUNNEL_ENDPOINT_IP_HERE="$( nvram get wifi_ipaddr )"

	TUNNEL_NET='192.168.6.0'
	TUNNEL_NET_MASK='24'

	TUNNEL_IP_REMOTE="$( echo $TUNNEL_NET | cut -d'.' -f1-3 ).$( _ip4_octet3 $TUNNEL_ENDPOINT_IP_REMOTE	)"
	TUNNEL_IP_HERE="$(   echo $TUNNEL_NET | cut -d'.' -f1-3 ).$( _ip4_octet3 $TUNNEL_ENDPOINT_IP_HERE	)"
}

_start ()
{
	local OBJ
	
	lsmod | grep -q ^ipip || insmod ipip.o		# ip_gre.o

	set -x

	_global_vars stop
	for OBJ in $TUNNEL_ENDPOINT_IP_REMOTE_LIST; do {
		ip tunnel  add $TUNNEL_DEV mode $TUNNEL_MODE remote $TUNNEL_ENDPOINT_IP_REMOTE local $TUNNEL_ENDPOINT_IP_HERE ttl 255
		ip address add $TUNNEL_IP_HERE/$TUNNEL_NET_MASK dev $TUNNEL_DEV
		ip link    set dev $TUNNEL_DEV up

		_global_vars
	} done

	set +x
}

_stop ()
{
	local OBJ
	
	_global_vars $1
	for OBJ in $TUNNEL_ENDPOINT_IP_REMOTE_LIST; do {
		ip address del $TUNNEL_IP_HERE/$TUNNEL_NET_MASK dev $TUNNEL_DEV
		ip link    set dev $TUNNEL_DEV down
		ip tunnel  del $TUNNEL_DEV

		_global_vars
	} done
}

_restart ()
{
	_stop
	_start
}

case $1 in
	start|stop|restart) _$1 ;;
			 *) _usage ;;
esac
