#!/bin/sh

# wget -qO /dev/null "http://127.0.0.1/cgi-bin-rrd1.html?START=end-24h"		# stats,wifi (signal/noise,rate,olsr-traffic)
# scp /tmp/rrd/img/end-24hWLAN_WLA_STATS.png intercity-vpn.de:/var/www/99.png

. /etc/functions_base_fff+ && func_need log

func_watch_hanging_command ()
{
	local COMMAND="$1"						# e.g. 'wget' or 'scp'
	local FUNC="watch_hanging_command"
	local COMMAND_PID="$( pidof -s $COMMAND )"			# any running process?
	
	[ -z "$COMMAND_PID" ] && {
		func_log $FUNC daemon debug "no running '$COMMAND'-process"
		return 0
	}
	
	local COMMAND_CMD="$( cat /proc/$COMMAND_PID/cmdline )"		# remember exact commandline
	local OLD_PID
	local OLD_CMD
	local FILE1="/tmp/maybe_hanging_${COMMAND}_process_id"
	local FILE2="/tmp/maybe_hanging_${COMMAND}_process_cmd"

	[ -e "$FILE1" ] && OLD_PID="$( cat $FILE1 )"
	[ -e "$FILE2" ] && OLD_CMD="$( cat $FILE2 )"

	func_log $FUNC daemon debug "found '$COMMAND'-process '$COMMAND_PID' / '$COMMAND_CMD'"

	if [ "$OLD_PID" = "$COMMAND_PID" ] && [ "$OLD_CMD" = "$COMMAND_CMD" ]; then

		func_log $FUNC daemon err "killing '$COMMAND_CMD'"
		kill $COMMAND_PID
		sleep 3
		
		[ -e "/proc/$COMMAND_PID" ] && {
			func_log $FUNC daemon crit "still hanging, killing hard"
			kill -9 $COMMAND_PID
			sleep 3
		
			[ -e "/proc/$COMMAND_PID" ] && {
				func_safe_reboot "$FUNC() still hanging '$COMMAND'"
				return
			}
		}
			
		func_log $FUNC daemon info "successfully killed"
		return
	fi

	func_log $FUNC daemon debug "remember for next check '$COMMAND_PID' / '$COMMAND_CMD'"
	echo >$FILE1 "$COMMAND_PID"
	echo >$FILE2 "$COMMAND_CMD"
}

[ "$1" = "watch_hanging_command" ] && {
	func_watch_hanging_command wget
	func_watch_hanging_command scp
	exit
}

func_watch_hanging_netcat ()
{
	local FUNC="watch_hanging_netcat"
	local PID="$( pidof nc )"
	local OLD="/tmp/maybe_hanging_netcat_process_id"
	
	if [ -z "$PID" ]; then
		[ -e "$OLD" ] && rm $OLD
		return
	else
		if [ -e "$OLD" ]; then
			[ "$PID" = "$( cat "$OLD" )" ] && {
				func_log $FUNC daemon err "killing '$PID'"
				kill "$PID"
				rm "$OLD"
			}
		else
			echo "$PID" >"$OLD"
		fi
	fi
}

func_watch_hanging_netcat

func_need vars_old olsr wifi netparam

if [ "$(func_wifi_get_mode $WIFIDEV )" = "adhoc" ]; then	# fixme! lowering tx-power if NLQ ~ 1.000 ?
								# fixme! also make this, if olsr-neighs (in ap or client-mode)
	  if ! func_wifi_phy_probe_online $WIFIDEV ; then	# maybe its switched off by admin
	
		func_log meshmode_but_no_wifi_neighs daemon debug "radio is off, no further tests"
		continue	
	
	elif [ "$(func_uptime min)" -lt 5 ]; then		# olsrd needs some time
	
		func_log meshmode_but_no_wifi_neighs daemon debug "uptime <5 min, no further tests"
		continue
	
	elif neigh check4wifi ; then
		func_log meshmode_but_no_wifi_neighs daemon debug "found wifi-neigh"	

		if [ -n "$( nvram get fff_optimize_neigh )"; then				# fixme! we must detect interface for neigh,
												#        to tune the correct antenna
			BEST_WIFI_NLQ="$( neigh get_nlq $(nvram get fff_optimize_neigh) )"
		else
			BEST_WIFI_NLQ="$( neigh best_wifi_nlq )"				# fixme! maybe check 'my' wifi_gateway?
		fi										#        and check if I'am a wifi_gateway?

		BEST_WIFI_NLQ_LAST="$( cat /tmp/BEST_WIFI_NLQ_LAST 2>/dev/null )"
		echo "$BEST_WIFI_NLQ" >/tmp/BEST_WIFI_NLQ_LAST
		[ -z "$BEST_WIFI_NLQ_LAST" ] && BEST_WIFI_NLQ_LAST="$BEST_WIFI_NLQ"
		
		if [ "$BEST_WIFI_NLQ" -gt 500 ]; then
	 		func_log meshmode_but_no_wifi_neighs daemon debug "found at least one wifi-neigh with reasonable NLQ ($BEST_WIFI_NLQ > 500)"

			func_wifi_set_txpwr "$WIFIDEV" 5 mW subtract limit
		else
			func_log meshmode_but_no_wifi_neighs daemon debug "NOT found at least one wifi-neigh with reasonable NLQ (found '$BEST_WIFI_NLQ')"

			if [ "$BEST_WIFI_NLQ" -le "$BEST_WIFI_NLQ_LAST" ]; then		# fixme! use hysteresis
				func_wifi_set_txpwr "$WIFIDEV" 5 mW add overturn
			else
				func_wifi_set_txpwr "$WIFIDEV" 5 mW subtract limit
			fi
		fi									# fixme! add aftercheck + alert.log when successful
		
		echo "0" >/tmp/wifi_error_counter
	else
		[ "$( func_wifi_get_bssid $WIFIDEV )" != "$( func_wifi_get_bssid $WIFIDEV config )" ] && {	# fixme! empty config bssid?
			func_log meshmode_but_no_wifi_neighs daemon alert "BSSID error: '$( func_wifi_get_bssid $WIFIDEV )'/'$( func_wifi_get_bssid $WIFIDEV config )'"
			func_wifi_restart_phy $WIFIDEV
		}
		
		# fixme! sensitivity does not work on madwifi
		if [ "$( func_wifi_get_noise $WIFIDEV )" -gt -85 ]; then		# [dBm] e.g. -75 is greater than -85
		
			[ "$( func_wifi_get_sensitivity $WIFIDEV short )" != "1" ] && {
				func_wifi_set_sensitivity $WIFIDEV nonwifi
			}
		else									# switch back, if conditions are normal again
			[ "$( func_wifi_get_sensitivity $WIFIDEV mode )" != "wifi,auto" ] && {
				func_wifi_set_sensitivity $WIFIDEV auto	
			}
		fi
	
		COUNT="$( cat /tmp/wifi_error_counter 2>/dev/null )"
		COUNT="$(( ${COUNT:=0} + 1 ))"
	
		func_log meshmode_but_no_wifi_neighs daemon info "raising counter to ${COUNT}/15"
		
		[ $COUNT -gt 15 ] && {
			func_safe_reboot "meshmode - but no wifi neigh for a long time (counter: '${COUNT}')"	# 15 * 15 mins = 4 hours
		}
		
		echo $COUNT >/tmp/wifi_error_counter
		
		func_wifi_set_txpwr "$WIFIDEV" 5 mW add overturn	# fixme! add aftercheck + alert.log when successful
		
		/usr/sbin/cron.select_best_antenna_fff+ force
	fi
else							# master or client-mode
	[ "$(func_uptime min)" -gt 5 ] && {

		if neigh check4nonwifi ; then		# fixme! check for zero bssid!

			func_log no_meshmode_and_no_neighs daemon debug "found wired neigh"
			echo "0" >/tmp/wifi_error_counter
		else
			  if ! func_wifi_phy_probe_online $WIFIDEV ; then
			
				func_log no_meshmode_and_no_neighs daemon debug "wifi is switched off by admin"
			
			elif neigh check4wifi ; then
		
				func_log no_meshmode_and_no_neighs daemon debug "found wifi neigh"
				echo "0" >/tmp/wifi_error_counter
			else
				[ "$(func_wifi_get_bssid $WIFIDEV)" = "00:00:00:00:00:00" ] && {
					func_log no_meshmode_and_no_neighs daemon alert "zero bssid: 'func_wifi_get_bssid $WIFIDEV'"
					func_wifi_restart_phy $WIFIDEV
				}
				
				if [ "$(fkt_check_if_this_node_offers_inet)" != "false" ]; then
				
					func_log no_meshmode_and_no_neighs daemon debug "no wifi-neighs, but local inet offer"
					echo "0" >/tmp/wifi_error_counter
				else
					COUNT="$( cat /tmp/wifi_error_counter 2>/dev/null )"
					COUNT="$(( ${COUNT:=0} + 1 ))"
					
					func_log no_meshmode_and_no_neighs daemon info "raising counter to ${COUNT}/15"
					
					[ $COUNT -gt 15 ] && {
						func_safe_reboot "no meshmode - and no wired nor wifi neigh for a long time (counter: '${COUNT}')"
					}
					
					echo $COUNT >/tmp/wifi_error_counter
				fi
			fi
		fi
	}
fi

func_olsr_plausi_check $(func_olsr_get_neighbours) || /etc/init.d/S53olsrd restart

# fixme!
	# random node-IP in mesh with 1 hop or 2 hops -> IP = main-interface
	# [ ! -e contact_$IP ] || [ "$(cat contact_${IP}_fetched)" -lt $(( $(date +%s) - 86400 )) ] && {
	# 	wget -qO - http://$IP/cgi-bin-contact.html | sed -n '/<H1>Kontakt<\/H1>/,$p'| sed '/^<\/TABLE>/q' >/tmp/node_$IP
	#
	#	[ "$( md5sum /tmp/node_$IP | cut -d' ' -f1 )" = "c9614a47d313e7be6f6cf2a7b88d5d2b" ]; then
	#		echo "empty"
	#	}
	# }			# ~ 800 Bytes if all fields are set

# fixme! Idee:
	# eintrag in everlog, wenn im WLAN-Scan ein extrem starker Router auftaucht,
	# muss man "unterdruecken" koennen, damit das nicht staendig kommt, wenn man nicht die
	# gewalt ueber den stoerer hat.

# fixme! Idee:
	# nice oder renice (fuer bestimmte code-abschnitte)

PID="$(pidof vpnc)" && {
	func_log vpnc_helper daemon info "petting PID '$PID' - fixme!"
	# kill -SIGHUP "$PID"		# fixme! (howto reconnect?)
}


func_set_time_with_ntp_server ()	# SENS: setting time, so each node is nearly in sync with hole network
{
	local FUNC="set_time_with_ntp-server"	
	local POOL="$( nvram get fff_timeserver ) 128.138.140.44 171.64.7.77 171.64.7.99 81.169.154.44"
	local   IP
	local  TRY="0"
	local  UP1="$( func_uptime sec )"
	local  UP2=0
	local HOST
	local FILE_SUCCESS="/tmp/ntp_was_successful"

	[ -e $FILE_SUCCESS ] && {
		UP2="$( cat $FILE_SUCCESS )"
		UP2="$(( $UP1 - ${UP2:-0} ))"
		[ $UP2 -lt 3600 ] && {
			func_log $FUNC daemon info "last successful ntp-fetch was only $UP2 seconds before, aborting"
			return 0
		}
	}
	touch $FILE_SUCCESS			# prevents double-execution
	
	func_log $FUNC daemon info "start"

	while [ $TRY -lt 5 ]; do {
		TRY=$(( $TRY + 1 ))
	
		local ID="0"
		for IP in $POOL; do {
		
			ID=$(( $ID + 1 ))		
			sleep 5
			rdate -s $IP >/dev/null 2>&1 && {

				UP2="$( func_uptime sec )"			
				HOST="$( func_ip2dns $IP )"
				func_log $FUNC daemon debug "success after $(( $UP2 - $UP1 )) seconds and ${TRY}. round on ${ID}. IP in pool (${IP} = $HOST)"
				TRY=9
				[ "$( func_filesize "$FILE_SUCCESS" )" -eq 0 ] && {
					func_log $FUNC daemon alert "first successful set after reboot"
				}
				echo $UP2 >$FILE_SUCCESS
				break				# fixme! calc + log diff before/after timesetting in sec?
			}
		} done
	} done

	[ "$TRY" != "9" ] && {
		func_log $FUNC daemon info "end without success"
		rm $FILE_SUCCESS
	}
}

### fresh booted (<300sec up) and no wifi? switch on!

[ "$( func_uptime sec )" -lt 300 ] && {

	[ "$( nvram get wl0_radio )" = "0" ] && {
		func_log "force_wifi_on" daemon info "working"
		nvram set wl0_radio=1
		wifi
	}
}

### reboot-command is lost/deleted/bad (ipkg login-utils)
[ ! -e /sbin/reboot ] && {
	func_log command_reboot_faulty daemon crit "symlinking to /rom/sbin/reboot"
	ln -s /rom/sbin/reboot /sbin/reboot
}

### same routers lost the 'date'/'busybox-coreutils'-package, correct this:

[ -z "$( date 2>/dev/null )" ] && {
	func_log command_date_faulty daemon crit "symlinking to busybox"
	rm /bin/date
	ln -s busybox /bin/date
	func_log command_date_faulty daemon crit "date output now: '$(date)'"
}

### firmware-build-date is newer than unixtime? -> set time

[ "$(( ${FFF_PLUS_VERSION:=340529} * 3600 ))" -gt "$(date +%s)" ] && {		# 340529 = 2008'november
	func_set_time_with_ntp_server

	[ "$(( ${FFF_PLUS_VERSION:=340529} * 3600 ))" -gt "$(date +%s)" ] && {
		func_log set_time daemon info "could'nt set time - trying poor mens timeserver - fixme!"
		# /www/cgi-bin-speed t		# fixme!
	}
}


### under unclear circumstances the "wifi"-program segfaults and there
### are after some time hanging 'wifi'-processes...

[ "$( func_count_pids wifi )" -gt 1 ] && {

	sleep 10
	
	[ "$( func_count_pids wifi )" -gt 1 ] && {
		func_safe_reboot "strange_wifi() several wifi-PIDs!"
	}
}

[ "$( func_count_pids xrelayd )" -gt 1 ] && {		# can be the case, after too many simultaneously https-connections
	
	func_log watch_xrelayd daemon info "trying to end some processes and restart daemon"
	killall xrelayd
	sleep 10
	
	if [ "$( func_count_pids xrelayd )" -gt 1 ]; then
	
		func_log watch_xrelayd daemon info "still some processes around"
	
		for PID in $(pidof xrelayd); do {
			kill -9 $PID
		} done
	
		if [ "$( func_count_pids xrelayd )" -gt 1 ]; then
			func_safe_reboot "can't end some xrelayd-processes"
		else
			/etc/init.d/S70secureadmin start
		fi
	else
		/etc/init.d/S70secureadmin start
	fi
}

touch /tmp/rrd_plausi_check					# needs some test
for FILE in $(find /tmp/rrd -name *.rrd 2>/dev/null); do {
	[ /tmp/rrd_plausi_check -ot $FILE ] && {
		func_log rrd_plausi_check daemon alert "rrd-file is in future - reinit for '$FILE'"
		touch "$FILE"
	}
} done


[ "$( ps | sed -n 's/^[^Z]*\(Z\)[^Z]*\[.*\].*/\1/p' | wc -l )" -gt 50 ] && {
	func_safe_reboot "more than 50 zombie processes!"
}

### sending "i'am alive"-messages to vpn-server in random
### intervals (approx. once a day) or/and simply log it

ARG1="$1"
ARG2="$2"

test   -e "/tmp/LOWMEM"			&& ARG1=fast
test   -n "$FAILSAFE" 			&& ARG1=fast
test ! -e "$SOFTWARE_FULLY_INSTALLED"	&& ARG1=fast

[ "$ARG1" = "fast" ] && func_log "fastmode" daemon debug "no mesh-rdf-data-collection"

if [ "$ARG1" != "fast" ] && [ -n "$( nvram get fff_node_number )" ]; then	# node must be configured

	func_log mesh_rdf daemon debug "start"

	# fixme! use more abstraction

	# this parts takes
	# about 30 seconds!
	# needs more optimizing!
					# keyword 'fast' means not to collect any data, which is faster
					# tip: it is useful that neighbour-infos must be "in sync" with other nodes
					#      which means: take this neighbour-snapshot at exactly the same time
					#                   in hole network
	
	func_need old log pfilter profile_user
	
	TIME="$( date +%s )"
	
# takes long!
	func_log mesh_rdf_build_neighs daemon debug "start"
	NEIGH="$( func_url_encode "$(neigh meshrdf)" )"		# -335:10.63.167.97:10.63.80.97:LC:1.000:1.000:1.000:1...

# takes long!
	func_log mesh_rdf_build_users daemon debug "start"
	USERS="$( func_url_encode "$(func_get_all_user_macs_with_traffic_today)" )"	# -001122334455:500~112233445566:9888
	
	FORWARDED="$( IPT=iptables ; fkt_convert_to_unit $(fkt_get_traffic_forward_alien) mb )"
	
	UPTIME="$(( $(cut -d"." -f1 /proc/uptime) / 3600 ))"		# in hours				# 1078
	CPU_LOAD="$( sed 's/^[0-9]*\.[0-9]* [0-9]*\.[0-9]* \([0-9]*\)\.\([0-9]*\).*/\1\2/' /proc/loadavg )"	# 088
	VERSION=$FFF_PLUS_VERSION										# 345678
	REBOOT="$( cat $REBOOT_COUNT )"										# 15
	NODE="$( nvram get fff_node_number )"									# 423

	func_need vars

	OLSRVER="$( func_url_encode "$OLSR_VERSION" )"				# pre-0.5.6-r4 2009-01-02 12:00:45 on pcnet
	WIFIDEV="$WIFI_DEVS"		# fixme!								# eth1
														# 001122334455
	WIFIMAC="$( ip link show dev $WIFIDEV | sed -n 's/^.*link\/ether \(..\):\(..\):\(..\):\(..\):\(..\):\(..\) brd.*/\1\2\3\4\5\6/p' )"
	UPDATE="$( nvram get fff_autofwupdate )"; test -z "$UPDATE" && UPDATE=stable			# testing
	LATLON="$( nvram get ff_adm_latlon | sed -e 's/[^0-9\;,\.]//g' -e 's/\;/,/g' )"				# 50.1234,11.3345
		if [ "," = "$LATLON" ] || [ -z "$LATLON" ]; then
			LATLON="0,0"
		fi
		LATLON="$( func_url_encode $LATLON )"
	
	ADMINEMAIL="$( nvram get ff_adm_mail  | sed 's/[^0-9a-zA-Z@\._-]//g' )"		# bla@blubb.de
	ADMINEMAIL="$( func_url_encode $ADMINEMAIL )"

	ADMINPHONE="$( nvram get ff_adm_tel   | sed 's/[^0-9a-zA-Z]//g' )"		# 036435101112zuhause
	HOSTNAME="$(   nvram get wan_hostname | sed 's/[^0-9a-zA-Z-]//g' )"		# Windmuehlen12

	TXPWR="$(	func_wifi_get_txpwr	  $WIFIDEV mw )"	# 40
	FRAG="$(	func_wifi_get_frag	  $WIFIDEV )"		# 500
	RTS="$(		func_wifi_get_rts	  $WIFIDEV )"		# 2347
	GMODEPROT="$(	func_wifi_get_protection  $WIFIDEV )"		# 0 or 1
	WIFIMODE="$(	func_wifi_get_mode	  $WIFIDEV )"		# adhoc
	NOISE="$(	func_wifi_get_noise	  $WIFIDEV )"		# -94
	SIGNAL="$(	func_wifi_get_signal	  $WIFIDEV )"
	CHANNEL="$(	func_wifi_get_channel	  $WIFIDEV )"		# 104
	MRATE="$(	func_wifi_get_mrate	  $WIFIDEV )"		# 5.5
	SENS="$(	func_wifi_get_sensitivity $WIFIDEV )"		# 1,wifi,auto | 3/3
	SENS="$( func_url_encode "$SENS" )"
	
	DRIVER="$(	func_wifi_get_driver_version $WIFIDEV )"	# wl-adv_3.90-RC37.0_v1.1
	DRIVER="$( func_url_encode "$DRIVER" )" 			# wl-simple_v1.0 
									# mod-madwifi_2.4.30brcm+r3314-8

	GMODE="$( nvram get wl0_gmode )"	# fixme!

	ESSID="$( func_url_encode "$(nvram get wl0_ssid)" )"
	BSSID="$( nvram get ff_bssid )"

	eval $( /etc/init.d/S02check_interface_correctness_fff+ show_hardware )
	HW="$( echo $HW | sed -e 's/ /_/g' -e 's/[^_a-zA-Z0-9-]//g' )"			# Buffalo_WHR-HP-G54_BCM4318-wifi

	# "$SSH_PUBKEY_FP"								# 1660559e90efefafd04298c516365bbd12b0ffda
											# (40 bytes HEX [SHA-1])
	FREE_SPACE_FLASH="$( func_system_flash_free )"			# [kByte]
	FREE_SPACE_USB="$(df | grep "/mnt/disc0_." | sed -n "s/^[0-9a-zA-Z\/]*[^0-9]*[0-9]*[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p")"	# fixme! more abstraction!
	[ -n "$FREE_SPACE_USB" ] && FREE_SPACE_USB="$(( $FREE_SPACE_USB / 1024 ))"
	SERVICE_FREE_SPACE="$(( $FREE_SPACE_FLASH + ${FREE_SPACE_USB:=0} ))"
	SERVICES="${SERVICE_FREE_SPACE}kb"						# fixme! how to describe webcams?
											# or SSHd or HTTPd?
											# or Templogger/Sensorstuff?
	
	[ $FREE_SPACE_FLASH -lt 150 ] && {
		[ ! -e /tmp/REPO_REMOVED ] && {
			func_log remove_repos_if_low_space daemon alert "only $FREE_SPACE_FLASH kb free - removing files in /usr/lib/ipkg/lists/"
			rm -f /usr/lib/ipkg/lists/*			# to avoid possible problems (gives +100k)
			touch /tmp/REPO_REMOVED
		}
		
		[ ! -e /tmp/SEND_ALIVE_FAILED ] && {
			rm /www/everlasting_syslog.txt		# content is already on server
		}
	}
	
	# fixme! we need a global sanitizer ("email","ip","hostname","url","number","hex","upper","lower")
	
	eval "$( func_ipsystem | grep ^FFF_CITY )"
	
	PUBIP="$( fkt_wget http://$( nvram get fff_server_vpn_dns )/show_remote_address.php 10 | sed 's/[^0-9\.]//g' )"	# 217.212.17.148
	
	# fixme! func_need gwcheck
	# GWCHECK=1; T=1243685931; DATE=30May2009-14uhr18; GW=10.63.3.1; HOSTNAME=KG-bittorfwireless-AP;
	# NEXTHOP=10.63.3.1; METRIC=0; ETX=1.00; COST=1.00; COST_INT=0
	# user better vars: GWCHECK_TIME= GWCHECK_COST_INT= ...
	
	[ -r "$TRACE_INET_GATEWAY" ] && {
		HOP2GW="$( tail -n1 $TRACE_INET_GATEWAY | sed -n 's/.* METRIC=\([0-9\.]*\).*/\1/p' )"		# 5
		ETX2GW="$( tail -n1 $TRACE_INET_GATEWAY | sed -n 's/.* ETX=\([0-9\.]*\).*/\1/p' )"		# 5.234
		GWNODE="$( tail -n1 $TRACE_INET_GATEWAY | sed -n 's/.* NEXTHOP=\([0-9\.]*\).*/\1/p' )"		# 10.63.144.65
			GWNODE="$( func_ipsystem $GWNODE )"
		GW="$( tail -n1 $TRACE_INET_GATEWAY | sed -n 's/.* GW=\([0-9\.]*\).*/\1/p' )"			# 10.63.144.65
			GW="$( func_ipsystem $GW )"								# 400
	}
	
	HOP2GW=${HOP2GW:=NULL}		# todo: ensure, that empty values are rewritten to 'NULL'
	ETX2GW=${ETX2GW:=NULL}
	GW=${GW:=NULL}

	# trying to print at first the values that are not likely to change its length/appearance often 
	# just to be better readable in logfile

	QUERY=""
	QUERY="${QUERY}local=$( date +%d%b%Y-%Huhr%M )&mail=$ADMINEMAIL&phone=$ADMINPHONE&time=$TIME&services=$SERVICES&pubkey=$SSH_PUBKEY_FP"
	QUERY="${QUERY}&node=$NODE&city=$FFF_CITY&mac=$WIFIMAC&latlon=$LATLON&hostname=$HOSTNAME&update=$UPDATE&wifidrv=$DRIVER&olsrver=$OLSRVER"
	QUERY="${QUERY}&txpwr=$TXPWR&wifimode=$WIFIMODE&channel=$CHANNEL&mrate=$MRATE&hw=$HW&frag=$FRAG&rts=$RTS"
	QUERY="${QUERY}&gmodeprot=${GMODEPROT:=0}&gmode=${GMODE:=0}&profile=$( nvram get fff_profile )&noise=${NOISE}&rssi=${SIGNAL}"
	QUERY="${QUERY}&version=$VERSION&reboot=$REBOOT&up=$UPTIME&load=$CPU_LOAD&forwarded=$FORWARDED&essid=${ESSID}&bssid=${BSSID}"
	QUERY="${QUERY}&gw=$GW&gwnode=$GWNODE&etx2gw=$ETX2GW&hop2gw=$HOP2GW&neigh=$NEIGH&users=$USERS&pubip=$PUBIP&sens=$SENS"
	
	echo >>"$ARCHIV_NODE_DATA" "$QUERY"
										# only last 150 lines ('ringbuffer')
	tail -n 150 "${ARCHIV_NODE_DATA}"     >"${ARCHIV_NODE_DATA}_temp"	# which is ~50 kilobytes and around
	mv          "${ARCHIV_NODE_DATA}_temp" "${ARCHIV_NODE_DATA}"		# 1.5 days archiv when called each 15 mins
	
	RANDOM=$(dd if=/dev/urandom bs=2 count=1 2>&-|hexdump|if read line;then echo 0x${line#* };fi)
	[ "$(( $RANDOM % 70 ))" -eq 1 ] && ARG1="send_alive_message"					# roundabout each day
	[ -e /tmp/SEND_ALIVE_FAILED ] && {
		rm /tmp/SEND_ALIVE_FAILED
		ARG1="send_alive_message"
		ARG2="no_antenna_test"
	}

	func_log mesh_rdf daemon debug "ready"
	
	KEEP_ALIVE_URL="$( nvram get fff_url_network )/meshrdf/"
	
	if [ -n "$KEEP_ALIVE_URL" ] && [ "$ARG1" = "send_alive_message" ]; then
	
		[ -z "$ARG2" ] && fkt_sleep_random_seconds_but_max 60

		func_log mesh_rdf_send_alive daemon info "sending message to vpn-server: '${KEEP_ALIVE_URL} [...]'"

		func_set_time_with_ntp_server

		[ -e /www/backup_archiv_node_data ] && {			# see func_safe_reboot()
		
			func_log mesh_rdf_send_alive daemon info "found node-data backup, including"
			
			mv "${ARCHIV_NODE_DATA}" "${ARCHIV_NODE_DATA}.temp"	# copy backup-file
			mv /www/backup_archiv_node_data "${ARCHIV_NODE_DATA}"	# on top of
			cat "${ARCHIV_NODE_DATA}.temp" >>"${ARCHIV_NODE_DATA}"	# normal node_data_file
			rm  "${ARCHIV_NODE_DATA}.temp"				# and remove backup
		}

		# look for last comment "# alive was send..." in our archive
		# and try to send all lines from this point to end of file
		# to the logging server. After this we set the comment at file-end

		LINENUMBER_LAST_SUCCESS="$( grep -n "^#" "${ARCHIV_NODE_DATA}" | tail -n1 | cut -d':' -f1 )"	# last comment

		while true; do {							# start one line after last comment
			LINENUMBER_LAST_SUCCESS=$(( $LINENUMBER_LAST_SUCCESS + 1 ))	# worst case is line one

		 	QUERY="$( sed "${LINENUMBER_LAST_SUCCESS}q;d" "${ARCHIV_NODE_DATA}" )"		# must be url-encoded
 
 			if [ -n "$QUERY" ]; then
 		
 				echo "$QUERY" | grep -q ^"lo" && {		# dont send trash/comments; "lo" means local='...' or log='...'
 
 					echo "$QUERY" | grep -q ^"log=" && {
 						func_log mesh_rdf_send_alive daemon debug "send log-message"
 						QUERY="${QUERY}&hostname=$HOSTNAME&mac=$WIFIMAC"
 					}
 			
 					OUT="$( fkt_wget "${KEEP_ALIVE_URL}?${QUERY}" 10 )"
 					func_log mesh_rdf_send_alive daemon debug "send alive-line: $LINENUMBER_LAST_SUCCESS - $OUT"
 					
 					[ "$OUT" != "OK" ] && {
 						func_log mesh_rdf_send_alive daemon info "send alive-line: something went wrong at line '$LINENUMBER_LAST_SUCCESS' - ending"
 						touch /tmp/SEND_ALIVE_FAILED
 						break				# fixme! set comment ("marker") after last sent line
 					}
 				}
 			else
 				func_log mesh_rdf_send_alive daemon debug "send alive normally ended"
 				echo >>"${ARCHIV_NODE_DATA}" "# alive-message was send (normal exit...)"
 				break
 			fi
		} done

		# fixme! [ inet_offer ] && upload_1mb -> upstream + download_5mb -> downstream
		#
		# echo "POST /index.php HTTP/1.1"
		# echo "Host: intercity-vpn.de"
		# echo "Content-Type: application/x-www-form-urlencoded"
		# echo "Content-Length: 1048576"
		# echo
		#
		# dd if=/dev/zero bs=64k count=16 2>/dev/null
		#
		# | nc intercity-vpn.de 80 >/dev/null
		# wget -qO /dev/null "http://intercity-vpn.de/testdata.bin"	// 5mb

		[ "$ARG2" != "no_antenna_test" ] && {
			func_log enforce_antenna_test daemon info "starting up"		# fixme! maybe there is a better place for	
			/usr/sbin/cron.select_best_antenna_fff+ force			# regular but random execution of this script
		
			[ "$(func_system_flash_free)" -gt 125 ] && {
				func_log update_adblock_filter daemon info "working"

#				ipkg update				
#				ipkg install fff-adblock-list || {		# fixme! returncode is always '0'
#				
#					func_log update_adblock_filter daemon info "failed - trying direct link"
#					ipkg install "$(nvram get fff_url_network)/packages/fff-adblock-list_0.1.0_mipsel.ipk" || {
#						func_log update_adblock_filter daemon info "direct link failed"
#					}
#				}
			}
		}
	fi
fi


### check if DNS-resolution works:
								# only with existing dnsmasq and reachable internet-gateway

if [ -e /etc/init.d/*dnsmasq ] && [ -n "$(ip route list exact 0/0)" ]; then	
	
	pidof dnsmasq >/dev/null || {

		logger -p daemon.err "$0 (DNS-watchdog) restarting dnsmasq"

		pidof udhcpd >/dev/null && {			# otherwise the server-port cannot bound to new daemon
	
			logger -p daemon.err "$0 (DNS-watchdog) killing old DNS-server \"udhcpd\""
			killall udhcpd
		}
		
		/etc/init.d/S*dnsmasq start
		/etc/init.d/S46fake_dns_server_fff+ remove_fake_dnsserver
		sleep 3
		
		logger -p daemon.err "$0 (DNS-watchdog) restarted dnsmasq, PID now \"$( pidof dnsmasq )\""
	}
	
	nslookup "$(date +%s).weimarnetz.de" 2>/dev/null >/dev/null || {		# can we resolv a random address?

		logger -p daemon.err -t "$0" "error in dns-resolution, sending SIGHUP to DNSmasq"
		kill -SIGHUP $( pidof -s dnsmasq )
		sleep 5
	
		nslookup "$(date +%s).weimarnetz.de" 2>/dev/null >/dev/null || {        # again: can we resolv a random address?

			logger -p daemon.err -t "$0" "error in dns-resolution, restarting DNSmasq"
			/etc/init.d/S*dnsmasq restart
		}
	}
fi


### check if PPPoE is running if needed

if [ -e "$PPPOE" ] && [ -z "$( ip route list exact 0/0 dev ppp0 )" ]; then
	
	func_log pppoe_watchdog daemon err "no default route over ppp0 - restarting PPPoE"
	
	killall    pppoecd
	killall -9 pppoecd
	ifup wan
	sleep 15
	
	func_log pppoe_watchdog daemon err "restarted: '$( ip route list exact 0/0 dev ppp0 )'"
fi


### check webcam

[ -e /tmp/WEBCAM ] && {
	pidof motion >/dev/null || {
		func_log webcam_watchdog daemon alert "restarting webcam"
		/etc/init.d/S90webcam_fff+ restart
	}
}


### check webserver

pidof httpd >/dev/null || {

	if pidof crond >/dev/null ; then
		func_log httpd_watchdog daemon err "webserver is not running - restarting"
	
		/etc/init.d/S50httpd start
		sleep 5
	
		func_log httpd_watchdog daemon err "webserver PID now: '$( pidof httpd )'"
	else
		func_log httpd_watchdog daemon debug "no crond - no restart"		# crondog does it
	fi
}

### check ssh-server/telnet-server

pidof dropbear >/dev/null || {

	pidof telnetd >/dev/null || {
	
		func_log sshd_watchdog daemon err "dropbear nor telnetd not running - restarting"
		
		/etc/init.d/S*dropbear start
		if pidof dropbear >/dev/null; then
			
			func_log sshd_watchdog daemon info "dropbear PID now: '$( pidof dropbear )'"
		else
			if telnetd; then
			
				func_log sshd_watchdog daemon info "telnetd PID now: '$( pidof telnetd )'"
			else
				func_log sshd_watchdog daemon err "dropbear nor telnetd not startable?"
			fi
		fi
	}
}



### check if nodenumber/id is from random pool

func_need profile_user old

WIFIMAC="$( ip link show dev $WIFIDEV | sed -n 's/^.*link\/ether \(..\):\(..\):\(..\):\(..\):\(..\):\(..\) brd.*/\1\2\3\4\5\6/p' )"

URL="$(nvram get fff_url_network)/registrator/?WIFIMAC=${WIFIMAC}&SSHPUBKEYFP=${SSH_PUBKEY_FP}&SSHPUBKEY=$(nvram get ff_dsskey_pub)"

if func_ipsystem | grep -q ^"NODE_NUMBER_RANDOM=true" ; then
	func_log replace_random_nodeID daemon info "detected ID from random pool - registering official ID from '$URL'"
	
 	[ -n "$SSH_PUBKEY_FP" ] && ID="$( fkt_wget "$URL" 10 )"		# fixme! no ssh  -> no ssh_pubkey_fingerprint!
 									# fixme! no wifi -> no wifimac -> no registration?
 	func_ipsystem "${ID:-99999}" >/dev/null && {			# ipsystem() has a sanitizer built in, so don't worry 8-)
		func_need nvram
		func_nvset fff_node_number "$ID"
		/etc/init.d/S02check_interface_correctness_fff+ enforce_new_profile
	
		func_safe_reboot "replace_random_nodeID() now profile applied"
	}

	func_log replace_random_nodeID daemon info "ID not clean: '$ID' - aborting"
else
	if [ ! -e /tmp/REGISTRATED ] && [ "$(func_uptime min)" -gt 30 ]; then

		[ -n "$SSH_PUBKEY_FP" ] && {
			ID="$( fkt_wget "${URL}&NODE=${NODE}" 10 )"
			touch /tmp/REGISTRATED				# fixme! only one (un/successful) try each reboot?
		}

		if [ -n "$ID" ]; then
			func_log registrator_petting daemon info "answer was '$ID' (question was: '$URL')"	
		else
			func_log registrator_petting daemon info "no answer (service '$URL' not running?)"
		fi
	else
		[ -e /tmp/REGISTRATED ] && func_log registrator_petting daemon debug "is already lucky"
	fi
fi

