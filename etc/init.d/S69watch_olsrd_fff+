#!/bin/sh
. /tmp/loader

# wget -qO /dev/null "http://127.0.0.1/cgi-bin-rrd1.html?START=end-24h"		# stats,wifi (signal/noise,rate,olsr-traffic)
# scp /tmp/rrd/img/end-24hWLAN_WLA_STATS.png intercity-vpn.de:/var/www/99.png

[ "$1" = "watch_hanging_command" ] && {
	_watch hanging_command wget
	_watch hanging_command scp
	exit
}

_watch hanging_netcat

_watch wifi_mode || sleep 30		# lets settle down to see some neighs

if [ "$(_wifi mode $WIFIDEV )" = "adhoc" ] || neigh check4wifi ; then		# also make this, if olsr-neighs (in ap or client-mode)

	  if ! _wifi phy_probe_online $WIFIDEV ; then	# maybe its switched off by admin
	
		_log do meshmode_but_no_wifi_neighs daemon debug "radio is off, no further tests"
		continue	
	
	elif [ "$(_system uptime min)" -lt 5 ]; then		# olsrd needs some time
	
		_log do meshmode_but_no_wifi_neighs daemon debug "uptime <5 min, no further tests"
		continue
	
	elif neigh check4wifi ; then
		_log do meshmode_but_no_wifi_neighs daemon debug "found wifi-neigh"	

		OPTIMIGE_TARGET_NLQ="$( nvram get fff_optimize_nlq   )"		# 0...1000 (integer)
		OPTIMIZE_NEIGH="$(      nvram get fff_optimize_neigh )"		# IPv4, 'gateway' or <empty> = any
		
		# fixme! if NLQ of wifi_gateway is much worser than best_wifi_nlq, take automatically wifi_gateway
		
		[ "$OPTIMIZE_NEIGH" = "gateway" ] && {				# make sure, that we optimize a wifi-gateway
			if ip route list exact 0/0 | grep -q "dev $WIFIDEV" ; then
				OPTIMIZE_NEIGH="$( ip route list exact 0/0 | sed -n "s/^default via \(.*\) dev ${WIFIDEV}.*/\1/p" )"
			else
				OPTIMIZE_NEIGH=""
			fi
		}
		
		if [ -n "$OPTIMIZE_NEIGH" ]; then						# fixme! we must detect interface for neigh,
												#        to tune the correct antenna
			BEST_WIFI_NLQ="$( neigh get_nlq $OPTIMIZE_NEIGH )"
			_log do meshmode_but_no_wifi_neighs daemon debug "found wifi-neigh, optimizing for $OPTIMIZE_NEIGH, nlq_now: ${BEST_WIFI_NLQ:=0}"
			echo $OPTIMIZE_NEIGH >/tmp/WIFI_OPTIMIZE_NEIGH		# for RRD-tool
		else
			BEST_WIFI_NLQ="$( neigh best_wifi_nlq )"							# fixme! maybe check 'my' wifi_gateway?
			_log do meshmode_but_no_wifi_neighs daemon debug "found wifi-neigh, nlq_now: $BEST_WIFI_NLQ"	#	 and check if I'am a wifi_gateway?
		fi

		BEST_WIFI_NLQ_LAST="$( cat /tmp/BEST_WIFI_NLQ_LAST 2>/dev/null )"
		echo "${BEST_WIFI_NLQ:=0}" >/tmp/BEST_WIFI_NLQ_LAST
		[ -z "$BEST_WIFI_NLQ_LAST" ] && BEST_WIFI_NLQ_LAST="$BEST_WIFI_NLQ"
		
		TXPWR_STEP="5 mW"
		
		if [ "${BEST_WIFI_NLQ:=0}" -gt ${OPTIMIGE_TARGET_NLQ:=900} ]; then		# definition of default_target_nlq = 0.900
	 	
	 		# fixme! maybe take tx_power into account? (high_txpower -> always try to lower?)
	 	
	 		# e.g. 940-900 = 40 > 900 / 20 = 45 ? -> no_tx_power_change	// only do TX_POWER_CHANGE if DIFF greater than 5% (x/100*5 -> x/20)
	 		#      650-600 = 50 > 600 / 20 = 30 ? -> lowering_tx_power	// this is for absorbe "pulsing" tx_power
	 	
	 		if [ $(( $BEST_WIFI_NLQ - $OPTIMIGE_TARGET_NLQ )) -gt $(( $OPTIMIGE_TARGET_NLQ / 20 )) ]; then
	 			_log do meshmode_but_no_wifi_neighs daemon debug "found at least one wifi-neigh with reasonable NLQ: -$TXPWR_STEP ($BEST_WIFI_NLQ > $OPTIMIGE_TARGET_NLQ)"
				_wifi phy_txpower_set "$WIFIDEV" $TXPWR_STEP subtract limit
			else
				_log do meshmode_but_no_wifi_neighs daemon debug "found at least one wifi-neigh with reasonable NLQ, low diff, do nothing ($BEST_WIFI_NLQ > $OPTIMIGE_TARGET_NLQ)"
			fi
		else
			if [ "$BEST_WIFI_NLQ" -lt "$BEST_WIFI_NLQ_LAST" ]; then			# fixme! use hysteresis
	
				case "$( cat /tmp/WIFI_TREND_TXPOWER_${WIFIDEV} 2>/dev/null || echo '-' )" in
					"=")
						_log do meshmode_but_no_wifi_neighs daemon info "NLQ is'nt good enough, do nothing, last txpower-change was '='"
					;;
					"+")
						_log do meshmode_but_no_wifi_neighs daemon info "NLQ is'nt good enough ('$BEST_WIFI_NLQ' old was: '$BEST_WIFI_NLQ_LAST') and lower than in last round: -$TXPWR_STEP"
						_wifi phy_txpower_set "$WIFIDEV" $TXPWR_STEP subtract limit
					;;
					"-")
						_log do meshmode_but_no_wifi_neighs daemon info "NLQ is'nt good enough ('$BEST_WIFI_NLQ' old was: '$BEST_WIFI_NLQ_LAST') and lower than in last round: +$TXPWR_STEP (last txpower-change was '-')"
						_wifi phy_txpower_set "$WIFIDEV" $TXPWR_STEP add overturn
					;;
				esac
			else
				_log do meshmode_but_no_wifi_neighs daemon info "NLQ is'nt good enough ('$BEST_WIFI_NLQ' old was: '$BEST_WIFI_NLQ_LAST') but higher or equal than in last round: +$TXPWR_STEP"
				_wifi phy_txpower_set "$WIFIDEV" $TXPWR_STEP add overturn
			fi
		fi										# fixme! add aftercheck + alert.log when successful
		
		echo "0" >/tmp/wifi_error_counter
	else
		[ "$( _wifi bssid $WIFIDEV )" != "$( _wifi bssid $WIFIDEV config )" ] && {	# fixme! empty config bssid?
			_log do meshmode_but_no_wifi_neighs daemon alert "BSSID error: '$( _wifi bssid $WIFIDEV )'/'$( _wifi bssid $WIFIDEV config )'"
			_wifi phy_restart $WIFIDEV
		}
		
		# fixme! sensitivity does not work on madwifi
		if [ "$( _wifi noise $WIFIDEV )" -gt -85 ]; then		# [dBm] e.g. -75 is greater than -85
		
			[ "$( _wifi sensitivity $WIFIDEV short )" != "1" ] && {
				_wifi sensitivity_set $WIFIDEV nonwifi
			}
		else									# switch back, if conditions are normal again
			[ "$( _wifi sensitivity $WIFIDEV mode )" != "wifi,auto" ] && {
				_wifi sensitivity_set $WIFIDEV auto	
			}
		fi
	
		COUNT="$( cat /tmp/wifi_error_counter 2>/dev/null )"
		COUNT="$(( ${COUNT:=0} + 1 ))"
	
		_log do meshmode_but_no_wifi_neighs daemon info "raising counter to ${COUNT}/15"
		
		[ $COUNT -gt 15 ] && {
			_system reboot_safe "meshmode_but_no_wifi_neighs for a long time (counter: '${COUNT}')"	# 15 * 15 mins = 4 hours
		}
		
		echo $COUNT >/tmp/wifi_error_counter
		
		_wifi phy_txpower_set "$WIFIDEV" 10 mW add overturn	# fixme! add aftercheck + alert.log when successful
		
		/usr/sbin/cron.select_best_antenna_fff+ force
	fi
else							# master or client-mode
	[ "$(_system uptime min)" -gt 5 ] && {

		if neigh check4nonwifi ; then		# fixme! check for zero bssid!

			_log do no_meshmode_and_no_neighs daemon debug "found wired neigh"
			echo "0" >/tmp/wifi_error_counter
		else
			  if ! _wifi phy_probe_online $WIFIDEV ; then
			
				_log do no_meshmode_and_no_neighs daemon debug "wifi is switched off by admin"
			
			elif neigh check4wifi ; then
		
				_log do no_meshmode_and_no_neighs daemon debug "found wifi neigh"
				echo "0" >/tmp/wifi_error_counter
			else
				[ "$(_wifi bssid $WIFIDEV)" = "00:00:00:00:00:00" ] && {
					_log do no_meshmode_and_no_neighs daemon alert "zero bssid: '_wifi bssid $WIFIDEV'"
					_wifi phy_restart $WIFIDEV
				}
				
				if [ "$(_net local_inet_offer)" != "false" ]; then
				
					_log do no_meshmode_and_no_neighs daemon debug "no wifi-neighs, but local inet offer"
					echo "0" >/tmp/wifi_error_counter
				else
					COUNT="$( cat /tmp/wifi_error_counter 2>/dev/null )"
					COUNT="$(( ${COUNT:=0} + 1 ))"
					
					_log do no_meshmode_and_no_neighs daemon info "raising counter to ${COUNT}/15"
					
					[ $COUNT -gt 15 ] && {
						_system reboot_safe "no meshmode - and no wired nor wifi neigh for a long time (counter: '${COUNT}')"
					}
					
					echo $COUNT >/tmp/wifi_error_counter
				fi
			fi
		fi
	}
fi

_olsr check_plausi $( _olsr neighs ) || /etc/init.d/S53olsrd restart

	# idee:
	# random node-IP in mesh with 1 hop or 2 hops -> IP = main-interface
	# [ ! -e contact_$IP ] || [ "$(cat contact_${IP}_fetched)" -lt $(( $(_system date unixtime) - 86400 )) ] && {
	# 	wget -qO - http://$IP/cgi-bin-contact.html | sed -n '/<H1>Kontakt<\/H1>/,$p'| sed '/^<\/TABLE>/q' >/tmp/node_$IP
	#
	#	[ "$( md5sum /tmp/node_$IP | cut -d' ' -f1 )" = "c9614a47d313e7be6f6cf2a7b88d5d2b" ]; then
	#		echo "empty"
	#	}
	# }			# ~ 800 Bytes if all fields are set


_watch vpnc

### fresh booted (<300sec up) and no wifi? switch on!

[ "$( _system uptime sec )" -lt 300 ] && {

	[ "$( nvram get wl0_radio )" = "0" ] && {
		_log do "force_wifi_on" daemon info "working"
		nvram set wl0_radio=1
		wifi
	}
}

### firmware-build-date is newer than unixtime?
### firmware-build-date + 1 year is older than date? (yes, i have seen _many_ routers with date 2020/2037!) -> set time

NTP_TIME_OK=								# fallback 347681 = 2009'aug-30

[ "$(( ${FFF_PLUS_VERSION:=347681} * 3600 ))"            -gt "$(_system date unixtime)" ] && NTP_TIME_OK="false"
[ "$(( ${FFF_PLUS_VERSION:=347681} * 3600 + 135000000))" -lt "$(_system date unixtime)" ] && NTP_TIME_OK="false"
_ntp set is_unset					     && NTP_TIME_OK="false"

[ "$NTP_TIME_OK" = "false" ] && {
	_ntp set

	[ "$(( ${FFF_PLUS_VERSION:=340529} * 3600 ))" -gt "$(_system date unixtime)" ] && {
		_log do set_time daemon info "could'nt set time - trying poor mens timeserver - fixme!"
		# /www/cgi-bin-speed t		# fixme!
	}
}

_watch hanging_broadcom_wifi
_watch hanging_xrelayd
_watch rrd_integrity
_watch zombie_processes

### sending "i'am alive"-messages to vpn-server in random
### intervals (approx. once a day) or/and simply log it

ARG1="$1"
ARG2="$2"

test   -e "/tmp/LOWMEM"			&& ARG1=fast
test   -n "$FAILSAFE" 			&& ARG1=fast
test ! -e "/www/SOFTWARE_FULLY_INSTALLED"	&& ARG1=fast

[ "$ARG1" = "fast" ] && _log do "fastmode" daemon debug "no mesh-rdf-data-collection"

if [ "$ARG1" != "fast" ] && [ -n "$( nvram get fff_node_number )" ]; then	# node must be configured

	_log do mesh_rdf daemon debug "start"

	# fixme! use more abstraction

	# this parts takes
	# about 30 seconds!
	# needs more optimizing!
					# keyword 'fast' means not to collect any data, which is faster
					# tip: it is useful that neighbour-infos must be "in sync" with other nodes
					#      which means: take this neighbour-snapshot at exactly the same time
					#                   in hole network
	
	_needs old log pfilter profile_user sanitizer
	
	TIME="$( _system date unixtime )"
	
# takes long!
	_log do mesh_rdf_build_neighs daemon debug "start"
	NEIGH="$( _sanitizer do "$(neigh meshrdf)" urlvalue )"		# -335:10.63.167.97:10.63.80.97:LC:1.000:1.000:1.000:1...

# takes long!
	_log do mesh_rdf_build_users daemon debug "start"
	USERS="$( _sanitizer do "$(func_get_all_user_macs_with_traffic_today)" urlvalue )"	# -001122334455:500~112233445566:9888
	
	FORWARDED="$( IPT=iptables ; fkt_convert_to_unit $(fkt_get_traffic_forward_alien) mb )"
	
	UPTIME="$(( $(cut -d"." -f1 /proc/uptime) / 3600 ))"		# in hours				# 1078
	CPU_LOAD="$( sed 's/^[0-9]*\.[0-9]* [0-9]*\.[0-9]* \([0-9]*\)\.\([0-9]*\).*/\1\2/' /proc/loadavg )"	# 088
	VERSION=$FFF_PLUS_VERSION										# 345678
	REBOOT="$( cat /www/REBOOT_COUNTER )"										# 15
	NODE="$( nvram get fff_node_number )"									# 423

	func_need vars

	OLSRVER="$( _sanitizer do "$( _olsr version )" urlvalue )"			# pre-0.5.6-r4 2009-01-02 12:00:45 on pcnet
	WIFIDEV="$WIFI_DEVS"		# fixme!								# eth1
														# 001122334455
	WIFIMAC="$( _sanitizer do "$(ip link show dev $WIFIDEV)" mac hex lowercase )"
	
	UPDATE="$( nvram get fff_autofwupdate )"; test -z "$UPDATE" && UPDATE=stable			# testing
	LATLON="$( nvram get ff_adm_latlon | sed -e 's/[^0-9\;,\.]//g' -e 's/\;/,/g' )"				# 50.1234,11.3345
		if [ "," = "$LATLON" ] || [ -z "$LATLON" ]; then
			LATLON="0,0"
		fi
		LATLON="$( _sanitizer do $LATLON urlvalue )"
	
	ADMINEMAIL="$( _sanitizer do "$(nvram get ff_adm_mail)" email urlvalue )"		# bla@blubb.de

	ADMINPHONE="$( _sanitizer do "$(nvram get ff_adm_tel)" alphanum )"			# 036435101112zuhause
	HOSTNAME="$(   _system hostname_get )"							# Windmuehlen12

	TXPWR="$(	_wifi phy_txpower	  $WIFIDEV mw )"	# 40
	FRAG="$(	func_wifi_get_frag	  $WIFIDEV )"		# 500
	RTS="$(		func_wifi_get_rts	  $WIFIDEV )"		# 2347
	GMODEPROT="$(	_wifi protection_gmode  $WIFIDEV )"		# 0 or 1
	WIFIMODE="$(	func_wifi_get_mode	  $WIFIDEV )"		# adhoc
	DISTANCE="$(	_wifi timing_distance    $WIFIDEV )"		# 1500
	NOISE="$(	func_wifi_get_noise	  $WIFIDEV )"		# -94
	SIGNAL="$(	func_wifi_get_signal	  $WIFIDEV )"		# 001122334455-70:223344556677-40
	SIGNAL="$( _sanitizer do "$SIGNAL" urlvalue )"
	
	CHANNEL="$(	func_wifi_get_channel	  $WIFIDEV )"		# 104
	MRATE="$(	func_wifi_get_mrate	  $WIFIDEV )"		# 5.5
	
	SENS="$(	_wifi sensitivity $WIFIDEV )"		# 1,wifi,auto | 3/3
	SENS="$( _sanitizer do "$SENS" urlvalue )"
	
	DRIVER="$(	_wifi driver_version $WIFIDEV )"	# wl-adv_3.90-RC37.0_v1.1
	DRIVER="$( _sanitizer do "$DRIVER" urlvalue )" 			# wl-simple_v1.0 
									# mod-madwifi_2.4.30brcm+r3314-8

	GMODE="$( nvram get wl0_gmode )"	# fixme!

	ESSID="$( _sanitizer do "$(nvram get wl0_ssid)" urlvalue )"
	BSSID="$( _sanitizer do "$(_wifi bssid $WIFIDEV)" hex lowercase )"

	eval $( /etc/init.d/S02check_interface_correctness_fff+ show_hardware )
	HW="$( echo $HW | sed -e 's/ /_/g' -e 's/[^_a-zA-Z0-9-]//g' )"			# Buffalo_WHR-HP-G54_BCM4318-wifi

	SSH_PUBKEY_FP="$( _sanitizer do $(_ssh key_public_fingerprint_get) hex )"	# 1660559e90efefafd04298c516365bbd12b0ffda
											# (40 bytes HEX [SHA-1])
	FREE_SPACE_FLASH="$( _system flash_free )"
	SERVICES="flash.free.kb:${FREE_SPACE_FLASH}"					# [kByte]
	
	FREE_SPACE_USB="$( df | grep "/mnt/disc0_." | sed -n "s/^[0-9a-zA-Z\/]*[^0-9]*[0-9]*[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p" )"	# fixme! more abstraction!
	[ -n "$FREE_SPACE_USB" ] && {
		SERVICES="${SERVICES}|usbstorage.free.kb:$(( $FREE_SPACE_USB / 1024 ))"	# [kByte]	# howto determine IDE <-> USB.storage?
	}
	
#	FREE_SPACE_IDE="$( df | grep "/mnt/disc0_." | sed -n "s/^[0-9a-zA-Z\/]*[^0-9]*[0-9]*[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p" )"	# fixme!
#	[ -n "$FREE_SPACE_IDE" ] && {
#		SERVICES="${SERVICES}|idestorage.free.kb:$(( $FREE_SPACE_IDE / 1024 ))" # [kByte]
#	}
	
	SERVICES="$( _sanitizer do "$SERVICES" urlvalue )"
	
											# fixme! add: soundcard, webcam, sambashare, sensorstuff, inetoffer, ...
	_watch flash_free_space
	
	eval "$( func_ipsystem | grep ^FFF_CITY )"
	
	PUBIP="$( _wget do http://$( nvram get fff_server_vpn_dns )/show_remote_address.php 10 | sed 's/[^0-9\.]//g' )"		# 217.212.17.148
	
	# _needs gwcheck
	#
	# GWCHECK=1; T=1243685931; DATE=30May2009-14uhr18; GW=10.63.3.1; HOSTNAME=KG-bittorfwireless-AP;
	# NEXTHOP=10.63.3.1; METRIC=0; ETX=1.00; COST=1.00; COST_INT=0
	# user better vars: 
	#
	# GWCHECK_OVERALL_COST_INT="9876"
	# GWCHECK_OVERALL_METRIC="5"
	# GWCHECK_OVERALL_GATEWAY_IP4="10.63.5.1"
	# GWCHECK_OVERALL_GATEWAY_HOST="trierer65"	// really?
	# GWCHECK_NEXTHOP_COST_INT="2876"
	# GWCHECK_NEXTHOP_IP4="10.63.3.1"
	# GWCHECK_NEXTHOP_HOST="bruckner4"		// really?
	# GWCHECK_NEXTHOP_MEDIA="remote/localwifi|lan|wan|pppoe|lan|..."
	#
	# -> GWCHECK="value:value:value:value:value:value:value"

	[ ! -r "/tmp/ARCHIV_TRACEINET" ] && cron.check_inet_gw_fff+ >/dev/null
	
	HOP2GW="$( tail -n1 /tmp/ARCHIV_TRACEINET | sed -n 's/.* METRIC=\([0-9\.]*\).*/\1/p' )"		# 5
	ETX2GW="$( tail -n1 /tmp/ARCHIV_TRACEINET | sed -n 's/.* ETX=\([0-9\.]*\).*/\1/p' )"		# 5.234
	GWNODE="$( tail -n1 /tmp/ARCHIV_TRACEINET | sed -n 's/.* NEXTHOP=\([0-9\.]*\).*/\1/p' )"		# 10.63.144.65
		GWNODE="$( func_ipsystem $GWNODE )"
	GW="$( tail -n1 /tmp/ARCHIV_TRACEINET | sed -n 's/.* GW=\([0-9\.]*\).*/\1/p' )"			# 10.63.144.65
		GW="$( func_ipsystem $GW )"								# 400

	HOP2GW=${HOP2GW:=NULL}			# todo: ensure, that empty values are rewritten to 'NULL'
	ETX2GW=${ETX2GW:=NULL}
	GW=${GW:=NULL}

	case "$(date +%H)" in			# only at night
		01|02|03|04|05|06)
			WIFISCAN="$( _wifi scan $WIFIDEV )"
			WIFISCAN="$( _sanitizer do "$WIFISCAN" urlvalue )"
		;;
	esac

	# ----- fixme! start_of_ugly_packetfilter_monitoring

	PFILTER_NAT="$(			iptables -t nat    -nxvL | grep "\--" | sed -n '$=' )"
	PFILTER_FILTER="$(		iptables -t filter -nxvL | grep "\--" | sed -n '$=' )"
	PFILTER_MANGLE="$(		iptables -t mangle -nxvL | grep "\--" | sed -n '$=' )"
	PFILTER_MANGLE_REAL="${PFILTER_MANGLE:=0}"

	PFILTER_MANGLE_USER_REAL="$(    iptables -t mangle -nxvL traff_users | grep    traff_99:99:99:99:99:9 | sed -n '$=' )"
	PFILTER_MANGLE_USER_RESERVE="$( iptables -t mangle -nxvL traff_users | grep -v traff_99:99:99:99:99:9 | sed -n '$=' )"

	_meshrdf_count_user_real ()
	{
		local LIST="$( iptables -t mangle -nxvL | sed -n 's/^Chain traff_\(..:..:..:..:..:..\) .*/\1/p' | grep -v 99:99:99:99:99:9 )"
		local LOOP=
		local COUNT
		local MAC
		
		for MAC in $LIST; do {
			COUNT="$( iptables -t mangle -nxvL traff_$MAC | sed -n '$=' )"
			echo -n "${LOOP:+,}${COUNT:-0}"
			LOOP=1
		} done
		
		[ -z "$LOOP" ] && echo -n "0"
	}
	
	_meshrdf_count_user_reserve ()
	{
		local LIST="$( iptables -t mangle -nxvL | sed -n 's/^Chain traff_\(..:..:..:..:..:..\) .*/\1/p' | grep    99:99:99:99:99:9 )"
		local LOOP=
		local COUNT
		local MAC
		
		for MAC in $LIST; do {
			COUNT="$( iptables -t mangle -nxvL traff_$MAC | sed -n '$=' )"
			echo -n "${LOOP:+,}${COUNT:-0}"
			LOOP=1
		} done
		
		[ -z "$LOOP" ] && echo -n "0"
	}

	PFILTER="$(_meshrdf_count_user_real):$(_meshrdf_count_user_reserve)"

	IFS=",:"
	for COUNT in $PFILTER; do {
		PFILTER_MANGLE_REAL="$(( $PFILTER_MANGLE_REAL - ${COUNT:-0} ))"
	} done
	unset IFS

	PFILTER="${PFILTER_NAT:-0}:${PFILTER_FILTER:-0}:${PFILTER_MANGLE}:${PFILTER_MANGLE_REAL}:${PFILTER_MANGLE_USER_REAL:-0}:${PFILTER_MANGLE_USER_RESERVE:-0}:${PFILTER}"
	PFILTER="$( _sanitizer do "$PFILTER" urlvalue )"

	# ----- end_of_ugly_packetfilter_monitoring, output like: 7:39:600:97:10:12:49,49,49,49,49:13,49,49,49,49,49

	# trying to print at first the values that are not likely to change its length/appearance often 
	# just to be better readable in logfile

	DATE_LOCAL_HUMAN="$( date +%d%b%Y-%Huhr%M )"

	QUERY=""
	QUERY="${QUERY}local=$DATE_LOCAL_HUMAN&mail=$ADMINEMAIL&phone=$ADMINPHONE&time=$TIME&services=$SERVICES&pubkey=$SSH_PUBKEY_FP"
	QUERY="${QUERY}&node=$NODE&city=$FFF_CITY&mac=$WIFIMAC&latlon=$LATLON&hostname=$HOSTNAME&update=$UPDATE&wifidrv=$DRIVER&olsrver=$OLSRVER"
	QUERY="${QUERY}&olsrrestartcount=$( cat /tmp/olsr_restarts )&olsrrestarttime=$( cat /tmp/olsr_restart_time )"
	QUERY="${QUERY}&portfw=$( _sanitizer do "$(nvram get fff_portfw)" urlvalue )&optimizenlq=$( nvram get fff_optimize_nlq )&optimizeneigh=$( nvram get fff_optimize_neigh )"
	QUERY="${QUERY}&txpwr=$TXPWR&wifimode=$WIFIMODE&channel=$CHANNEL&mrate=$MRATE&hw=$HW&frag=$FRAG&rts=$RTS&pfilter=$PFILTER"
	QUERY="${QUERY}&gmodeprot=${GMODEPROT:=0}&gmode=${GMODE:=0}&profile=$( nvram get fff_profile )&noise=${NOISE}&rssi=${SIGNAL}&distance=${DISTANCE}"
	QUERY="${QUERY}&version=$VERSION&reboot=$REBOOT&up=$UPTIME&load=$CPU_LOAD&forwarded=$FORWARDED&essid=${ESSID}&bssid=${BSSID}"
	QUERY="${QUERY}&gw=$GW&gwnode=$GWNODE&etx2gw=$ETX2GW&hop2gw=$HOP2GW&neigh=$NEIGH&users=$USERS&pubip=$PUBIP&sens=$SENS&wifiscan=$WIFISCAN"
	
	echo >>/tmp/ARCHIV_MONITORING "$QUERY"
											# only last 150 lines ('ringbuffer')
	tail -n 150 "/tmp/ARCHIV_MONITORING"     >"/tmp/ARCHIV_MONITORING_temp"		# which is ~50 kilobytes and around
	mv          "/tmp/ARCHIV_MONITORING_temp" "/tmp/ARCHIV_MONITORING"		# 1.5 days archiv when called each 15 mins
	
	[ "$( _math random_integer 1 96 )" -eq 50 ] && ARG1="send_alive_message"	# roundabout each day (15min = 4/h * 24 = 96)
	[ -e /www/backup_archiv_node_data ] && ARG1="send_alive_message"
	[ -e /tmp/SEND_ALIVE_FAILED ] && {
		rm /tmp/SEND_ALIVE_FAILED
		ARG1="send_alive_message"
		ARG2="no_antenna_test"
	}

	_log do mesh_rdf daemon debug "ready"
	
	KEEP_ALIVE_URL="$( nvram get fff_url_network )/meshrdf/"

	[ "$UPTIME" -lt 2 ] && {
		ARG1="send_alive_message"
		ARG2="no_antenna_test"
	}
	
	if [ -n "$KEEP_ALIVE_URL" ] && [ "$ARG1" = "send_alive_message" ]; then
	
		[ -z "$ARG2" ] && sleep "$( _math random_integer 0 60 )"

		_log do mesh_rdf_send_alive daemon info "sending message: '${KEEP_ALIVE_URL} [...]'"

		_ntp set

		[ -e /www/backup_archiv_node_data ] && {			# see _system reboot_safe()
		
			_log do mesh_rdf_send_alive daemon info "found node-data backup, including"
			
			mv "/tmp/ARCHIV_MONITORING" "/tmp/ARCHIV_MONITORING.temp"	# copy backup-file
			mv /www/backup_archiv_node_data "/tmp/ARCHIV_MONITORING"	# on top of
			cat "/tmp/ARCHIV_MONITORING.temp" >>"/tmp/ARCHIV_MONITORING"	# normal node_data_file
			rm  "/tmp/ARCHIV_MONITORING.temp"				# and remove backup
		}

		# look for last comment "# alive was send..." in our archive
		# and try to send all lines from this point to end of file
		# to the logging server. After this we set the comment at file-end

		LINENUMBER_LAST_SUCCESS="$( grep -n "^#" "/tmp/ARCHIV_MONITORING" | tail -n1 | cut -d':' -f1 )"	# last comment

		while true; do {							# start one line after last comment
			LINENUMBER_LAST_SUCCESS=$(( $LINENUMBER_LAST_SUCCESS + 1 ))	# worst case is line one

		 	QUERY="$( sed "${LINENUMBER_LAST_SUCCESS}q;d" "/tmp/ARCHIV_MONITORING" )"		# must be url-encoded
 
 			if [ -n "$QUERY" ]; then
 		
 				echo "$QUERY" | grep -q ^"lo" && {		# dont send trash/comments; "lo" means local='...' or log='...'
 
 					echo "$QUERY" | grep -q ^"log=" && {
 						_log do mesh_rdf_send_alive daemon debug "send log-message"
 						QUERY="${QUERY}&hostname=$HOSTNAME&mac=$WIFIMAC"
 					}
 
 					QUERY="$( echo "$QUERY" | sed 's/:/%3a/g' )"	# fixme! only temporary
 			
 					OUT="$( _wget do "${KEEP_ALIVE_URL}?${QUERY}" 10 )"
 					_log do mesh_rdf_send_alive daemon debug "send alive-line: $LINENUMBER_LAST_SUCCESS - $OUT"
 					
 					[ "$OUT" != "OK" ] && {
 						_log do mesh_rdf_send_alive daemon info "send alive-line: something went wrong at line '$LINENUMBER_LAST_SUCCESS' - ending ('${KEEP_ALIVE_URL}?${QUERY}' -> '$OUT')"
 						touch /tmp/SEND_ALIVE_FAILED
 						break				# fixme! set comment ("marker") after last sent line
 					}
 				}
 			else
 				_log do mesh_rdf_send_alive daemon debug "send alive normally ended"
 				echo >>"/tmp/ARCHIV_MONITORING" "# alive-message was send @ $DATE_LOCAL_HUMAN (normal exit...)"
 				break
 			fi
		} done

		# fixme! [ inet_offer ] && upload_1mb -> upstream + download_5mb -> downstream
		#
		# echo "POST /index.php HTTP/1.1"
		# echo "Host: intercity-vpn.de"
		# echo "Content-Type: application/x-www-form-urlencoded"
		# echo "Content-Length: 1048576"
		# echo
		#
		# dd if=/dev/zero bs=64k count=16 2>/dev/null
		#
		# | nc intercity-vpn.de 80 >/dev/null
		# wget -qO /dev/null "http://intercity-vpn.de/testdata.bin"	// 5mb

		[ "$ARG2" != "no_antenna_test" ] && {
			_log do enforce_antenna_test daemon info "starting up"		# fixme! maybe there is a better place for	
			/usr/sbin/cron.select_best_antenna_fff+ force			# regular but random execution of this script
		}
	fi
fi

_watch dns_resolution
_watch pppoe
_watch webcam
_watch webserver
_watch sshd_or_telnet
_watch random_node_id
