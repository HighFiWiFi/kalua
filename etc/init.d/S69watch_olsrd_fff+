#!/bin/sh
. /tmp/loader

# wget -qO /dev/null "http://127.0.0.1/cgi-bin-rrd1.html?START=end-24h"		# stats,wifi (signal/noise,rate,olsr-traffic)
# scp /tmp/rrd/img/end-24hWLAN_WLA_STATS.png intercity-vpn.de:/var/www/99.png

# idee:
# random node-IP in mesh with 1 hop or 2 hops -> IP = main-interface
# [ ! -e contact_$IP ] || [ "$(cat contact_${IP}_fetched)" -lt $(( $(_system date unixtime) - 86400 )) ] && {
# 	wget -qO - http://$IP/cgi-bin-contact.html | sed -n '/<H1>Kontakt<\/H1>/,$p'| sed '/^<\/TABLE>/q' >/tmp/node_$IP
#
#	[ "$( md5sum /tmp/node_$IP | cut -d' ' -f1 )" = "c9614a47d313e7be6f6cf2a7b88d5d2b" ]; then
#		echo "empty"
#	}
# }			# ~ 800 Bytes if all fields are set

_watch flash_free_space

_watch wifi_mode || sleep 30		# lets settle down to see some neighs

_olsr check_plausi || _olsr daemon restart "plausi_check_failed"

_watch vpnc
_watch system_time
_watch hanging_broadcom_wifi
_watch hanging_xrelayd
_watch rrd_integrity
_watch zombie_processes
_watch dns_resolution
_watch pppoe
_watch netserver
_watch webcam
_watch webserver
_watch sshd_or_telnet
_watch random_node_id

update_needed()
{
	case "$( uci get system.@profile[0].name )" in
		 liszt28*) ;;
			*) return 1 ;;
	esac

	_uci is_oldstyle && {
		return 1
	}

	[ "$( _system version short )" -ge 27575 ] && {
		return 1
	}

	_net local_inet_offer >/dev/null && {
		return 1
	}

	[ "$( _software package_status kernel | grep ^Architecture: | cut -d' ' -f2 )" = "ar71xx" ] || {
		return 1
	}

	[ "$( _system uptime min )" -ge 30 ] || {
		return 1
	}

	return 0
}

fetch_firmware()
{
	local hash="hash=dd46a08fb252b79723f7a8456adf90e6"
	local source="http://intercity-vpn.de/firmware/ar71xx/images/testing/openwrt-ar71xx-generic-tl-wr1043nd-v1-squashfs-sysupgrade.bin"

	while [ "$( md5sum "/tmp/fw" | cut -d" " -f1 )" != "$hash" ]; do {
		_log do fetch_firmware daemon info "http_get $source"
		wget -qcO /tmp/fw "$source"
		sleep 1
		 _watch counter "/tmp/fetch_firmware" increment 1 max 100 || break
	} done

	if _watch counter "/tmp/fetch_firmware" increment 1 max 100; then
		return 0
	else
		rm /tmp/fw
		return 1
	fi
}

update_needed && {
	fetch_firmware && {
		_firmware burn /tmp/fw
	}
}

