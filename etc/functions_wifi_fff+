FUNC_WIFI=1

# func_wifi_get_params
# func_wifi_get_tx_and_rx
# func_wifi_get_config_params
# func_wifi_get_status_broadcom
# func_wifi_get_status_iwconfig
# func_wifi_print_iwconfig_sample
# func_wifi_probe_feature
# func_wifi_phy_probe_online
# func_wifi_get_hardware_pci
# func_wifi_get_hardware_usb
# func_wifi_get_driver_version
# func_wifi_get_sensitivity
# func_wifi_set_sensitivity
# func_wifi_install_full_broadcomdriver_if_not_installed
# todo: func_wifi_get_scansupress?
# todo: func_wifi_get_retry
# func_wifi_uptime
# func_wifi_restart_phy
# func_wifi_get_txpwr
# func_wifi_set_txpwr
# func_wifi_convert_mhz2channel
# func_wifi_convert_mw2qdbm
# func_wifi_set_antenna_rx
# func_wifi_set_antenna_tx
# func_wifi_get_antenna_rx
# func_wifi_get_antenna_tx
# func_wifi_get_bssid
# func_wifi_get_frag
# func_wifi_get_rts
# func_wifi_get_rate
# func_wifi_get_mrate
# func_wifi_get_noise
# func_wifi_get_signal
# func_wifi_get_channel
# func_wifi_get_protection
# func_wifi_get_assoclist
# func_wifi_get_all_devs
# func_wifi_probe_mode_infrastructure
# func_wifi_probe_mode_ap
# func_wifi_get_wifimode
# func_wifi_get_mode
# func_wifi_scan



# fixme! all calls to 'wl' must be in one functions, that checks for "Bus error" on stderr (2)
# fixme! [ ! -e /usr/sbin/wl ] && ...
# -> wl channel _must_ output something?

# alle devs rausbekommen
# pro dev herausbekommen, welche hardware = welcher treiber

# mode=master|client|adhoc|wds ???

# was wenn eine hardware mit wl und iwconfig angesprochen werden kann?
# vielleicht immer mit iwconfig probieren, wenn leer dann wl?!

# joinen von iwconfig/broadcom-ausgabe-variablen
# oder gleich broadcom nach iwconfig ueberfuehren?

# Idee, wie man mit mehreren wlan-karten klarkommt: 
#    Erstes WIFI_DEV steht sowohl in normaler Variablenliste,
#    als auch in /tmp/wifi_$DEV zum includen. So werden Operationen
#    auf alle Elemente in der Liste gemacht:
#    (es muss also nur was included werden, wenn es mehrere wireless-karten gibt)
#    (bei einer wlan-karte gibt es kein $WIFI_DEV_NEXT)
#
# for WIFI_DEV in $WIFI_DEVS; do {
#	do_some_stuff_with_normal_vars
#	[ -n "$WIFI_DEV_NEXT" ] && . $WIFI_DEV_NEXT	# inluding VAR-set for next WIFI_DEV
# } done						# (last entry must point to first-device)


func_wifi_get_params ()
{
	local VAR
	local WIFI_DEVS="$( func_wifi_get_all_devs )"
	local THIS_WIFI_DEV

	echo "WIFI_DEVS='$WIFI_DEVS'"	
	
	for THIS_WIFI_DEV in $WIFI_DEVS; do {

		func_wifi_get_hardware_usb  >/tmp/wifi_hardware
		func_wifi_get_hardware_pci >>/tmp/wifi_hardware
		. /tmp/wifi_hardware

		if [ "$WIFI_VENDOR" = "broadcom" ]; then
			func_wifi_get_status_broadcom $THIS_WIFI_DEV
		else
			func_wifi_get_status_iwconfig $THIS_WIFI_DEV
		fi

		cat /tmp/wifi_hardware		
		func_wifi_get_config_params
		func_wifi_get_tx_and_rx $THIS_WIFI_DEV
	} done
}

func_wifi_get_tx_and_rx ()		# ARG1 = NETWORK_DEV e.g. WIFI_DEV
{
	# WIFI_RX_BYTES=1665694551
	# WIFI_RX_PACKETS=22019893
	# WIFI_RX_ERRORS=0
	# WIFI_RX_FRAMES=109127
	# WIFI_TX_BYTES=2572111365
	# WIFI_TX_PACKETS=22193801
	# WIFI_TX_ERROR=3

	sed -n "s/^.*$1: *\([0-9]*\) *\([0-9]*\) *\([0-9]*\) *[0-9]* *[0-9]* *\([0-9]*\) *[0-9]* *[0-9]* *\([0-9]*\) *\([0-9]*\) *\([0-9]*\) .*/WIFI_RX_BYTES=\1\nWIFI_RX_PACKETS=\2\nWIFI_RX_ERRORS=\3\nWIFI_RX_FRAMES=\4\nWIFI_TX_BYTES=\5\nWIFI_TX_PACKETS=\6\nWIFI_TX_ERROR=\7/p" /proc/net/dev
}

func_wifi_get_config_params ()
{
	# WIFI_CONFIG_FRAG=2346
	# WIFI_CONFIG_CHANNEL=7
	# WIFI_CONFIG_BSSID=02:CA:FF:EE:BA:BE

	sed -ne '/^wl0_frag=/s/^wl0_frag=\([0-9]*\)/WIFI_CONFIG_FRAG=\1/p' \
	    -ne '/^wl0_channel=/s/^wl0_channel=\([0-9]*\)/WIFI_CONFIG_CHANNEL=\1\n/p' \
	    -ne '/^ff_bssid=/!d;s/^ff_bssid=\([0-9]\)/WIFI_CONFIG_BSSID=\1/;y/abcdef/ABCDEF/;p' /dev/mtdblock/3
}

func_wifi_get_status_broadcom ()	# ARG1 = WIFI_DEV ; safe and fast reformatting of 'wl status'-output
{					# for easy eval() BSSID is always uppercase
	# WIFI_DEV=eth1
	# WIFI_UPTIME=0
	# WIFI_ESSID='www.freifunk.net (Zugangspunkt)'
	# WIFI_MODE='Master'
	# WIFI_RSSI='0'						# is signal in [dBm]?
	# WIFI_NOISE='0'
	# WIFI_CHANNEL=7					# convert to MHz ?
	# WIFI_BSSID=00:1D:73:05:0F:59				# own wifi_mac in AP, master_wifi_mac in STA and cell in ADHOC-mode
	# WIFI_RATESET='1(b) 2(b) 5.5(b) 6 9 11(b) 12 18 24 36 48 54'

	wl -i $1 status 2>/dev/null |
	 sed -ne "s/'/'\\\''/g;s/^SSID: \"\(.*\)\"/WIFI_DEV=$1\nWIFI_UPTIME=0\nWIFI_ESSID='\1'/p" \
	     -ne "s/^Mode: \([ a-zA-Z]*\).*RSSI: \(.*\) dBm.*noise: \(.*\) dBm.*Channel: \([0-9]*\).*/WIFI_MODE='\1'\nWIFI_RSSI='\2'\nWIFI_NOISE='\3'\nWIFI_CHANNEL=\4/p" \
	     -ne "s/^Supported Rates: \[ \(.*\) \]/WIFI_RATESET='\1'/p" \
	     -ne "/^BSSID: /!d;s/^BSSID: \(..:..:..:..:..:..\).*/WIFI_BSSID=\1/;y/abcdef/ABCDEF/;p"
}

func_wifi_get_status_iwconfig ()	# ARG1 = WIFI_DEV
{
	# WIFI_DEV=eth1
	# WIFI_UPTIME=0
	# WIFI_ESSID='www.freifunk.net (Zugangspunkt)'  	# fixme! single quotes are not correct escaped!
	# WIFI_MODE="Managed"
	# WIFI_FREQ=2442					# in MHz ! -> convert to Channel?
	# WIFI_CHANNEL="$( func_wifi_convert_mhz2chan 2442 )"	# this is converted during 'eval'
	# WIFI_BSSID=00:1D:73:05:0F:59  
	# WIFI_SENSITIVITY="0/3"
	# WIFI_RETRY=off
	# WIFI_RTS=256
	# WIFI_FRAG=off
	# WIFI_QUALITY=52
	# WIFI_QUALITY_MAX=94
	# WIFI_SIGNAL='-43'
	# WIFI_NOISE='-95'

	iwconfig $1 2>/dev/null |
	 sed -ne "s/^.*ESSID:\"\(.*\)\"/WIFI_DEV=$1\nWIFI_UPTIME=0\nWIFI_ESSID='\1'/p" \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Access Point: \(..:..:..:..:..:..\)/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Cell: \(..:..:..:..:..:..\)/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( func_wifi_convert_mhz2channel \2\3 )\"\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Bit Rate:.*Tx-Power:.*Sensitivity=\([0-9]*\)\/\([0-9]*\).*/WIFI_SENSITIVITY="\1\/\2"/p' \
	     -ne 's/^.*Retry.\([a-z0-9]*\)[^a-zA-Z0-9]*RTS thr.\([a-z0-9]*\)[^0-9a-zA-Z]*Fragment thr.\([a-z0-9]*\).*/WIFI_RETRY="\1"\nWIFI_RTS="\2"\nWIFI_FRAG="\3"/p' \
	     -ne "s/^.*Link Quality[:=]\([0-9]*\)\/\([0-9]*\).*Signal level[:=]\([-0-9]*\) dBm.*Noise level[:=]\([-0-9]*\) dBm/WIFI_QUALITY=\1\nWIFI_QUALITY_MAX=\2\nWIFI_SIGNAL='\3'\nWIFI_NOISE='\4'/p"
}

func_wifi_print_iwconfig_sample ()		# only for testing above function
{
	cat >/dev/null <<EOF
ath0      IEEE 802.11b  ESSID:"www.freifunk.net (Zugangspunkt)"  
          Mode:Managed  Frequency:2.442GHz  Access Point: 00:1D:73:05:0F:59  
          Bit Rate:11Mb/s   Tx-Power:0 dBm   Sensitivity=0/3  
          Retry:off   RTS thr:off   Fragment thr:off
          Encryption key:off
          Power Management:off
          Link Quality:52/94  Signal level:-43 dBm  Noise level:-95 dBm
          Rx invalid nwid:8199  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
EOF

	cat <<EOF
ath0      IEEE 802.11g  ESSID:"hier muss was 'kompliziertes' stehen"   
          Mode:Ad-Hoc  Frequency:2.412 GHz  Cell: 02:0B:6B:DA:95:07   
          Bit Rate:0 kb/s   Tx-Power:19 dBm   Sensitivity=1/1  
          Retry:off   RTS thr:off   Fragment thr=256 B   
          Encryption key:off
          Power Management:off
          Link Quality=0/70  Signal level=-96 dBm  Noise level=-96 dBm
          Rx invalid nwid:389  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
EOF
}

func_wifi_probe_feature ()
{
	local FUNC="wifi_probe_feature"
	local FEATURE="$1"
	
	eval $(func_wifi_get_hardware_pci)	# WIFI_BANDS

	case "$FEATURE" in
		802.11a)
			echo $WIFI_BANDS | grep -q "a" && {
				func_log $FUNC daemon debug "802.11a capable"
				return 0
			}
		;;
		802.11b)
			echo $WIFI_BANDS | grep -q "b" && {
				func_log $FUNC daemon debug "802.11b capable"
				return 0
			}
		;;
		802.11g)
			echo $WIFI_BANDS | grep -q "g" && {
				func_log $FUNC daemon debug "802.11g capable"
				return 0
			}
		;;
	esac
	
	return 1
}

func_wifi_phy_probe_online ()		# fixme! more abstraction
{
	local WIFI_DEV="$1"
	
	[ "$( nvram get wl0_radio )" = "0" ] && {
		return 1
	}
	
	return 0
}

func_wifi_get_hardware_pci ()		# output can be more than one, how to handle?
{					# ARG1 = WIFI_DEV

	# WIFI_VENDOR=broadcom;WIFI_MODEL=4318

	sed -ne "/14e44318/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4318 ;WIFI_BANDS='b g'" \
	    -ne "/14e44320/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4306 ;WIFI_BANDS='b g'" \
	    -ne "/14e44319/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4319 ;WIFI_BANDS='b g a'" \
	    -ne "/168c0012/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5211a;WIFI_BANDS='b g a'" \
	    -ne "/168c0013/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5212a;WIFI_BANDS='b g a'" /proc/bus/pci/devices
}

func_wifi_get_hardware_usb ()
{
	# WIFI_VENDOR=ralink;WIFI_MODEL=rt73usb

	sed -ne "/Vendor=148f ProdID=2573/cWIFI_VENDOR=ralink;WIFI_MODEL=rt73usb;WIFI_BANDS='b g'" /proc/bus/usb/devices 2>/dev/null
}

func_wifi_get_driver_version ()
{
	local WIFI_DEV="$1"		# fixme! howto connect DEV -> PHY  (DEV -> DRIVER is no problem)
	local VERSION

	func_need packages

	if func_wifi_get_hardware_pci | grep -q broadcom ; then

		VERSION="$( wl -i $WIFI_DEV ver | sed -n 's/^wl:[^0-9]*\(.*\)/\1/p;q' | sed 's/[ ]/-/g' )"	# 3.90-RC37.0
		
		if [ -n "$VERSION" ]; then
			VERSION="wl-adv_${VERSION}_v$( func_packages_version wl-adv )"
		else
			VERSION="wl-simple_v$( func_packages_version wl )"
		fi
	else
		VERSION="kmod-madwifi_v$( func_packages_version kmod-madwifi )"
	fi
	
	echo "$VERSION"
}

func_wifi_get_sensitivity ()
{
	local WIFI_DEV="$1"
	local COMMAND="$2"	# short | mode
	local VALUE
	local OUT

	if func_wifi_get_hardware_pci | grep -q broadcom ; then

		VALUE="$( wl -i $WIFI_DEV interference )"
	
		case "$VALUE" in
			"Auto Wireless LAN Interference mitigation is enabled and not active")
				OUT="0,wifi,auto"
			;;
			"Auto Wireless LAN Interference mitigation is enabled and active")	# just guessed
				OUT="1,wifi,auto"
			;;
			"Wireless LAN Interference mitigation is enabled.")
				OUT="1,wifi,user"
			;;
			"Non-wireless LAN Interference mitigation is enabled.")
				OUT="1,nonwifi,user"
			;;
			"All interference mitigation is disabled.")
				OUT="0,all,user"
			;;
			*)
				OUT="?,wifi,auto"		# e.g. if 'wl-adv' is not installed
			;;
		esac
	else
		eval "$( func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_SENSITIVITY= )"	# e.g. '3/3'
		OUT="$WIFI_SENSITIVITY"								# fixme! output more common
	fi

	case $COMMAND in
		short)
			OUT="$( echo $OUT | cut -d',' -f1 )"		# "0,wifi,auto" -> "0"
		;;
		mode)
			OUT="$( echo $OUT | cut -d',' -f2-3 )"		# "0,wifi,auto" -> "wifi,auto"
		;;
	esac
	
	echo "$OUT"
}

func_wifi_install_full_broadcomdriver_if_not_installed ()
{
	local FUNC="wifi_install_full_broadcomdriver_if_not_installed"
	local WIFI_DEV="$( func_wifi_get_all_devs )"			# fixme!

	wl -i $WIFI_DEV ver | grep -q ^"wl:" && return 0
	
	func_need packages
	func_packages_install wl-adv && return 0

	func_log $FUNC daemon alert "installing 'wl-adv' was not possible"
		
	return 1
}

func_wifi_set_sensitivity ()
{
	local FUNC="wifi_set_sensitivity"
	local WIFI_DEV="$1"
	local METHOD="$2"	# off | auto | wifi | nonwifi

	if func_wifi_get_hardware_pci | grep -q broadcom ; then
	
		func_wifi_install_full_broadcomdriver_if_not_installed && {
		
			func_log $FUNC daemon info "setting interference mitigation for '$WIFI_DEV' to '$METHOD'"
		
			case $METHOD in			# fixme! only apply, when method differs from active method
				off)
					wl -i $WIFI_DEV interference 0
				;;
				nonwifi)
					wl -i $WIFI_DEV interference 1
				;;
				wifi)
					wl -i $WIFI_DEV interference 2
				;;
				auto)
					wl -i $WIFI_DEV interference 3
				;;
			esac
		}
	else
		# http://madwifi-project.org/ticket/820
		func_log $FUNC daemon info "setting interference mitigation with madwifi does not work"
	fi
}

func_wifi_get_scansupress ()
{
	local WIFI_DEV="$1"
	
	wl -i $WIFI_DEV scansuppress
}

func_wifi_get_retry ()
{
	local WIFI_DEV="$1"
	local RETRYTYPE="$2"		# long / short

	wl -i $WIFI_DEV srl		# short retrylimit: empty == default == 7	// non RTS/CTS-packets ("big packets")
	wl -i $WIFI_DEV lrl		# long  retrylimit: empty == default == 4
}

func_wifi_uptime ()	todo: get/set
{
	a=0
	# cut -d"." -f1 /proc/uptime
	# set
	# get
}

func_wifi_restart_phy ()
{
	local FUNC="wifi_restart_wifi_phy"
	local WIFI_DEV="$1"

	func_log $FUNC daemon info "working on '$WIFI_DEV'"

	if func_wifi_get_hardware_pci | grep -q broadcom ; then
	
		wifi					# simply rereads nvram for all broadcom-devices
	else
		# func_log $FUNC daemon info "ignoring event for non-broadcom devices"
		ip link set dev $WIFI_DEV down
		ip link set dev $WIFI_DEV up
	fi
}

func_wifi_get_txpwr ()
{
	local WIFI_DEV="$1"
	local UNIT="$2"		# keyword, can be 'mw', 'dbm', 'qdbm' // fixme! at the moment this IS in [mW]
	local POWER
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then

		POWER="$( wl -i $WIFI_DEV txpwr | cut -d" " -f3 )"	# this is in [mW]
	else
		POWER="$( iwlist "$WIFI_DEV" txpower 2>/dev/null | sed -n '/Tx-Power/s/^.*(\([0-9]*\).*/\1/p' )"		# [mW]
	fi
	
	echo "${POWER:-0}"	# no wifi-dev
}

func_wifi_set_txpwr ()		# fixme! abstraction of broadcom/atheros needed
{				# e.g.: func_wifi_set_txpwr "$WIFIDEV" 10 mW add overturn
	local FUNC="wifi_set_txpwr"
	local WIFI_DEV="$1"
	local TXPWR="$2"
	local UNIT="$3"		# keyword, can be 'mw', 'dbm', 'qdbm'	// fixme! at the moment this MUST be [mW]
	local MODE="$4"		# keyword, can be 'add', 'subtract', 'empty = absolute'
	local KEYWORD="$5"	# keyword: 'overturn' (if value is over max, then flip to min)
				#          'limit' (if value is over max or under min, than do nothing)
	local VALUE
	local VALUE_OLD
	local PRIO="alert"
	local MAX="90"		# this is just an proposal and not science-based
	local MIN="10"		# this is a not science-based, but IMHO a senseful value

	func_wifi_get_hardware_pci | grep -q broadcom || {
		func_log $FUNC daemon debug "abort - does only work with broadcom-driver"
		return
	}
	
	case $MODE in
	    	     add) VALUE="$(( $(func_wifi_get_txpwr $WIFI_DEV mw) + $TXPWR ))" ;;
		subtract) VALUE="$(( $(func_wifi_get_txpwr $WIFI_DEV mw) - $TXPWR ))" ;;
		       *)
		          VALUE="$( func_wifi_convert_mw2qdbm $TXPWR )"
		       	  VALUE_OLD="$( nvram get wl0_txpwr )"
		       	  
		       	  [ "$VALUE"   = "$VALUE_OLD" ] && return
		       	  [ "$VALUE" -lt "$VALUE_OLD" ] && PRIO="debug"		# don't spam too much
		       	  [ "$TXPWR" -gt 55	      ] && PRIO="alert"
		       	 
		       	  func_need nvram
		       	  func_log $FUNC daemon ${PRIO} "for '$WIFI_DEV' to '$TXPWR' mW ('$VALUE' qdBm)"
		       	  func_nvset wl0_txpwr "$VALUE"
		       	  wl -i "$WIFI_DEV" txpwr $TXPWR	# must be in [mW]
		       	 
		       	  return 0
		       ;;
	esac

	case "$KEYWORD" in
		overturn)
			[ "$VALUE" -gt "$MAX" ] && VALUE="$MIN"
			[ "$VALUE" -lt "$MIN" ] && VALUE="$MAX"
		;;
		limit)
			[ "$VALUE" -gt "$MAX" ] && VALUE="$MAX"
			[ "$VALUE" -lt "$MIN" ] && VALUE="$MIN"
		;;
	esac
	
	func_wifi_set_txpwr "$WIFI_DEV" "$VALUE" mw absolute
}

func_wifi_convert_mhz2channel ()	# http://en.wikipedia.org/wiki/Lost_of_WLAN_channels
{
	local o				# idea: add to each freq regdomain/countrycode
					#       and choose corresponding countrycode, which fits channel 8-)
	case $1 in
		2412) o=1 ;;  # 276	# block of 802.11b/g/n-freqs
		2417) o=2 ;;  # 276
		2422) o=3 ;;  # 276
		2427) o=4 ;;  # 276
		2432) o=5 ;;  # 276
		2437) o=6 ;;  # 276
		2442) o=7 ;;  # 276
		2447) o=8 ;;  # 276
		2452) o=9 ;;  # 276
		2457) o=10 ;; # 276
		2462) o=11 ;; # 276
		2467) o=12 ;; # 276
		2472) o=13 ;; # 276
		2484) o=14 ;;

					# block of 802.11y ommited

		5035) o=7 ;;		# block of 802.11a/h/j/n
            504|5040) o=8 ;;
		5045) o=9 ;;		# fixme! mark 'outdoor'-channels
		5055) o=11 ;;
	    506|5060) o=12 ;;
            508|5080) o=13 ;;

	    517|5170) o=34 ;;
	    518|5180) o=36 ;; # 608 
	    519|5190) o=38 ;;
	     52|5200) o=40 ;; # 608
	    521|5210) o=42 ;; #	608	# TURBO.only	# for TURBO, see http://madwifi-project.org/wiki/UserDocs/802.11a_channels
	    522|5220) o=44 ;; # 608
	    523|5230) o=46 ;;
	    524|5240) o=48 ;; # 608
	    525|5250) o=50 ;; # 608	# TURBO.only	# not listed in wikipedia?
	    526|5260) o=52 ;; # 608
	    528|5280) o=56 ;; # 608
	    529|5290) o=58 ;; # 608	# TURBO.only	# not listed in wikipedia?
	     53|5300) o=60 ;; # 608
	    532|5320) o=64 ;; # 608

	     55|5500) o=100 ;; # 276	# iwconfig-output is '55' and means 5500mhz!
	    552|5520) o=104 ;; # 276
	    553|5530) o=106 ;; # 276	# not listed in wikipedia?
	    554|5540) o=108 ;; # 276
	    556|5560) o=112 ;; # 276
	    557|5570) o=114 ;; # 276	# not listed in wikipedia?
	    558|5580) o=116 ;; # 276
	     56|5600) o=120 ;; # 276
	    561|5610) o=122 ;; # 276	# not listed in wikipedia?
	    562|5620) o=124 ;; # 276
	    564|5640) o=128 ;; # 276
	    565|5650) o=130 ;; # 276	# not listed in wikipedia?
	    566|5660) o=132 ;; # 276
	    568|5680) o=136 ;; # 276
	     57|5700) o=140 ;; # 276
		5745) o=149 ;;
	    576|5760) o=152 ;;	# TURBO.only	# not listed in wikipedia?
		5765) o=153 ;;
		5785) o=157 ;;
	     58|5800) o=160 ;;	# TURBO.only	# not listed in wikipedia?
		5805) o=161 ;;
		5825) o=165 ;;

		4915) o=183 ;;
	    492|4920) o=184 ;;
		4925) o=185 ;;
		4935) o=187 ;;
	    494|4940) o=188 ;;
		4945) o=189 ;;
	    496|4960) o=192 ;;
	    498|4980) o=196 ;;
					# wl also knows: 200, 204, 208, 212, 216
					
		   *) o=0 ;;		# fixme! till we inserted all freqs
	esac

	echo -n "$o"
}

func_wifi_convert_mw2qdbm ()		# for broadcom on freifunk, convert unit [mW] -> [qdBm]
{
	local o
					# nvram 0|78 is both 89 mW
	case $1 in
	 	 2) o=8 ;;
	 	 3) o=16 ;;
	 	 4) o=22 ;;		
		 5) o=27 ;;
		 6) o=30 ;;
		 7) o=33 ;;
		 8) o=36 ;;
		 9) o=38 ;;
		10) o=40 ;;
		11) o=41 ;;
		12) o=43 ;;
		13) o=44 ;;
		14) o=46 ;;
		15) o=47 ;;
		16) o=48 ;;
		17) o=49 ;;
		18) o=50 ;;
		19) o=51 ;;
		20) o=52 ;;
		21) o=53 ;;
	     22|23) o=54 ;;
		24) o=55 ;;
	     25|26) o=56 ;;
		27) o=57 ;;
	     28|29) o=58 ;;
	     30|31) o=59 ;;
		32) o=60 ;;
	     33|34) o=61 ;;
	  35|36|37) o=62 ;;
	     38|39) o=63 ;;
	     40|41) o=64 ;;
          42|43|44) o=65 ;;
             45|46) o=66 ;;
            4[7-9]) o=67 ;;
            5[0-2]) o=68 ;;
            5[3-5]) o=69 ;;
            5[6-9]) o=70 ;;
            6[0-2]) o=71 ;;
            6[3-6]) o=72 ;;
         6[7-9]|70) o=73 ;;
            7[1-4]) o=74 ;;
            7[5-8]) o=75 ;;
         79|8[0-3]) o=76 ;;
            8[4-8]) o=77 ;;
         89|9[0-3]) o=78 ;;
            9[4-9]) o=79 ;;
	   10[0-5]) o=80 ;;
   10[6-9]|110|111) o=81 ;;
           11[2-8]) o=82 ;;
       119|12[0-5]) o=83 ;;
   12[6-9]|13[0-2]) o=84 ;;
       13[3-9]|140) o=85 ;;
           14[1-9]) o=86 ;;
           15[0-7]) o=87 ;;
   158|159|16[0-7]) o=88 ;;
   168|169|17[0-7]) o=89 ;;
   178|179|18[0-7]) o=90 ;;
   188|189|19[0-9]) o=91 ;;
       20[0-9]|210) o=92 ;;
   21[1-9]|22[0-3]) o=93 ;;
   22[4-9]|23[0-6]) o=94 ;;
   23[7-9]|24[0-9]) o=95 ;;
               250) o=95 ;;
           25[1-4]) o=96 ;;
	       255) o=97 ;;
		 *) o=1 ;;
	esac
	
	echo -n "$o"
}

func_wifi_set_antenna_rx ()
{
	local FUNC="wifi_set_antenna_rx"
	local WIFI_DEV="$1"
	local ANTENNA="$2"
	local VALUE

	case "$ANTENNA" in
		0) VALUE=0 ;;
		1) VALUE=1 ;;
		*) VALUE=-1 ;;
	esac
	
	func_nvset wl0_antdiv "$VALUE"					# fixme! set it also with 'wl -i $WIFIDEV rxant ?'

	func_wifi_get_hardware_pci | grep -q broadcom || {		# fixme! must be device specific
		case $VALUE in
		       -1)
		       		func_log $FUNC daemon debug "sysctl +dev.wifi0.diversity = 1"
				sysctl -w dev.wifi0.diversity=1
			;;
			*)
				func_log $FUNC daemon debug "sysctl +dev.wifi0.diversity = 0"
				func_log $FUNC daemon debug "sysctl +dev.wifi0.rxantenna = $(( $VALUE + 1 ))"
				sysctl -w dev.wifi0.diversity=0
				sysctl -w dev.wifi0.rxantenna="$(( $VALUE + 1 ))"
			;;
		esac
	}
}

func_wifi_set_antenna_tx ()
{
	local FUNC="wifi_set_antenna_tx"
	local WIFI_DEV="$1"
	local ANTENNA="$2"
	
	case "$ANTENNA" in
		0) VALUE=0 ;;
		1) VALUE=1 ;;
		*) VALUE=-1 ;;
	esac
	
	func_nvset wl0_txant "$VALUE"

	func_wifi_get_hardware_pci | grep -q broadcom || {		# fixme! must be device specific
		case $VALUE in
		       -1)
				func_log $FUNC daemon debug "sysctl +dev.wifi0.diversity = 1"
				sysctl -w dev.wifi0.diversity=1
			;;
			*)
				func_log $FUNC daemon debug "sysctl +dev.wifi0.diversity = 0"
				func_log $FUNC daemon debug "sysctl +dev.wifi0.txantenna = $(( $VALUE + 1 ))"
				sysctl -w dev.wifi0.diversity=0
				sysctl -w dev.wifi0.txantenna="$(( $VALUE + 1 ))"
			;;
		esac
	}
}

func_wifi_get_antenna_rx ()
{
	local WIFI_DEV="$1"
	local RX="$( nvram get wl0_antdiv )"

	case $RX in
		0) echo "0" ;;
		1) echo "1" ;;
		*) echo "auto" ;;
	esac
}

func_wifi_get_antenna_tx ()
{
	local WIFI_DEV="$1"
	local TX="$( nvram get wl0_txant )"

	if [ "$TX" = "0" ] || [ "$TX" = "1" ]; then
		echo "$TX"
		return
	fi

	echo "auto"
}

func_wifi_get_distance ()
{
	local WIFI_DEV="$1"
	
	nvram get wl0_distance
}

func_wifi_get_bssid ()			# BSSID = cell in adhoc, ap-wifimac in ap, wifimac of associated ap in client-mode
{
	local WIFI_DEV="$1"		# fixme! check, if this works with broadcom AND madwifi in all conditions
	local SWITCH="$2"		# can be 'config'
	local WIFI_BSSID

	[ "$SWITCH" = "config" ] && {				# fixme! return wifimac in 'ap'-mode?
		func_uppercase "$(nvram get ff_bssid)"
		return
	}
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific

		eval "$(func_wifi_get_status_broadcom $WIFI_DEV | grep ^WIFI_BSSID= )"
	else
		eval "$(func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_BSSID= )"
	fi
	
	func_uppercase $WIFI_BSSID
}

func_wifi_get_frag ()
{
	local WIFI_DEV="$1"
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific
	
		wl -i $WIFI_DEV frag | sed -n 's/^frag is \([0-9]*\).*$/\1/p'
	else
		eval "$(func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_FRAG )"
		echo $WIFI_FRAG
	fi
}

func_wifi_get_rts ()
{
	local WIFI_DEV="$1"

	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific
	
		wl -i $WIFI_DEV rts | sed -n 's/^rts is \([0-9]*\).*$/\1/p'
	else
		eval "$(func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_RTS )"
		echo $WIFI_RTS
	fi
}

func_wifi_get_rate ()
{
	local WIFI_DEV="$1"
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then
	
		wl -i $WIFI_DEV rate | cut -d' ' -f3		# 1, 2, 5.5, 6, 9, 12 ...
	else
		# Current Bit Rate=54 Mb/s
		# Current Bit Rate:0 kb/s
		
		iwlist $WIFI_DEV rate 2>/dev/null | sed -n 's/^.*Bit Rate[:=]\([0-9\.]*\) .*/\1/p'
	fi
}

func_wifi_get_mrate ()
{
	local WIFI_DEV="$1"
	local LINE
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific
	
		wl -i $WIFI_DEV mrate | cut -d' ' -f3		# 1, 2, 5.5, 6, 9, 12 , auto ...
	else
		iwpriv $WIFI_DEV get_mcast_rate |
		 sed -n 's/^.*:\([0-9]*\).*/\1/p' |
		  while read LINE; do {
			case $LINE in
				5500) echo 5.5 ;;
				   *) echo $(( $LINE / 1000 )) ;;	
			esac
		} done
	fi
}

func_wifi_get_noise ()		# OUT1: signed Integer, -93 [dBm]
{
	local WIFI_DEV="$1"
	local WIFI_MODE="$(func_wifi_get_mode $WIFI_DEV)"
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific
	
		case "$WIFI_MODE" in
			adhoc|client)
				wl -i $WIFI_DEV noise | sed 's/[^0-9-]//g'
			;;
			ap)
				echo "0"	# fixme! does not work in broadcom?
			;;
			*)
				echo ""		# ?
			;;
		esac
	else
		eval "$(func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_NOISE )"
		
		case "$WIFI_MODE" in
			adhoc)
				echo $WIFI_NOISE
			;;
			client)
				echo ""		# fixme!
			;;
			ap)
				echo ""		# fixme!
			;;
			*)
				echo ""		# ?
			;;
		esac
	fi
}

func_wifi_get_signal ()		# OUT1: signed Integer, -70 [dBm] or list of $MAC+RSSI of all stations	// fimxe! better concept needed
{
	local WIFI_DEV="$1"
	local WIFI_MODE="$(func_wifi_get_mode $WIFI_DEV)"
	local MAC RSSI LOOP

	# func_need sanitizer

	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific	

		case "$WIFI_MODE" in
			adhoc|client)
				wl -i $WIFI_DEV rssi | sed 's/[^0-9-]//g'
			;;
			ap)
				# for MAC in $(func_wifi_get_assoclist $WIFI_DEV); do {
				#	RSSI="$( wl -i $WIFI_DEV rssi $MAC | sed -n 's/^rssi is \([0-9-]*\).*/\1/p' )"
				#	echo -n "${LOOP:+:}$( _sanitizer "$MAC" hex )${RSSI}"
				#	LOOP=1
				# } done
				
				for MAC in $(func_wifi_get_assoclist $WIFI_DEV); do {
					wl -i $WIFI_DEV rssi $MAC | cut -d' ' -f3
				} done | sort -n | tail -n1
			;;
			*)
				echo ""		# fixme!
			;;
		esac
	else
		case "$WIFI_MODE" in
			adhoc)
				eval "$(func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_SIGNAL )"
				echo "$WIFI_SIGNAL"
			;;
			client)
				echo ""		# fixme!
			;;
			ap)
				echo ""		# fixme!
			;;
			*)
				echo ""		# fixme!
			;;
		esac	
	fi
}

func_wifi_get_channel ()
{
	local WIFI_DEV="$1"
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific
	
		eval "$(func_wifi_get_status_broadcom $WIFI_DEV | grep ^WIFI_CHANNEL )"
	else
		eval "$(func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_CHANNEL )"
	fi
	
	echo $WIFI_CHANNEL
}

func_wifi_get_protection ()	# OUT1: integer, 0 | 1
{
	local WIFI_DEV="$1"
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific
	
		wl -i $WIFI_DEV gmode_protection | sed -n 's/^gmode_protection is \([0-9]\) .*/\1/p'
	else
		iwpriv $WIFI_DEV get_protmode | sed -n 's/^.*:\([01]\).*/\1/p'
	fi
}

func_wifi_get_assoclist ()		# OUT1: list of associated mac_adresses
{
	func_need sanitizer

	local WIFI_DEV="$1"
	local WIFI_MODE="$(func_wifi_get_mode $WIFI_DEV)"
	local NOP MAC
	
	if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific

		case "$WIFI_MODE" in
			adhoc)
				echo ""		# fixme! howto distinguish from OLSR-neighs?
			;;
			ap)
				wl -i $WIFI_DEV assoclist |
				 while read NOP MAC; do {
				 	echo -n "$( _sanitizer "$MAC" lowercase ) "
				 } done
			;;
			client)
				echo ""		# fixme!
			;;
		esac
	else
		echo ""				# fixme!
	fi
}

func_wifi_get_all_devs ()	# one device per line
{
	sed -n 's/^ *\(.*\): [0-9]*.*/\1/p' /proc/net/wireless
	#  sed -n 's/^ *\([^:]\+\):.*/\1/p' /proc/net/wireless	(sven-ola)
}

func_wifi_probe_mode_infrastructure ()		# fixme! respect WIFI_DEV
{
	local WIFI_DEV="$1"
	local SWITCH="$2"	# 'config' or <empty>

	if [ "$SWITCH" = "config" ]; then
	
		[ "$(nvram get wl0_infra)" = "1" ] && return 0
		return 1
	else
		if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific
	
			eval "$( func_wifi_get_status_broadcom $WIFI_DEV | grep ^WIFI_MODE= )"
		else
			eval "$( func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_MODE= )"
		fi
		
		case $WIFI_MODE in
			Managed|managed|Master|master) return 0 ;;
						    *) return 1 ;;
		esac
	fi
}

func_wifi_probe_mode_ap ()			# fixme! respect WIFI_DEV
{
	local WIFI_DEV="$1"
	local SWITCH="$2"	# 'config' or <empty>

	if [ "$SWITCH" = "config" ]; then

		[ "$(nvram get wl0_mode)" = "ap" ] && return 0		
		return 1
	else
		if func_wifi_get_hardware_pci | grep -q broadcom ; then		# fixme! hardware-check must be device specific
		
			eval "$( func_wifi_get_status_broadcom $WIFI_DEV | grep ^WIFI_MODE= )"
		else
			eval "$( func_wifi_get_status_iwconfig $WIFI_DEV | grep ^WIFI_MODE= )"
		fi
		
		case $WIFI_MODE in
			Managed|managed|Master|master) return 0 ;;
						    *) return 1 ;;
		esac
	fi
}

func_wifi_get_wifimode ()	# fixme! howto describe:			// rename: wifi_get_mode_phy?
{
				# channel-width, compression, frame-aggregation/bursting, plcp-header(=preamble)long/short ...?

	local WIFI_DEV="$1"	# OUT1: string, b | g | bg | gT | a | aT | abg?

	echo "bg"		# fixme!
}

func_wifi_get_mode ()		# OUT1: string, ap | client | adhoc		// rename: wifi_get_mode_conn?
{
	local WIFI_DEV="$1"	# fixme! some calls can't provide wifidev - till now we only check nvram, so it does'nt matter
	local SWITCH="$2"	# can be 'config' or <empty>

	if func_wifi_probe_mode_infrastructure $WIFI_DEV "$SWITCH" ; then
	
		if func_wifi_probe_mode_ap $WIFI_DEV "$SWITCH" ; then
			echo 'ap'
		else
			echo 'client'	# fixme! output 'sta' or 'station' ?
		fi
	else
		if func_wifi_probe_mode_ap $WIFI_DEV "$SWITCH" ; then
			echo 'unknown'	
		else
			echo 'adhoc'
		fi
	fi
}

func_wifi_scan ()			# OUT: 00184d81a0c2:1:-93:-82:6:WEP:NETGEAR;06180a015e3e:1:-88:-76:8:WEP:Zugangspunkt
{					# which means   BSSID : INFRA/ADHOC=1/0 | RSSI | NOISE | CHANNEL | CRYPT | ESSID + next_entry
	local WIFI_DEV="$1"
	local FILE="/tmp/WIFI_SCAN_$$"
	local LINE SIGNAL NOISE CHANNEL BSSID CRYPT INFRA LOOP
	
	func_need sanitizer

	if func_wifi_get_hardware_pci | grep -q broadcom ; then

		[ "$(func_wifi_get_mode $WIFI_DEV)" != "adhoc" ] && return
	
		wl -i $WIFI_DEV scan					# SSID: "FRITZ!Box Fon WLAN 7141"
		sleep 3							# Mode: Managed RSSI: -93 dBm noise: -89 dBm Channel: 10
		wl -i $WIFI_DEV scanresults >$FILE			# BSSID: 00:04:0E:88:F1:03 Capability: ESS WEP ShortSlot
									# Supported Rates: [ 1(b) 2(b) 5.5(b) 11(b) 6 9 12 18 24 36 48 54 ]
		while read LINE; do {
			
			case "$( echo $LINE | cut -d: -f1 )" in
				
				SSID)
					ESSID="$( echo "$LINE" | sed -n 's/^SSID: "\(.*\)"$/\1/p' )"
					ESSID="$( _sanitizer "$ESSID" essid )"			# fixme! (escape_all?)
				;;
				Mode)
					# 'Mode: Managed RSSI: -93 dBm noise: -89 dBm Channel: 10'
					# SIGNAL="-93";NOISE="-89";CHANNEL="10"
				
					eval "$( echo "$LINE" | sed -n 's/^Mode: .*RSSI: \([0-9-]*\).*dBm.*noise: \([0-9-]*\).*dBm.*Channel: \([0-9]*\).*/SIGNAL="\1";NOISE="\2";CHANNEL="\3"/p' )"
				;;
				BSSID)
					# 'BSSID: 00:04:0E:88:F1:03 Capability: ESS WEP ShortSlot'
					
					BSSID="$( echo "$LINE" | sed -n 's/^BSSID: \([0-9a-fA-F:]*\).*/\1/p' )"
					[ "$( echo $BSSID | cut -d':' -f1 )" = "02" ] && INFRA=0
					BSSID="$( _sanitizer "$BSSID" hex lowercase )"
					
					echo "$LINE" | grep -q "WEP" && CRYPT="WEP"
				;;
				"")
					[ -z "$BSSID" ] && continue
					echo -n "${LOOP:+;}${BSSID}:${INFRA:=1}:${SIGNAL}:${NOISE}:${CHANNEL}:${CRYPT:=0}:${ESSID}"
					
					LOOP=1;BSSID=;INFRA=;SIGNAL=;NOISE=;CHANNEL=;CRYPT=;ESSID=
				;;
			esac
			
		} done <$FILE
	else
		# fixme! needs a parser for madwifi...
		continue
	fi
	
	[ -e "$FILE" ] && rm $FILE
}
