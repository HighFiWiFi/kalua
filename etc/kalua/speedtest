_speedtest_meta1 ()
{
	:
	# test whole network
}

_speedtest_help ()
{
	_speedtest do help
}

_speedtest_do ()
{
	local FUNC="speedtest_do"

	case "$1" in
		"-h"|"-help"|"--help"|"help")
			cat <<EOF

Usage:	_speedtest do <firstIP> <secondIP> <method> <duration>

	speedtest is performed between first and second IP with a
	selectable measure-method. after wished duration (defaults
	to 10 seconds), test is aborted and overall speed is calculated.

	empty <firstIP> defaults to IP of local wifi interface
	empty <secondIP> defaults to wifi-IP of nexthop to internet
	empty <method> defaults to poormens_tcpdownload
	empty <duration> defaults to 10 seconds
	
	<firstIP> can also be the keyword "here" or "path_to"
	<secondIP> can also be a keyword, e.g. "here", "gateway", "inetgateway", "neighs_onehop" or "neighs_wifi_onehop"
	<method> can be "poormens_tcpdownload", "udpupload", "udpdownload", "tcpdownload" or "tcpupload"

e.g.:	_speedtest do here gateway udpupload 15
	_speedtest do 10.63.12.1 10.63.99.1 tcpdownload 5
	_speedtest do gateway here
	_speedtest do

EOF
			return
		;;
	esac

	local IP_LOCAL="${1:-$WIFIADR}"			# [ip4]
	local KEYWORD="${2:-gateway}"			# [ip4 = IP_TARGET] or keyword - fixme! allow lists
	local METHOD="${3:-poormens_tcpdownload}"	# keyword, e.g. tcpdownload, netperfTCP, netperfUDP
	local DURATION="${4:-10}"			# [seconds]
	local INITIATOR="${REMOTE_ADDR:-local}"
	local LIST IP I IP_LOCAL IP_REMOTE

	_log do $FUNC daemon debug "$IP_LOCAL <-> $KEYWORD method '$METHOD', duration $DURATION sec, initiated from $INITIATOR"

	case "$IP_LOCAL" in
		$WIFIADR|$LANADR|$WANADR)
			:
		;;
		here)
			IP_LOCAL="$WIFIADR"
		;;
		path_to)
			LIST="$WIFIADR $( traceroute -n "$KEYWORD" 2>/dev/null | while read NOP IP NOP;do echo $IP;done )"

			list_get_element ()
			{
				local LIST="$1"
				local N="$2"
				local I=0
				local OBJ
				
				for OBJ in $LIST; do {
					I=$(( $I + 1 ))
					[ $I -eq $N ] && {
						echo $OBJ
						break
					}
				} done
			}

			I=0
			for IP in $LIST; do {
					I=$(( $I + 1 ))
					IP_LOCAL="$(  list_get_element "$LIST" $I )"
					IP_REMOTE="$( list_get_element "$LIST" $(( $I + 1 )) )" 

					[ -n "$IP_REMOTE" ] && _speedtest do $IP_LOCAL $IP_REMOTE $METHOD $DURATION
			} done

			return
		;;
		*)
			_sanitizer do "$IP_LOCAL" ip4 check || return

			local URL="http://$IP_LOCAL/cgi-bin-tool_fff+?OPT=speedtest&ARGS=$IP_LOCAL+$KEYWORD+$METHOD+$DURATION"
			_log do $FUNC daemon debug "fetching '$URL'"
			wget -qO - "$URL"
			return				# fixme! translate IP_LOCAL/KEYWORD (can be e.g. here or gateway)?
		;;
	esac

	local MAXCOST=7000	# fixme! hardcoded and unused?
	local VALUES IP_LOCAL IP_TARGET LOAD_BEGIN LOAD_END UNIXTIME HUMANTIME METRIC_BEGIN METRIC_END OLSR_COST_BEGIN OLSR_COST_END SPEED DEVTYPE
	local PID_WGET PACK BYTES REST METHOD IP_LIST NOP
	local RATE RATE_MIN RATE_MAX RATE_AVG RATE_SAMPLES DIRECTION
	local DURATION DURATION_REAL DURATION_COUNTER
	local PID_OF_TOOL

	case "$METHOD" in
		poormens_tcpdownload|udpupload|udpdownload|tcpupload|tcpdownload)
			:
		;;
		*)
			METHOD="poormens_tcpdownload"		# fixme! here we must track 'rate' of device from which we download
		;;
	esac

	case "$KEYWORD" in			# fixme! we need _net_any2ip() on several points
		here)
			IP_LIST="$WIFIADR"
		;;
		neighs_onehop)
			IP_LIST="$( neigh | sed -n 's/^.* ..1.. \([0-9\.]*\).*/\1/p' )"
		;;
		neighs_wifi_onehop)
			IP_LIST="$( neigh | sed -n 's/^.* ~~1~~ \([0-9\.]*\).*/\1/p' )"
		;;
		gateway)
			_net local_inet_offer && {
				_log do $FUNC daemon info "no gatewaytest, because we _are_ the gateway 8-)"
				return
			}				

			IP_LIST="$( _sanitizer do "$( ip route list exact 0/0 )" ip4 )"
		;;
		inetgateway)
			IP_LIST="$( sed -n 's/^.* GW=\([0-9\.]*\).*/\1/p' /tmp/GATEWAY_CHECK_RECENT )"
		;;
		*)
			_sanitizer do "$KEYWORD" ip4 check || {
				_log do $FUNC daemon info "this is not an IP-address or known keyword: '$KEYWORD'"
				return
			}
			IP_LIST="$KEYWORD"
		;;
	esac

	if [ -z "$IP_LIST" ]; then
		_log do $FUNC daemon info "empty target list?"
	else
		_log do $FUNC daemon info "looping with method $METHOD from $IP_LOCAL over list $IP_LIST"
	fi

	# fixme! onehop, but metric >1 && continue
	# fixme! calculate EFFECTIV_PROCENTUAL_THROUGHPUT -> 34 mbit rate_avg, but 207kb/s -> xy% from max
	# fixme! udpupload >1 hop does not make sense - we only fill the buffers (here -> wire -> nextrouter -> wifi)

	for IP_TARGET in $IP_LIST; do {

		[ "$IP_LIST" != "$KEYWORD" ] && {
			_log do $FUNC daemon debug "$IP_LOCAL <-> $IP_TARGET method '$METHOD', duration $DURATION sec, initiated from $INITIATOR"
		}

		netperf_fire ()
		{
			_log do $FUNC daemon debug "netperf -H $1 -t $2 -l $3"
			netperf -H $1 -t $2 -l $3 >/dev/null &
		}

		case "$METHOD" in
			poormens_tcpdownload|tcpdownload|udpdownload)
				DIRECTION="download"
			
				case "$METHOD" in
					poormens_tcpdownload)
						iptables -I INPUT -p tcp --sport 80 -s $IP_TARGET
						wget -qO /dev/null "http://$IP_TARGET/cgi-bin-dev-zero.bin" &
					;;
					tcpdownload)
						iptables -I INPUT -p tcp -s $IP_TARGET
						netperf_fire $IP_TARGET TCP_MAERTS $(( $DURATION * 2 ))
					;;
					udpdownload)
						iptables -I INPUT -p udp -s $IP_TARGET
						netperf_fire $IP_TARGET UDP_MAERTS $(( $DURATION * 2 ))		# fixme! older netperf's do not know this method
					;;
				esac
			;;
			udpupload|tcpupload)
				DIRECTION="upload"

				case "$METHOD" in		# seems that dport (12865?) changes randomly, so it's a bit inexact
					udpupload)
						iptables -I OUTPUT -p udp -d $IP_TARGET
						netperf_fire $IP_TARGET UDP_STREAM $(( $DURATION * 2 ))
					;;
					tcpupload)
						iptables -I OUTPUT -p tcp -d $IP_TARGET
						netperf_fire $IP_TARGET TCP_STREAM $(( $DURATION * 2 ))
					;;
				esac
			;;
		esac

		PID_OF_TOOL="$!"
		[ -z "$PID_OF_TOOL" ] && _log do $FUNC daemon info "[ERR] empty pid of measurement-tool"
		trap "kill $PID_OF_TOOL" SIGINT

		_stopwatch start speedtest_$$				############## START ###########

		LOAD_BEGIN="$( _system load 1min )"
		eval "$( neigh get_nlq $IP_TARGET speedtest )"		# LQ|NLQ|COST
		OLSR_COST_BEGIN=$COST

		UNIXTIME="$(  _system date unixtime )"
		HUMANTIME="$( _system date humanreadable )"
		METRIC_BEGIN="$( _net ip2metric $IP_TARGET )"
		DEVTYPE="$( _net dev_type $( _net ip2dev $IP_TARGET ))"

		[ "$DIRECTION" = "upload" ] || {
			[ "$DEVTYPE" = "wifi" ] || {
				_log do $FUNC daemon debug "outgoing device is not of type wifi, but '$DEVTYPE' - no output of rate_control_algo"
			}
		}

		while [ ${DURATION_COUNTER:=0} -lt $(( $DURATION / 2 )) ]; do {

			[ "$DIRECTION" = "upload" -a "$DEVTYPE" = "wifi" -a "${METRIC_BEGIN:=0}" = "1" ] && {

				RATE="$( wl -i $WIFIDEV rate | cut -d' ' -f3 )"		# fixme! use _wifi()-abstraction
				case "${RATE:=0}" in
					5.5) RATE=5500 ;;
					  0) RATE=1000 ;;
					  *) RATE="${RATE}000" ;;			# rate is convert to [Kilobit]
				esac
				
				[ $RATE -gt ${RATE_MAX:-0}	] && RATE_MAX="$RATE"
				[ $RATE -lt ${RATE_MIN:-600000}	] && RATE_MIN="$RATE"
				RATE_AVG="$(( ${RATE_AVG:-0} + $RATE ))"
				RATE_SAMPLES="$(( ${RATE_SAMPLES:-0} + 1 ))"
				
				_log do $FUNC daemon debug "rate: $RATE"
			}

			sleep 1
			DURATION_COUNTER="$(( $DURATION_COUNTER + 1 ))"
		} done

		DURATION_COUNTER=0
		RATE_AVG="$(( ${RATE_AVG:-0} / ${RATE_SAMPLES:-1} ))"

		LOAD_END="$( _system load 1min )"
		METRIC_END="$( _net ip2metric $IP_TARGET )"

		eval "$( neigh get_nlq $IP_TARGET speedtest )"		# LQ|NLQ|COST
		OLSR_COST_END=$COST

		[ -e "/proc/$PID_OF_TOOL" ] && kill $PID_OF_TOOL	# normally this is only needed when poormens_tcpdownload
		DURATION_REAL="$( _stopwatch stop speedtest_$$ )"	############## END #############

		case "$DIRECTION" in
			download)
				eval $( iptables --line-numbers -nxvL INPUT  | grep ^"1 " | while read NOP PACK BYTES REST; do echo "BYTES=$BYTES"; done )
				iptables -D INPUT 1
			;;
			upload)
				eval $( iptables --line-numbers -nxvL OUTPUT | grep ^"1 " | while read NOP PACK BYTES REST; do echo "BYTES=$BYTES"; done )
				iptables -D OUTPUT 1
			;;
		esac
			
		trap - SIGINT						# unset
		SPEED="$(( ${BYTES:=0} / $DURATION_REAL / 10 ))"	# kilobytes / second ; 1 Kilobyte = 1000 Bytes

		VALUES="IP_LOCAL=$IP_LOCAL IP_TARGET=$IP_TARGET SPEED=$SPEED RATE_AVG=$RATE_AVG RATE_MIN=${RATE_MIN:-0} RATE_MAX=${RATE_MAX:-0} BYTES=$BYTES METHOD=$METHOD LOAD_BEGIN=$LOAD_BEGIN LOAD_END=$LOAD_END UNIXTIME=$UNIXTIME HUMANTIME=$HUMANTIME INITIATOR=$INITIATOR METRIC_BEGIN=$METRIC_BEGIN METRIC_END=$METRIC_END OLSR_COST_BEGIN=$OLSR_COST_BEGIN OLSR_COST_END=$OLSR_COST_BEGIN DURATION=${DURATION}000 DURATION_REAL=${DURATION_REAL}0 DEVTYPE=$DEVTYPE"
		_speedtest_store "$IP_LOCAL" "$IP_TARGET" "$METHOD" "$UNIXTIME" "$SPEED" "$VALUES"

		_log do $FUNC daemon info "$IP_LOCAL <-> $IP_TARGET @ $SPEED Kilobytes/sec, method '$METHOD'"

		[ -n "$REMOTE_ADDR" ] && echo "$IP_LOCAL <-> $IP_TARGET @ $SPEED Kilobytes/sec, method '$METHOD'"
	} done
}

_speedtest_store ()				# fixme! metric_begin/end differs? don't use it for speed_avg but store it
{						# fixme! autoremove/max XY entrys per connection? 
	local FUNC="speedtest_store"		# fixme! calculate efficiency of rate_control_algorithm
	
	local IP_LOCAL="$1"
	local IP_TARGET="$2"
	local METHOD="$3"
	local TIME="$4"
	local SPEED="$5"
	local VALUES="$6"

	local DIR="/tmp/STATS/SPEEDTEST"

	DIR="$DIR/$IP_LOCAL/$IP_TARGET/$METHOD"
	[ -d "$DIR" ] || mkdir -p "$DIR"

	local SAMPLES SPEED_AVG SPEED_MIN SPEED_MAX SPEED_SUM
	read  SAMPLES SPEED_AVG SPEED_MIN SPEED_MAX SPEED_SUM 2>/dev/null <"$DIR/stats"	

	[ "${SPEED_MAX:=0}"     -lt "$SPEED"	] && SPEED_MAX="$SPEED"
	[ "${SPEED_MIN:=15000}" -gt "$SPEED"	] && SPEED_MIN="$SPEED"

	SAMPLES="$(( ${SAMPLES:-0} + 1 ))"
	SPEED_SUM="$(( ${SPEED_SUM:-0} + $SPEED ))"
	SPEED_AVG="$(( $SPEED_SUM / $SAMPLES ))"

	_log do $FUNC daemon info "SPEED_AVG=$SPEED_AVG - $VALUES"
	echo "$VALUES" >"$DIR/$TIME"
	echo "$SAMPLES $SPEED_AVG $SPEED_MIN $SPEED_MAX $SPEED_SUM" >"$DIR/stats"
}

_speedtest_stats ()
{
	local IP_LOCAL="$1"
	local KEYWORD="$2"
	local METHOD="$3"
	local DIR="/tmp/STATS/SPEEDTEST"

	# SAMPLES SPEED_AVG SPEED_MIN SPEED_MAX SPEED_SUM
	
	:
}
