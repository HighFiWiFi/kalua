_tunnel_check_local_capable()
{
	test -e "/usr/sbin/vtund"	# later: memory, etc.
}

_tunnel_build()
{
	local action="$1"	# up|down
}

_tunnel_id2ip()
{
	local id="$1"
	local tunnel_side="$2"
	local ipstart="192.168.200"		# mask is always /30 for each tunnel
	local broadcast=0			# id=1
	local n=1
							# fixme! block capable(), if max is full
	while [ $n -lt $id ]; do {
		broadcast=$(( $broadcast + 4 ))		# max of 64 tunnels (=256/4)
		n=$(( $n + 1 ))
	} done

	case "$tunnel_side" in
		server)
			echo "$ipstart.$(( $broadcast + 1 ))"
		;;
		client)
			echo "$ipstart.$(( $broadcast + 2 ))"
		;;
	esac
}

_tunnel_config_build()				# on client
{
	local tunnel_id="$1"
	local mac="$2"
	local ipuser="$3"
	local option="$4"			# e.g. 'ignore_intranet_traffic' 	// idea: having an extra tunnel for this

	local storage="/tmp/tunnel"		# todo: always use tunnel_name for TABLE
	mkdir -p "$storage"

	local mask="30"
	local mtu="1450"
	local password="ff"

	local bin_logger="$( which logger )"
	local bin_ip="$( which ip )"
	local bin_echo="$( which echo )"
	local bin_sed="$( which sed )"
	mkdir /var/log/vtund			# for stats

	local name message rt_num logerror prio_first prio_last table_intranet intranet

	intranet="10.0.0.0/8"			# fixme!
	rt_num="$(( 150 + $tunnel_id ))"
	name="$( _sanitizer do "$mac" hostname )"
	message="id $tunnel_id conn $name dev %% for user $ipuser"	# speed unknown, send from server?
	logerror="logger -t tunnel_HELPER -p daemon.err $message "

	prio1="$3${tunnel_id}0"		# e.g. 3 + 152 + 0 = 31520
	prio2="$3{tunnel_id}1"		# e.g. 3 + 152 + 1 = 31521

	case "$option" in
		ignore_intranet_traffic)
			table_intranet="main"
		;;
		*)
			table_intranet="$mac"
		;;
	esac

	cat <<EOF
$name {
	type tun;
	proto udp;
	password ff;
	persist yes;
	stat yes;

	up {
		program $bin_logger "-t tunnel_clientUP -p daemon.info [START] $message" wait;

		program "$bin_ip address add $( _tunnel id2ip $tunnel_id client )/$mask dev %%" wait;
		program "$bin_ip link set dev %% mtu $mtu up" wait;

		program "$bin_echo $rt_num $mac >>/etc/iproute2/rt_tables" wait;
		program "$bin_ip rule add from $ipuser to $intranet prio $prio1 table $table_intranet" wait;
		program "$bin_ip rule add from $ipuser prio $prio2 table $mac" wait;

		program "$bin_ip route add default via $( _tunnel id2ip $tunnel_id server ) dev %% table $mac" wait;
		program "$bin_ip route flush cache" wait;

		program $bin_logger "-t tunnel_clientUP -p daemon.info [READY] $message" wait;
	};

	down {
		program $bin_logger "-t tunnel_clientDOWN -p daemon.info [START] $message" wait;

		program "$bin_ip route del default via $( _tunnel id2ip $tunnel_id server ) dev %% table $mac" wait;

		program "$bin_ip rule del from $ipuser prio $prio2 table $mac" wait;
		program "$bin_ip rule del from $ipuser to $intranet prio $prio1 table $table_intranet" wait;
		program "$bin_sed -i '/^$rt_num /d' /etc/iproute2/rt_tables" wait;

		program "$bin_ip route flush cache" wait;

		program "$bin_ip link set dev %% down" wait;
		program "$bin_ip address del $( _tunnel id2ip $tunnel_id client )/$mask dev %%" wait;

		program $bin_logger "-t tunnel_clientDOWN -p daemon.info [READY] $message" wait;
	};
}
EOF
}

_tunnel_config_insert_new_client()		# on server
{
	local tunnel_id="$1"
	local mac="$2"
	local ipuser="$3"
	local speed_upload="$4"
	local speed_download="$5"
	local storage="/tmp/tunnel"
	local speed

	mkdir -p "$storage"

	if   [ -z "$speed_upload" ]; then
		speed="0"					# no shaping at all
	elif [ -z "$speed_download" ]; then
		speed="$speed_upload:$speed_upload"		# up/down is symetric (follows vtun syntax idea)
	else
		speed="$speed_download:$speed_upload"		# normal vtun-syntax
	fi

	echo "$tunnel_id $mac $ipuser $speed" >"$storage/$mac"
}

_tunnel_config_rebuild()			# on server: we have to join many user/connections
{
	local storage="/tmp/tunnel"
	local option="$1"								# e.g. 'ignore_intranet_traffic'
	local list_tunnel="$( ls -1 "$storage" | grep ..:..:..:..:..:.. )"		# these are files named like macadresses
	local tunnel tunnel_id mac ipuser speed name message rt_num compress
	local prio1 prio2 intranet intranet_table

	local mask="30"
	local mtu="1450"
	local password="ff"

	local bin_logger="$( which logger )"
	local bin_ip="$( which ip )"
	local bin_echo="$( which echo )"
	local bin_sed="$( which sed )"
	mkdir -p /var/log/vtund				# for stats

	for tunnel in $list_tunnel; do {				# todo: log memory, avoid compression for loopback-conns

		tunnel_id=; mac=; ipuser=; speed=
		read tunnel_id mac ipuser speed <"$storage/$tunnel" 

		rt_num="$(( 50 + $tunnel_id ))"
		name="$( _sanitizer do "$tunnel" hostname )"
		message="id $tunnel_id conn $name dev %% for user $ipuser with speed $speed"

		prio1="$3${tunnel_id}0"		# e.g. 3 + 152 + 0 = 31520
		prio2="$3${tunnel_id}1"		# e.g. 3 + 152 + 0 = 31521

		case "$tunnel" in
			00:08:c6*)
				compress="no"
			;;
			*)
				compress="lzo:9"
			;;
		esac

		intranet="10.0.0.0/8"			# fixme!
		case "$option" in
			ignore_intranet_traffic)
				intranet_table="main"
			;;
			*)
				intranet_table="$mac"
			;;
		esac

		logerror="logger -t tunnel_HELPER -p daemon.err $message "

		cat <<EOF
$name {
	compress $compress;
	encrypt no;
	speed $speed;
	stat yes;

	type tun;
	proto udp;
	passwd $password;

	up {
		program $bin_logger "-t tunnel_serverUP -p daemon.info [START] $message" wait;

		program "$bin_ip address add $( _tunnel id2ip $tunnel_id server )/$mask dev %%" wait;
		program "$bin_ip link set dev %% mtu $mtu up" wait;

		program "$bin_echo $rt_num $mac >>/etc/iproute2/rt_tables" wait;
		program "$bin_ip rule add to $ipuser from $intranet prio $prio1 table $intranet_table" wait;
		program "$bin_ip rule add to $ipuser prio $prio2 table $mac" wait;

		program "$bin_ip route add default via $( _tunnel id2ip $tunnel_id client ) dev %% table $mac" wait;
		program "$bin_ip route flush cache" wait;

		program $bin_logger "-t tunnel_serverUP -p daemon.info [READY] $message" wait;
	};

	down {
		program $bin_logger "-t tunnel_serverDOWN -p daemon.info [START] $message" wait;

		program "$bin_ip route del default via $( _tunnel id2ip $tunnel_id client ) dev %% table $mac" wait;
		program "$bin_ip rule del to $ipuser prio $prio2 table $mac" wait;
		program "$bin_ip rule del to $ipuser from $intranet prio $prio1 table $intranet_table" wait;

		program "$bin_sed -i '/^$rt_num /d' /etc/iproute2/rt_tables" wait;

		program "$bin_ip route flush cache" wait;

		program "$bin_ip link set dev %% down" wait;
		program "$bin_ip address del $( _tunnel id2ip $tunnel_id server )/$mask dev %%" wait;

		program $bin_logger "-t tunnel_serverDOWN -p daemon.info [READY] $message" wait;
	};
}

EOF

	} done
}

_tunnel_daemon_apply_config()
{
	local file_config="$1"
	local pidfile="/tmp/tunnel/vtund.pid"
	local pid cmdline

	if [ -e "$pidfile" ]; then
		read pid <"$pidfile"
		read cmdline <"/proc/${pid:-unset}/cmdline"
	else
		pid="$( _system get_first_pid vtund )"
		read cmdline <"/proc/${pid:-unset}/cmdline"
	fi

	case "$cmdline" in
		vtund*)
			kill -SIGHUP $pid
		;;
		*)
			vtund -s -f "$file_config"
			_system get_first_pid vtund >"$pidfile"
		;;
	esac
}

_tunnel_clientside_control()
{
	local funcname="tunnel_clientside_control"
	local action="${1:-action_unset}"
	local mac="${2:-mac_unset}"
	local ip="${3:-ip_unset}"

	case "$( uci get system.@profile[0].name )" in
		liszt28*)
		;;
		*)
			return 1
		;;
	esac

	case "$mac" in
		99:99:99:99:99:*)		# the reserve chains...
			return 1
		;;
	esac

	_tunnel check_local_capable || {
		_log do $funcname daemon info "tunnel for $mac / $ip locally not capable"
		return 1
	}

	local storage="/tmp/tunnel"
	local configfile="$storage/${mac}.conf"
	local tunnel_id tunnel_name dummy answer url pid tunnel_server process_output file list_files
	local TRUE FALSE TUNNEL_IP_CLIENT TUNNEL_IP_SERVER SPEED_UPLOAD SPEED_DOWNLOAD

	case "$action" in
		check_connection)

			case "$mac" in
				all)
					list_files="$( ls -1 "$storage/"*.conf | grep ..:..:..:..:..:.. )"
				;;
				*)
					list_files="$mac"
				;;
			esac

			for file in $list_files; do {
				read tunnel_name dummy <"$file"
				_log do $funcname daemon info "$action: checking conn $tunnel_name in file $file"

				process_output="$( ps ax | fgrep "vtund[c]: $tunnel_name connecting to" | fgrep -v "fgrep" | head -n1 )"
				[ -n "$process_output" ] && {
						read tunnel_server <"/tmp/GATEWAY_CHECK_RECENT_GATEWAY_IP_ONLY"

						[ -z "$tunnel_server" ] && {
							_log do $funcname daemon info "tunnel for $mac / $ip fails, no gateway/server found"
							break
						}

						ip="$(  _sanitizer do "$( cat "$file" )" ip4 | head -n2 | tail -n1 )"
						mac="$( _sanitizer do "$( cat "$file" )" mac | head -n1 )"

						_log do $funcname daemon info "awake tunnel $tunnel_name for mac $mac and ip $ip"
						url="http://$tunnel_server/cgi-bin-tunnel.sh?ACTION=tunnel_possible&MAC=${mac}&IP_USER=${ip}"
						answer="$( _wget do "$url" 3 )"
				}
			} done
		;;
		start)
			read tunnel_server <"/tmp/GATEWAY_CHECK_RECENT_GATEWAY_IP_ONLY"

			[ -z "$tunnel_server" ] && {
				_log do $funcname daemon info "tunnel for $mac / $ip fails, no gateway/server found"
				return 1
			}

			url="http://$tunnel_server/cgi-bin-tunnel.sh?ACTION=tunnel_possible&MAC=${mac}&IP_USER=${ip}"
			answer="$( _wget do "$url" 3 )"

			case "$answer" in
				TRUE*)
					_watch counter "/tmp/tunnel_id" increment 1 max 65 || {
						_log do $funcname daemon info "[ERR] maximum tunnel instances reached, aborting"
						return 1
					}
					read tunnel_id </tmp/tunnel_id

					mkdir -p /tmp/tunnel
					_tunnel config_build $tunnel_id "$mac" "$ip" >"$configfile"
					read tunnel_name dummy <"$configfile"

					vtund -f "$configfile" "$tunnel_name" "$tunnel_server"

					_log do $funcname daemon info "[OK] prepared tunnel for $mac / $ip"
				;;
				*)
					_log do $funcname daemon info "[ERR] tunnel for $mac / $ip not possible, answer from $tunnel_server: '$answer' question: '$url'"
				;;
			esac
		;;
		stop)
			_log do $funcname daemon info "[OK] stopping tunnel for $mac / $ip"
			rm "$configfile"

			read tunnel_name dummy <"$configfile"									# normal output of ps: 'S <  vtund[c]: 001500189266 tun tun0'
			process_output="$( ps ax | fgrep "$tunnel_name" | grep -v "fgrep" | fgrep vtund | head -n1 )"		# fixme! there must be a better way...
			set ${process_output:-empty_process_output}								# running into bg with & and reading $!
			pid="$1"												# does not work - maybe writing pid during section up{...}?

			kill "${pid:-unset}"
		;;
	esac
}
_pfilter_shaping_tunnel_control()		# maybe job-schedule only? move to tunnel() _tunnel clientside_control()
{
	local funcname="pfilter_shaping_tunnel_control"
	local action="${1:-action_unset}"
	local mac="${2:-mac_unset}"
	local ip="${3:-ip_unset}"

	case "$( uci get system.@profile[0].name )" in
		liszt28*)
		;;
		*)
			return 1
		;;
	esac

	case "$mac" in
		99:99:99:99:99:*)		# the reserve chains...
			return 1
		;;
	esac

	_tunnel check_local_capable || {
		_log do $funcname daemon info "tunnel for $mac / $ip locally not capable"
		return 1
	}

	local storage="/tmp/tunnel"
	local configfile="$storage/${mac}.conf"
	local tunnel_id tunnel_name dummy answer url pid tunnel_server process_output file list_files
	local TRUE FALSE TUNNEL_IP_CLIENT TUNNEL_IP_SERVER SPEED_UPLOAD SPEED_DOWNLOAD

	case "$action" in
		check_connection)

			case "$mac" in
				all)
					list_files="$( ls -1 "$storage/"*.conf | grep ..:..:..:..:..:.. )"
				;;
				*)
					list_files="$mac"
				;;
			esac

			for file in $list_files; do {
				read tunnel_name dummy <"$file"
				_log do $funcname daemon info "$action: checking conn $tunnel_name in file $file"

				process_output="$( ps ax | fgrep "vtund[c]: $tunnel_name connecting to" | fgrep -v "fgrep" | head -n1 )"
				[ -n "$process_output" ] && {
						read tunnel_server <"/tmp/GATEWAY_CHECK_RECENT_GATEWAY_IP_ONLY"

						[ -z "$tunnel_server" ] && {
							_log do $funcname daemon info "tunnel for $mac / $ip fails, no gateway/server found"
							break
						}

						ip="$(  _sanitizer do "$( cat "$file" )" ip4 | head -n2 | tail -n1 )"
						mac="$( _sanitizer do "$( cat "$file" )" mac | head -n1 )"

						url="http://$tunnel_server/cgi-bin-tunnel.sh?ACTION=tunnel_possible&MAC=${mac}&IP_USER=${ip}"
						answer="$( _wget do "$url" 3 )"
				}
			} done
		;;
		start)
			read tunnel_server <"/tmp/GATEWAY_CHECK_RECENT_GATEWAY_IP_ONLY"

			[ -z "$tunnel_server" ] && {
				_log do $funcname daemon info "tunnel for $mac / $ip fails, no gateway/server found"
				return 1
			}

			url="http://$tunnel_server/cgi-bin-tunnel.sh?ACTION=tunnel_possible&MAC=${mac}&IP_USER=${ip}"
			answer="$( _wget do "$url" 3 )"

			case "$answer" in
				TRUE*)
					_watch counter "/tmp/tunnel_id" increment 1 max 65 || {
						_log do $funcname daemon info "[ERR] maximum tunnel instances reached, aborting"
						return 1
					}
					read tunnel_id </tmp/tunnel_id

					mkdir -p /tmp/tunnel
					_tunnel config_build $tunnel_id "$mac" "$ip" "ignore_intranet_traffic" >"$configfile"		# fixme! needs an config option
					read tunnel_name dummy <"$configfile"

					vtund -f "$configfile" "$tunnel_name" "$tunnel_server"

					_log do $funcname daemon info "[OK] prepared tunnel for $mac / $ip"
				;;
				*)
					_log do $funcname daemon info "[ERR] tunnel for $mac / $ip not possible, answer from $tunnel_server: '$answer' question: '$url'"
				;;
			esac
		;;
		stop)
			_log do $funcname daemon info "[OK] stopping tunnel for $mac / $ip"
			rm "$configfile"

			read tunnel_name dummy <"$configfile"									# normal output of ps: 'S <  vtund[c]: 001500189266 tun tun0'
			process_output="$( ps ax | fgrep "$tunnel_name" | grep -v "fgrep" | fgrep vtund | head -n1 )"		# fixme! there must be a better way...
			set ${process_output:-empty_process_output}								# running into bg with & and reading $!
			pid="$1"												# does not work - maybe writing pid during section up{...}?

			kill "${pid:-unset}"
		;;
	esac
}
