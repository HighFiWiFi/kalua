_tunnel_check_local_capable()
{
	test -e "/usr/sbin/vtund"	# later: memory, etc.
}

_tunnel_build()
{
	local action="$1"	# up|down
}

_tunnel_id2ip()
{
	local id="$1"
	local tunnel_side="$2"
	local ipstart="192.168.200"		# mask is always /30 for each tunnel
	local broadcast=0			# id=1
	local n=1
							# fixme! block capable(), if max is full
	while [ $n -lt $id ]; do {
		broadcast=$(( $broadcast + 4 ))		# max of 64 tunnels (=256/4)
		n=$(( $n + 1 ))
	} done

	case "$tunnel_side" in
		server)
			echo "$ipstart.$(( $broadcast + 1 ))"
		;;
		client)
			echo "$ipstart.$(( $broadcast + 2 ))"
		;;
	esac
}

_tunnel_config_build()				# on client
{
	local tunnel_id="$1"
	local mac="$2"
	local ipuser="$3"

	local storage="/tmp/tunnel"		# todo: always use tunnel_name for TABLE
	mkdir -p "$storage"

	local mask="30"
	local mtu="1450"
	local password="ff"

	local bin_logger="$( which logger )"
	local bin_ip="$( which ip )"
	local bin_echo="$( which echo )"
	local bin_sed="$( which sed )"
	mkdir /var/log/vtund			# for stats

	local name message rt_num logerror

	rt_num="$(( 150 + $tunnel_id ))"
	name="$( _sanitizer do "$mac" hostname )"
	message="id $tunnel_id conn $name dev %% for user $ipuser"	# speed unknown, send from server?
	logerror="logger -t tunnel_HELPER -p daemon.err $message "

	cat <<EOF
$name {
	type tun;
	proto udp;
	password ff;
	persist yes;
	stat yes;

	up {
		program $bin_logger "-t tunnel_clientUP -p daemon.info [START] $message" wait;

		program "$bin_ip address add $( _tunnel id2ip $tunnel_id client )/$mask dev %%" wait;
		program "$bin_ip link set dev %% mtu $mtu up" wait;

		program "$bin_echo $rt_num $mac >>/etc/iproute2/rt_tables" wait;
		program "$bin_ip rule add from $ipuser prio $(( 30000 + $tunnel_id )) table $mac" wait;

# not needed?	ip rule add to 10.63.6.8 prio 30001 table main
# todo: bypass intranet-traffic (no shaping)
		program "$bin_ip route add default via $( _tunnel id2ip $tunnel_id server ) dev %% table $mac" wait;
		program "$bin_ip route flush cache" wait;

		program $bin_logger "-t tunnel_clientUP -p daemon.info [READY] $message" wait;
	};

	down {
		program $bin_logger "-t tunnel_clientDOWN -p daemon.info [START] $message" wait;

		program "$bin_ip route del default via $( _tunnel id2ip $tunnel_id server ) dev %% table $mac" wait;

# not needed?	ip rule del to 10.63.6.8 prio 30001 table main

		program "$bin_ip rule del from $ipuser prio $(( 30000 + $tunnel_id )) table $mac" wait;
		program "$bin_sed -i '/^$rt_num /d' /etc/iproute2/rt_tables" wait;
		program "$bin_ip route flush cache" wait;

		program "$bin_ip link set dev %% down" wait;
		program "$bin_ip address del $( _tunnel id2ip $tunnel_id client )/$mask dev %%" wait;

		program $bin_logger "-t tunnel_clientDOWN -p daemon.info [READY] $message" wait;
	};
}
EOF
}

_tunnel_config_insert_new_client()		# on server
{
	local tunnel_id="$1"
	local mac="$2"
	local ipuser="$3"
	local speed_upload="$4"
	local speed_download="$5"
	local storage="/tmp/tunnel"
	local speed

	mkdir -p "$storage"

	if   [ -z "$speed_upload" ]; then
		speed="0"					# no shaping at all
	elif [ -z "$speed_download" ]; then
		speed="$speed_upload:$speed_upload"		# up/down is symetric (follows vtun idea)
	else
		speed="$speed_download:$speed_upload"		# normal vtun-syntax
	fi

	echo "$tunnel_id $mac $ipuser $speed" >"$storage/$mac"
}

_tunnel_config_rebuild()			# on server: we have to join many user/connections
{
	local storage="/tmp/tunnel"
	local list_tunnel="$( ls -1 "$storage" | grep ..:..:..:..:..:.. )"		# these are files named like macadresses
	local tunnel tunnel_id mac ipuser speed name message rt_num

	local mask="30"
	local mtu="1450"
	local password="ff"

	local bin_logger="$( which logger )"
	local bin_ip="$( which ip )"
	local bin_echo="$( which echo )"
	local bin_sed="$( which sed )"
	mkdir -p /var/log/vtund				# for stats

	for tunnel in $list_tunnel; do {				# todo: log memory, avoid compression for loopback-conns

		tunnel_id=; mac=; ipuser=; speed=
		read tunnel_id mac ipuser speed <"$storage/$tunnel" 

		rt_num="$(( 50 + $tunnel_id ))"
		name="$( _sanitizer do "$tunnel" hostname )"
		message="id $tunnel_id conn $name dev %% for user $ipuser with speed $speed"

		logerror="logger -t tunnel_HELPER -p daemon.err $message "

		cat <<EOF
$name {
	compress lzo:9;
	encrypt no;
	speed $speed;
	stat yes;

	type tun;
	proto udp;
	passwd $password;

	up {
		program $bin_logger "-t tunnel_serverUP -p daemon.info [START] $message" wait;

		program "$bin_ip address add $( _tunnel id2ip $tunnel_id server )/$mask dev %%" wait;
		program "$bin_ip link set dev %% mtu $mtu up" wait;

		program "$bin_echo $rt_num $mac >>/etc/iproute2/rt_tables" wait;
		program "$bin_ip rule add to $ipuser table $mac" wait;
		program "$bin_ip route add default via $( _tunnel id2ip $tunnel_id client ) dev %% table $mac" wait;
		program "$bin_ip route flush cache" wait;

		program $bin_logger "-t tunnel_serverUP -p daemon.info [READY] $message" wait;
	};

	down {
		program $bin_logger "-t tunnel_serverDOWN -p daemon.info [START] $message" wait;

		program "$bin_ip route del default via $( _tunnel id2ip $tunnel_id client ) dev %% table $mac" wait;
		program "$bin_ip rule del to $ipuser table $mac" wait;
		program "$bin_sed -i '/^$rt_num /d' /etc/iproute2/rt_tables" wait;
		program "$bin_ip route flush cache" wait;

		program "$bin_ip link set dev %% down" wait;
		program "$bin_ip address del $( _tunnel id2ip $tunnel_id server )/$mask dev %%" wait;

		program $bin_logger "-t tunnel_serverDOWN -p daemon.info [READY] $message" wait;
	};
}

EOF

	} done
}

_tunnel_daemon_apply_config()
{
	local file_config="$1"
	local pidfile="/tmp/tunnel/vtund.pid"
	local pid cmdline

	if [ -e "$pidfile" ]; then
		read pid <"$pidfile"
		read cmdline <"/proc/${pid:-unset}/cmdline"
	else
		pid="$( _system get_first_pid vtund )"
		read cmdline <"/proc/${pid:-unset}/cmdline"
	fi

	case "$cmdline" in
		vtund*)
			kill -SIGHUP $pid
		;;
		*)
			vtund -s -f "$file_config"
			_system get_first_pid vtund >"$pidfile"
		;;
	esac
}

