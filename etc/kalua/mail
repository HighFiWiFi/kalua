# _mail send "bittorf wireless )) Breitband Rehungen" "breitband-rehungen@gmx.de" "ANREDE VORNAME NACHNAME" "bittorf@bluebottle.com" "mail3-2010aug26-nach_Zusendung_Vertrag.txt" "STRASSE HAUSNUMMER" "ANREDE VORNAME" "NACHNAME" "/tmp/wlansystem-HotelZumnorde-2010aug05_16uhr42-32x1-Wochen-Ticket-Etiketten.pdf wlansystem-HotelZumnorde-2010aug05_16uhr42-32x1-Wochen-Ticket-Etiketten.pdf"

_mail_pop3_check_stats ()	# works with busybox-netcat
{
	local   FUNC="mail_check_pop3_stats"
	local   USER="$( nvram get fff_mail_user )"
	local   PASS="$( nvram get fff_mail_pass )"
	local    OUT=""
	local   LINE
	local NETCAT="nc"
	local SERVER="$( nvram get fff_mail_server_pop3 )"
	local   PORT="$( nvram get fff_mail_server_pop3_port )"
	local     RC=0
	local WINDOW=600						# fixme! time in seconds, when pop_before_smtp is valid, unused!

	_log do $FUNC user notice "sending data to '$SERVER'"

	OUT="$( echo -e "USER $USER\nPASS $PASS\nSTAT\nQUIT\n" | $NETCAT $SERVER $PORT )"
	RC=$?

	OUT="$( echo "$OUT" | cut -d' ' -f1 | while read LINE; do echo -n "$LINE"; done )"	# fixme! use sanitizer, removes LF/CR

	case "$OUT" in
		"+OK+OK+OK"*) return 0 ;;	# if all went fine we get 3 x OK (or more)
	esac

	[ $RC -eq 0 ] || {
		_log do $FUNC user crit "returncode: '$RC' - '$SERVER'-answer: '$OUT' - something went wrong"
	}
}

_mail_send ()		# todo: we need a simple addressbook for phone,email,shortname,name...
{
	local           FUNC="mail_send"
	local      FROM_REAL="$1"	# ARG1, string (name,  format: title, surname name  )
	local      FROM_MAIL="$2"	# ARG2, string (email, format: recipient@domain.foo )
	local RECIPIENT_REAL="$3"	# ARG3, string (name)
	local RECIPIENT_MAIL="$4"	# ARG4, string (email)
	local       MAILFILE="$5"	# ARG5, string (name of file with body-text and variables)
	local           VAR1="$6"	# ARG6, string (user-defineable, for using in mail.txt)
	local           VAR2="$7"	# ARG7, string
	local           VAR3="$8"	# ARG8, string
	local      LIST_FILE="$9"
	local FILE

	[ ! -e "$MAILFILE" ] && {
		_log do $FUNC user crit "can't read '$MAILFILE' - aborting (usage: _$FUNC myname me@world.org yourname you@world.org mailfile"
		return
	}

	local SUBJECT="$( head -n1 $MAILFILE | sed "s#\$VAR1#$VAR1#g" )"
	local OUT LINE
	local NETCAT="nc"
	local SERVER="$( nvram get fff_mail_server_smtp )"
	local PORT="$( nvram get fff_mail_server_smtp_port )"
	local RC=0
	local FQDN="$( nvram get wan_hostname ).local"
	local ADMIN_REAL="$( nvram get ff_adm_name )"
	local ADMIN_MAIL="$( nvram get ff_adm_mail )"
	local MAIL="/tmp/outgoing_mail_$( _system date humanreadable nice )"
	local BOUNDARY="dc+cDN39EJAMEtIO"					# maybe random?

	_mail pop3_check_stats			# pop before smtp must be configured on mailserver
	_log do $FUNC daemon debug "[BEGIN]"

	_do ()
	{
		case "$1" in
			init)
				[ -e "$MAIL" ] && rm "$MAIL"
			;;
			linefeed)
				echo >>$MAIL -n "\n"
			;;
			*)
				echo >>$MAIL -n "$1\r\n"
			;;
		esac
	}

	_do init	
	_do "HELO ${FQDN}"
	_do "MAIL FROM: \"${FROM_REAL}\" <${FROM_MAIL}>"
	_do "RCPT TO: \"${RECIPIENT_REAL}\" <${RECIPIENT_MAIL}>"
	_do "DATA"
	_do "From: \"${FROM_REAL}\" <${FROM_MAIL}>"
	_do "To: \"${RECIPIENT_REAL}\" <${RECIPIENT_MAIL}>"			# can be multiple RCPT's:
#	_do "Cc: \"${ADMIN_REAL}\" <${ADMIN_MAIL}>"

	_do "Date: $( _system date mail )"
	_do "Message-ID: <$( date +%s%d%b%y-%H_%M )@${FQDN}>"			# 121016909907May08-16_04@buffalo422.local

	_do "MIME-Version: 1.0"
	_do "Content-Type: multipart/mixed; boundary=\"${BOUNDARY}\""
	_do "Content-Disposition: inline"
	_do "Content-Transfer-Encoding: 8bit"

	_do "Organization: ${ADMIN_REAL}"
	_do "Reply-To: \"${ADMIN_REAL}\" <${ADMIN_MAIL}>"
	_do "X-Mailer: netcat $( $NETCAT --help 2>&1 | grep -i " v" )"
	_do "X-Operating-System: $( cat /proc/version )"
	_do "X-Firmware: $FFF_VERSION / $FFF_PLUS_VERSION / $( grep ^Kit: /etc/freifunk-release )"
	_do "Subject: ${SUBJECT}\r\n"
	_do linefeed

	_do "--${BOUNDARY}"
	_do "Content-Type: text/plain; charset=iso-8859-1"
	_do "Content-Disposition: inline"
	_do "Content-Transfer-Encoding: 8bit"
	_do ""

	IFS="
"
						# 1st/2nd line subject/empty
	sed '3,99!d' $MAILFILE |
	 sed	-e "s#\$VAR1#$VAR1#g" \
		-e "s#\$VAR2#$VAR2#g" \
	 	-e "s#\$VAR3#$VAR3#g" |
	  while read LINE; do {
	  	_do "$LINE"
	  } done

	unset IFS

	_do ""

	for FILE in $LIST_FILE; do {
		_do "--${BOUNDARY}"
		_do "Content-Type: $( _filetype detect_mimetype "$FILE" )"

		[ -e "$FILE.desc" ] && {
			_do "Content-Description: $( cat "$FILE.desc" )"
		}

		_do "Content-Disposition: attachment; filename=\"$( basename "$FILE" )\""
		_do "Content-Transfer-Encoding: quoted-printable"
		_do ""

		_mail encode_quoted_printable "$FILE" >>$MAIL
		_do ""
	} done

	[ -n "$FILE" ] && {
		_do "--${BOUNDARY}--"
	}

	_do "."
	_do "QUIT"

	_log do $FUNC daemon info "sending mail to '${RECIPIENT_MAIL}'"

	OUT="$( echo -e "$( cat $MAIL )" | $NETCAT $SERVER $PORT )"
	RC=$?
	OUT="$( echo "$OUT" | strings | sed -e 's/ //g' -e 's/^\([0-9]*\).*$/\1_/' | while read LINE; do echo -n "$LINE"; done )"	# extract error-codes + remove LF/CR

												# fixme! for each RCPT we must add an "2502_"
	if [ $RC -ne 0 ] || [ "$OUT" != "220_250_2502_2502_354_2502_2212_" ]; then		# error-codes, when all went fine (RCPT=OK=2502)

		_log do $FUNC user crit "error for recipient '${RECIPIENT_MAIL}': returncode: '$RC' - '$SERVER'-answer: '$OUT' - debug file '$MAIL'"
	else
		_log do $FUNC user notice "sent mail to '$RECIPIENT_MAIL' went fine"
		rm "$MAIL"
	fi
}

_mail_encode_quoted_printable ()	# http://en.wikipedia.org/wiki/Quoted-printable#Example | http://tools.ietf.org/html/rfc2045
{					# http://rand-mh.sourceforge.net/book/overall/mulmes.html
	local FUNC="mail_encode_quoted_printable"

	local FILE="$1"			# fixme! there is no check for special chars, done already:
	local WRAP=75			# - tab/space at the end of a line to '=09' / '=20'
	local BUFFER="$WRAP"		# - newlines to '=0A'
	local WINDOWSTART=1		# - linewrap at 75 column + a softbreak '='
	local LINE OUTPUT		# - encoded special chars must not be line-wrapped

	_stopwatch start $FUNC

	IFS="
"
#	sed -e 's/	$/=09/' -e 's/ $/=20/' -e 's/$/=0A/' "$FILE" | while read LINE; do {
	sed 's/$/=0A/' "$FILE" | while read LINE; do {

		while true; do {

			case $LINE in
				"."*) LINE="=2E$( echo "$LINE" | cut -b 2-9999 )"
			esac

			if [ ${#LINE} -lt $BUFFER ]; then

				echo -n "$LINE"
				BUFFER=$(( $BUFFER - ${#LINE} ))
				break		# fetch next LINE

			elif [ ${#LINE} -eq $BUFFER ]; then

				echo "${LINE}="
				BUFFER=$WRAP
				break		# fetch next LINE
			else
				OUTPUT="$( echo "$LINE" | cut -b $WINDOWSTART-$BUFFER )"

				  if echo "$OUTPUT" | grep -q =$ ; then		# =A0 at the end (encoded) must not be wrapped
					BUFFER=$(( $BUFFER - 1 ))
					OUTPUT="$( echo "$OUTPUT" | cut -b $WINDOWSTART-$BUFFER )"					
				elif echo "$OUTPUT" | grep -q =.$ ; then
					BUFFER=$(( $BUFFER - 2 ))
					OUTPUT="$( echo "$OUTPUT" | cut -b $WINDOWSTART-$BUFFER )"
				elif echo "$OUTPUT" | grep -q =..$ ; then
					BUFFER=$(( $BUFFER - 3 ))
					OUTPUT="$( echo "$OUTPUT" | cut -b $WINDOWSTART-$BUFFER )"	
				fi

				echo "${OUTPUT}="
				LINE="$( echo "$LINE" | cut -b $(( $BUFFER + 1 ))-9999 )"	# idea: simply raise startcounter
				BUFFER=$WRAP
			fi

		} done

	} done

	unset IFS

	_stopwatch stop $FUNC quiet
}
