_pdf_filename ()
{
	local TYPE="$1"		# string: overview|labels|csv
	local COUNT="$2"	# integer: 32
	local NAME="$3"		# 1-Stunden-Tickets
	local LANG="$4"		# fixme!

	local FILENAME WORD EXTENSION

	case $TYPE in
		overview) WORD="-Uebersicht"; EXTENSION="pdf" ;;
		labels)	  WORD="-Etiketten" ; EXTENSION="pdf" ;;
		csv)	  WORD="-Excel"	    ; EXTENSION="csv" ;;
		*)	  WORD=""	    ; EXTENSION="txt" ;;
	esac

	FILENAME="wlansystem-$( _weblogin metadata_locationname )-$( _system date humanreadable )-${COUNT}x${NAME}${WORD}.${EXTENSION}"

	echo "$FILENAME" | sed -e 's/ //g' -e 's/:/uhr/g'	# strip spaces, replace ":" - fixme! is a hack
}

_pdf_output ()
{
	local METHOD="$1"			# a4digest|a4marker
	local LIST_LOGIN_ID="$2"

	local FUNC="pdf_output"
	local TEMPFILE="/tmp/${FUNC}_${METHOD}_$$"
	local FILEPART

	_log do $FUNC daemon info "[START] generating A4-page ($METHOD) with these logins: '$( _sanitizer do "$LIST_LOGIN_ID" newlines2spaces )'"

	_pdf output_${METHOD}_body "$LIST_LOGIN_ID"		>$TEMPFILE.body
	SIZE_BODY="$( _file size "$TEMPFILE.body" )"

	_pdf output_header $SIZE_BODY				>$TEMPFILE.header
	SIZE_HEADER="$( _file size "$TEMPFILE.header" )"

	_pdf output_footer $(( $SIZE_BODY + SIZE_HEADER ))	>$TEMPFILE.footer

	for FILEPART in header body footer; do {
		cat $TEMPFILE.$FILEPART
		rm $TEMPFILE.$FILEPART
	} done

	_log do $FUNC daemon info "[OK] generated PDF ($METHOD)"
}

_pdf_output_a4digest_body ()
{
	local LIST_LOGIN_ID="$1"

	local FUNC="output_a4digest_body"
	local MAXLINES=32			# then A4 is full
	local FONTSIZE X XY ID NAME
	local Y=718
	local Y_STEP=21
	local Y_MARGIN=5
	local YSTART=$Y
	local RECORD=0
	local ID

	local X0=25
	local X1=35
	local X2=160
	local X3=170
	local X4=250
	local X5=260
	local X6=470
	local X7=480
	local X8=570

	FONTSIZE=24

	HOTELNAME="$( _weblogin metadata_locationname )"
	XY="$(( 600 - ( 13 * ${#HOTELNAME}) )) 800"		# not exact, but works (proportional font!)
	echo "BT $XY TD /F1 $FONTSIZE Tf ($HOTELNAME)Tj ET"

	for ID in $LIST_LOGIN_ID; do {				# fetch profilename from first ticket
		eval $( _db user login show $ID "PROFILE_ID" )
		eval $( _db user profile show $PROFILE_ID "NAME" )
		break
	} done	

	XY="$X0 740"
	FONTSIZE=8	
	echo "BT $XY TD /F1 $FONTSIZE Tf (Zeitpunkt der automatischen Generierung: $( _system date humanreadable nice ))Tj ET"

	FONTSIZE=18

	Y_FONT="$(( $Y + $Y_MARGIN - $Y_STEP ))"

	cat <<EOF
BT $X1 $Y_FONT TD /F1 $FONTSIZE Tf (Benutzername)Tj ET
BT $X3 $Y_FONT TD /F1 $FONTSIZE Tf (Passwort)Tj ET
BT $X5 $Y_FONT TD /F1 $FONTSIZE Tf (Zimmernummer/Gastname)Tj ET
BT $X7 $Y_FONT TD /F1 $FONTSIZE Tf (Kommentar)Tj ET
EOF

	for ID in $LIST_LOGIN_ID; do {

		[ $RECORD -eq $MAXLINES ] && break
		RECORD=$(( $RECORD + 1 ))

		Y=$(( $Y - $Y_STEP ))
		Y_FONT="$(( $Y + $Y_MARGIN - $Y_STEP ))"

		eval $( _db user login show $ID "USERNAME PASSWORD" )

				# username/password + horizontal_line
		cat <<EOF
BT $X1 $Y_FONT TD /F1 $FONTSIZE Tf ($USERNAME)Tj ET
BT $X3 $Y_FONT TD /F1 $FONTSIZE Tf ($PASSWORD)Tj ET
$X0 $Y m $X8 $Y l S
EOF
	} done	

	Y=$(( $Y - $Y_STEP ))
				# bottom/upper line + vertical lines
	cat <<EOF
$X0 $Y m $X8 $Y l S
$X0 $YSTART m $X8 $YSTART l S
$X0 $YSTART m $X0 $Y l S
$X2 $YSTART m $X2 $Y l S
$X4 $YSTART m $X4 $Y l S
$X6 $YSTART m $X6 $Y l S
$X8 $YSTART m $X8 $Y l S
EOF

	FONTSIZE=24
	XY="$X0 750"
	echo "BT $XY TD /F1 $FONTSIZE Tf (WLAN-Benutzerliste: $NAME ($RECORD Stueck))Tj ET"

	_log do $FUNC daemon info "[OK] $RECORD tickets"
}

_pdf_output_header ()		# http://www.gnupdf.org/Introduction_to_PDF
{				# http://www.aivosto.com/vbtips/pdf-optimize2.html
	local BODYSIZE_IN_BYTES="${1:-100}"

	cat <<EOF
%PDF-1.7

1 0 obj  % entry point
<<
  /Type /Catalog
  /Pages 2 0 R
>>
endobj

2 0 obj
<<
  /Type /Pages
  /MediaBox [ 0 0 595 842 ]
  /Count 1
  /Kids [ 3 0 R ]
>>
endobj

3 0 obj
<<
  /Type /Page
  /Parent 2 0 R
  /Resources <<
    /Font <<
      /F1 4 0 R 
    >>
  >>
  /Contents 5 0 R
>>
endobj

4 0 obj
<<
  /Type /Font
  /Subtype /Type1
  /BaseFont /Times-Roman
>>
endobj

5 0 obj  % page content
<<
  /Length $BODYSIZE_IN_BYTES
>>
stream
EOF
}

_pdf_output_footer ()
{
	local XREF_START_BYTE_OFFSET="${1:-999}"	# length of body + header
	XREF_START_BYTE_OFFSET="$(( $XREF_START_BYTE_OFFSET + 18 ))"	# adding 'endstream...' after body

	local BYTE_OFFSET_OBJ1="0000000010"
	local BYTE_OFFSET_OBJ2="0000000079"
	local BYTE_OFFSET_OBJ3="0000000173"
	local BYTE_OFFSET_OBJ4="0000000301"
	local BYTE_OFFSET_OBJ5="0000000380"	# we have 6 hardcoded objects

	local GENERATION_NO="00000"		# all objects are new and never changed
	local OBJ_USED="n "
	local OBJ_HIDDEN="f "

	cat <<EOF
endstream
endobj

xref
0 6
0000000000 65535 $OBJ_HIDDEN
$BYTE_OFFSET_OBJ1 $GENERATION_NO $OBJ_USED
$BYTE_OFFSET_OBJ2 $GENERATION_NO $OBJ_USED
$BYTE_OFFSET_OBJ3 $GENERATION_NO $OBJ_USED
$BYTE_OFFSET_OBJ4 $GENERATION_NO $OBJ_USED
$BYTE_OFFSET_OBJ5 $GENERATION_NO $OBJ_USED
trailer
<<
  /Size 6
  /Root 1 0 R
>>
startxref
$XREF_START_BYTE_OFFSET
%%EOF
EOF
}

_pdf_output_a4marker_body ()		# SENS: fits for 2x32 labels 35.6x16.9mm L4732 "Zweckform" organised to 5 rows with 16 cols (center row leaves emtpy)
{
	local FUNC="pdf_output_a4marker_body"
	local LIST_LOGIN_ID="$1"

	local FONTSIZE=18
	local NUMBER I N N1 N2 ID USERNAME PASSWORD XCOL1 XCOL2 XCOL3 XCOL4 XCOL5 YCOL

	tenth ()	# SENS: 123 -> 12.3
	{
		local VALUE="$1"

		echo "$(( $VALUE / 10 )).$(( $VALUE % 10 ))"
	}

	xcol ()
	{
		local COLUMN="$1"
		local BEGIN="163"
		local OFFSET="1170"
		local X

		X=$(( $BEGIN + ( $OFFSET * ( $COLUMN - 1 ) ) ))

		tenth $X
	}

	yrow ()					# pdf-coord-system starts in lower/left border with 0/0
	{
		local ROW="$1"
		local OPTION="$2"		# nextline
		local BEGIN="300"
		local OFFSET="516"
		local OFFSET_NEXTLINE="160"
		local Y

		Y=$(( $BEGIN + ($OFFSET * ($ROW - 1) ) ))

		[ -n "$OPTION" ] && Y=$(( $Y - $OFFSET_NEXTLINE ))

		tenth $Y
	}

	XCOL1=$( xcol 1 )
	XCOL2=$( xcol 2 )
	XCOL3=$( xcol 3 )
	XCOL4=$( xcol 4 )
	XCOL5=$( xcol 5 )
	I=17			# counter for right yrow (increasing)

	for ID in $LIST_LOGIN_ID; do {

		NUMBER=$(( ${NUMBER:-0} + 1 ))

		if [ $NUMBER -gt 16 ]; then		# right yrow

			I=$(( $I - 1 ))
			N=$I
			
			XCOL1=$XCOL4
			XCOL2=$XCOL5
		else
			N=$(( $I - $NUMBER ))		# left yrow
		fi

		YROW1="$( yrow $N )"
		YROW2="$( yrow $N nextline )"

		eval $( _db user login show $ID "USERNAME PASSWORD" )

		cat <<EOF
BT $XCOL1 $YROW1 TD /F1 $FONTSIZE Tf ($USERNAME)Tj ET
BT $XCOL1 $YROW2 TD /F1 $FONTSIZE Tf ($PASSWORD)Tj ET
BT $XCOL2 $YROW1 TD /F1 $FONTSIZE Tf ($USERNAME)Tj ET
BT $XCOL2 $YROW2 TD /F1 $FONTSIZE Tf ($PASSWORD)Tj ET
EOF

	} done

	FONTSIZE=12
	YROW1=$( yrow 15 )
	YROW2=$( yrow 15 nextline )
	eval $( _db user login show $ID "PROFILE_ID" )
	eval $( _db user profile show $PROFILE_ID "NAME" )

	cat <<EOF
BT $XCOL3 $YROW1 TD /F1 $FONTSIZE Tf ($NUMBER x $NAME )Tj ET
BT $XCOL3 $YROW2 TD /F1 $FONTSIZE Tf ($( _system date humanreadable nice ))Tj ET
EOF

	YROW1=$( yrow 2 )
	YROW2=$( yrow 2 nextline )

	cat <<EOF
BT $XCOL3 $YROW1 TD /F1 $FONTSIZE Tf (Standard-Etiketten)Tj ET
BT $XCOL3 $YROW2 TD /F1 $FONTSIZE Tf ("Zweckform" L4732)Tj ET
EOF

	_log do $FUNC daemon info "[OK] $NUMBER tickets" 
}
