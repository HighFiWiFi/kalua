_pdf_output_header ()
{
	cat <<EOF
%PDF-1.7

1 0 obj  % entry point
<<
  /Type /Catalog
  /Pages 2 0 R
>>
endobj

2 0 obj
<<
  /Type /Pages
  /MediaBox [ 0 0 595 842 ]
  /Count 1
  /Kids [ 3 0 R ]
>>
endobj

3 0 obj
<<
  /Type /Page
  /Parent 2 0 R
  /Resources <<
    /Font <<
      /F1 4 0 R 
    >>
  >>
  /Contents 5 0 R
>>
endobj

4 0 obj
<<
  /Type /Font
  /Subtype /Type1
  /BaseFont /Times-Roman
>>
endobj

5 0 obj  % page content
<<
  /Length 44
>>
stream
EOF
}

_pdf_output_footer ()
{
	cat <<EOF
endstream
endobj

xref
0 6
0000000000 65535 f 
0000000010 00000 n 
0000000079 00000 n 
0000000173 00000 n 
0000000301 00000 n 
0000000380 00000 n 
trailer
<<
  /Size 6
  /Root 1 0 R
>>
startxref
492
%%EOF
EOF
}

_pdf_output_a4marker ()		# SENS: fits for 2x32 labels 35.6x16.9mm L4732 "Zweckform" organised to 5 rows with 16 cols (center row leaves emtpy)
{				# fixme! more generic approach? + print INFO in top_center field
	local FUNC="pdf_output_a4marker"
	local LIST_LOGIN_ID="$1"
	local FONTSIZE=18
	local NUMBER I N N1 N2 ID USERNAME PASSWORD XCOL1 XCOL2 XCOL3 XCOL4 XCOL5 YCOL

	_log do $FUNC daemon info "[start] generating A4-page with these logins: '$LIST_LOGIN_ID'"

	_pdf output_header

	tenth ()	# SENS: 123 -> 12.3
	{
		local VALUE="$1"

		echo "$(( $VALUE / 10 )).$(( $VALUE % 10 ))"
	}

	xcol ()
	{
		local COLUMN="$1"
		local BEGIN="163"
		local OFFSET="1170"
		local X

		X=$(( $BEGIN + ( $OFFSET * ( $COLUMN - 1 ) ) ))

		tenth $X
	}

	yrow ()					# pdf-coord-system starts in lower/left border with 0/0
	{
		local ROW="$1"
		local OPTION="$2"		# nextline
		local BEGIN="300"
		local OFFSET="516"
		local OFFSET_NEXTLINE="160"
		local Y

		Y=$(( $BEGIN + ($OFFSET * ($ROW - 1) ) ))

		[ -n "$OPTION" ] && Y=$(( $Y - $OFFSET_NEXTLINE ))

		tenth $Y
	}

	XCOL1=$( xcol 1 )
	XCOL2=$( xcol 2 )
	XCOL3=$( xcol 3 )
	XCOL4=$( xcol 4 )
	XCOL5=$( xcol 5 )
	I=17			# counter for right yrow (increasing)

	for ID in $LIST_LOGIN_ID; do {

		NUMBER=$(( ${NUMBER:-0} + 1 ))

		if [ $NUMBER -gt 16 ]; then		# right yrow

			I=$(( $I - 1 ))
			N=$I
			
			XCOL1=$XCOL4
			XCOL2=$XCOL5
		else
			N=$(( $I - $NUMBER ))		# left yrow
		fi

		YROW1="$( yrow $N )"
		YROW2="$( yrow $N nextline )"

		eval $( _db user login show $ID "USERNAME PASSWORD" )

		cat <<EOF
BT $XCOL1 $YROW1 TD /F1 $FONTSIZE Tf ($USERNAME)Tj ET
BT $XCOL1 $YROW2 TD /F1 $FONTSIZE Tf ($PASSWORD)Tj ET
BT $XCOL2 $YROW1 TD /F1 $FONTSIZE Tf ($USERNAME)Tj ET
BT $XCOL2 $YROW2 TD /F1 $FONTSIZE Tf ($PASSWORD)Tj ET
EOF

	} done

	FONTSIZE=12
	YROW1=$( yrow 15 )
	YROW2=$( yrow 15 nextline )
	eval $( _db user login show $ID "PROFILE_ID" )
	eval $( _db user profile show $PROFILE_ID "NAME" )

	cat <<EOF
BT $XCOL3 $YROW1 TD /F1 $FONTSIZE Tf ($NUMBER x $NAME )Tj ET
BT $XCOL3 $YROW2 TD /F1 $FONTSIZE Tf ($( _system date humanreadable ))Tj ET
EOF

	_pdf output_footer

	_log do $FUNC daemon info "[end] generating PDF to stdout ($NUMBER tickets)" 
}

_pdf_output_a4digest ()								# max 32 on one A4-sheet
{										# fixme! calculate correct output size? (template_size - replaced_vars_templete + replaced_vars)
	local FUNC="pdf_output_a4digest"
	local LIST_LOGIN_ID="$1"						# fixme! automatically print 2,3...pages each 35 tickets

	_log do $FUNC daemon info "[start] generating A4-page with these logins: '$LIST_LOGIN_ID'"

	local PDF_TEMPLATE="/www/images/userdb_ticket_template.pdf"
	local PDF_LINES_MAX="35"						# fixme! read it from PDF, not hardcode here
	local TEMP="/tmp/db_output_generate_$$"
	local SQLTEMP="/tmp/db_output_sqlquery_$$"
	local LINE WORD NUMBER
	local ID PROFILE_ID NAME INSTALLED USERNAME PASSWORD
	local COUNT=0

	local VAR_CREATOR="ekuku multispot"					# fixme!
	local VAR_SOURCE="quellenangabe"					# fixme!
	local VAR_HOTELNAME="$( _weblogin metadata_locationname )"		# Hotel Liszt in Weimar
	local WORD_USERLIST="WLAN-Benutzerliste: "

	local VAR_GENTIME							# unixtime
	local VAR_TICKETTYPE							# 24-Stunden-Tickets, 1-Wochen-Tickets, 1-Monats-Tickets
	for ID in $LIST_LOGIN_ID; do {
		eval $( _db user login show $ID "PROFILE_ID INSTALLED" )
		eval $( _db user profile show $PROFILE_ID NAME )
		VAR_TICKETTYPE="$NAME"
		VAR_GENTIME="$INSTALLED"		# _system date unixtime2date
		break
	} done

	local WORD_GENTIME="Zeitpunkt der automatischen Generierung: "		# fixme! 'automatischen' / 'manuellen'
	local VAR_GENHUMANDATE="$( _sanitizer do $( _system date humanreadable nice ) escape_single_quotes )"
	local WORD_USER="Benutzername"
	local WORD_PASS="Passwort"
	local WORD_ROOMANDGUEST="Zimmernummer \/ Gastname"			# sed-style
	local WORD_COMMENT="Kommentar"
	local VARLIST="VAR_CREATOR VAR_GENTIME VAR_SOURCE VAR_HOTELNAME WORD_USERLIST VAR_TICKETTYPE VAR_GENHUMANDATE WORD_GENTIME WORD_USER WORD_PASS WORD_ROOMANDGUEST WORD_COMMENT" 

	for WORD in $VARLIST; do {
		echo "$WORD = $( eval echo \$$WORD )"
	} done

	ID=;while :; do ID="$ID N";test ${#ID} -eq $(( $PDF_LINES_MAX * 2 )) && break; done 	# outputs: N N N N ... (filling up template-page)
	for ID in $LIST_LOGIN_ID $ID; do {

		COUNT=$(( $COUNT + 1 ))				# for calc
		NUMBER=$COUNT					# for print
		[ ${#COUNT} -eq 1 ] && NUMBER="0${COUNT}"

		case "$ID" in
			N) USERNAME=; PASSWORD= ;;
			*) eval $( _db user login show $ID "USERNAME PASSWORD" ) ;;
		esac

		# echo -n "-e 's/USER${NUMBER}/$USERNAME/' -e 's/PASS${NUMBER}/$PASSWORD/' -e 's/GUEST${NUMBER}//' -e 's/COMMENT${NUMBER}//' "

		echo "USERNAME: $USERNAME PASSWORD: $PASSWORD"

		[ $NUMBER -eq $PDF_LINES_MAX ] && break

	} done

	_log do $FUNC daemon info "[end] generating PDF to stdout ($COUNT tickets)"
}
