# tc qdisc add dev eth0 root handle 1: cbq avpkt 1000 bandwidth [HN]
# tc qdisc show

_pfilter_user_splash_remove ()
{
	local MAC="$1"
	local IP="$2"

	[ -z "$MAC" -o -z "$IP" ] && return 1
								# user is known, but splashed
	_pfilter user_list | grep -q -i $MAC && {
		_pfilter user_splash_control nosplash $MAC $IP >/dev/null
		return
	}

	_pfilter user_ruleset_activate $MAC $IP || {		# user is new and splashed
		_pfilter user_add $MAC $IP
	}
}

_pfilter_rules_webserver_deny_incoming_nonlocal ()
{
	local FUNC="reject_traffic_from_nonlocal_hosts_to_local_webserver"
	local MYHNA="$( _config get net olsr hna4 )"

	_log do $FUNC daemon info "activate blocking for HTTP(S) to avoid lowmem situations during software-install"

	iptables -I INPUT -p tcp -s ! $MYHNA --dport 80  -j DROP	# if REJECT is not possible, then method DROP is fallback
	iptables -I INPUT -p tcp -s ! $MYHNA --dport 443 -j DROP
	iptables -I INPUT -p tcp -s ! $MYHNA --dport 80  -j REJECT
	iptables -I INPUT -p tcp -s ! $MYHNA --dport 443 -j REJECT
}

_pfilter_user_ruleset_activate ()
{
	local FUNC="activate_reserved_user_chain"
	local MAC_RESERVE
	local MAC_RESERVE_LIST="99:99:99:99:99:99 99:99:99:99:99:98 99:99:99:99:99:97 99:99:99:99:99:96 99:99:99:99:99:95"
	local MAC="$1"
	local IP="$2"
	
	for MAC_RESERVE in $MAC_RESERVE_LIST; do {

		iptables -t mangle -E traff_${MAC_RESERVE} traff_$MAC 2>/dev/null && { 
	
			_log do $FUNC daemon info "found chain traff_${MAC_RESERVE} and renamed to 'traff_$MAC'"
			
			iptables -t mangle -D traff_users -m mac --mac-source $MAC_RESERVE	-j traff_$MAC
			iptables -t mangle -D traff_users -d 99.99.99.99			-j traff_$MAC

			iptables -t mangle -D traff_$MAC 12
			iptables -t mangle -I traff_$MAC 12 -m mark --mark $( _pfilter proto2id CONN )/0xFF -j ULOG --ulog-prefix "${MAC}>"	# inside2outside
			iptables -t mangle -D traff_$MAC 19
			iptables -t mangle -I traff_$MAC 19 -m mark --mark $( _pfilter proto2id CONN )/0xFF -j ULOG --ulog-prefix "${MAC}<"	# outside2inside

			iptables -t mangle -A traff_users -m mac --mac-source $MAC		-j traff_$MAC
			iptables -t mangle -A traff_users -d $IP				-j traff_$MAC

			_net arp_permanent $IP $MAC
			_pfilter user_splash_control nosplash $MAC $IP		
		
			_log do $FUNC daemon info "successfully activated 'traff_$MAC'"

			_scheduler add "/etc/local.fw-fff+ adduser_reserve $MAC_RESERVE 99.99.99.99"
			return 0
		}

		_log do $FUNC daemon debug "renaming chain 'traff_${MAC_RESERVE}' to 'traff_$MAC' didn't work"
		_scheduler add "/etc/local.fw-fff+ adduser_reserve $MAC_RESERVE 99.99.99.99"
		
		if [ "$MAC_RESERVE" = "99:99:99:99:99:95" ] && [ ! -e "/tmp/USER_PACKETFILTER" ]; then
			touch /tmp/USER_PACKETFILTER
			_scheduler add "/etc/local.fw-fff+ close_doors"
		fi
	} done
	
	return 1
}

_pfilter_stats_rules_count ()
{
	local LIST="${1:-mangle filter nat}"
	local OPTION="$2"			# POSTROUTING
	local TABLE COUNT
	
	for TABLE in $LIST; do {
		COUNT="$( iptables -t $TABLE -nxL $OPTION | sed -e '/^target/d' -e '/^Chain /d' -ne '/[^.]$/p' | sed -n '$=' )"
		_log do packetfilter_count_rules daemon debug "$COUNT rules in '$TABLE' $OPTION"
	} done
}

_pfilter_rules_portfw_install ()			# fixme! howto redirect to myself?
{
	local FUNC="packetfilter_install_portforwarding"
	local ENTRY
	local PROTO
	local PORTFORWARDING="$( nvram get fff_portfw )"

	for ENTRY in $PORTFORWARDING; do {
	
		eval $( _pfilter rules_portfw_config_serialize $ENTRY )
		
		[ $RULE_ACTIVE = "on" ] && {
		
			case $RULE_INCOMING_INTERFACE in
				 wan) RULE_INCOMING_INTERFACE="-i $WANDEV"	;;
				 lan) RULE_INCOMING_INTERFACE="-i $LANDEV"	;;
				wifi) RULE_INCOMING_INTERFACE="-i $WIFIDEV"	;;
			     tun|tap) RULE_INCOMING_INTERFACE="-i ${RULE_INCOMING_INTERFACE}+" ;;
				   *) RULE_INCOMING_INTERFACE=""		;;
			esac

			[ $RULE_PROTO = "both" ] && RULE_PROTO="tcp udp"
			
			for PROTO in $RULE_PROTO; do {
				
				RULE_ACTIVE="-t nat -I PREROUTING $RULE_INCOMING_INTERFACE -p $PROTO --dport $RULE_PORT_INCOMING -j DNAT --to-destination $RULE_DEST_IP:$RULE_PORT_DEST"
				
					if iptables $RULE_ACTIVE ; then
				     		_log do $FUNC user info "success adding rule '$RULE_NAME'"
				     	else
				     		_log do $FUNC user err  "error adding rule '$ENTRY' ('iptables $RULE_ACTIVE')"
				     	fi
			} done
		}
	} done
}

_pfilter_rules_dhcp_ignore_specific_macs ()	# SENS: mario
{
	local FUNC="packetfilter_dhcp_ignore_specific_macs"
	local MAC
	
	for MAC in $( nvram get fff_dhcp_ignore ); do {		# format: 'MAC1 MAC2 MACn"

		_log do $FUNC daemon debug "ignoring '$MAC'"
		iptables -I INPUT -p udp --sport 68 -d 255.255.255.255 --dport 67 -m mac --mac-source $MAC -j DROP
	} done
}

_pfilter_rules_portfw_config_serialize ()
{
	# like in DD-WRT (but with incoming interface!)

	# name:active:incoming_interface:proto:dport>dest_ip:dest_port name:...
	# name:on/off:any/wan/lan/wifi:tcp/udp/both:dport>dest_ip:dest_port name:...

	# emule:off:wan:both:4661>10.63.45.100:4661
	# webcam:on:any:tcp:8080>10.63.168.97:80
	
	echo $1 | sed 's/\(.*\):\(.*\):\(.*\):\(.*\):\(.*\)>\(.*\):\(.*\)/local RULE_NAME=\1\nlocal RULE_ACTIVE=\2\nlocal RULE_INCOMING_INTERFACE=\3\nlocal RULE_PROTO=\4\nlocal RULE_PORT_INCOMING=\5\nlocal RULE_DEST_IP=\6\nlocal RULE_PORT_DEST=\7/'

	# output is like:
	# local RULE_NAME=webcam
	# local RULE_ACTIVE=on
	# local RULE_INCOMING_INTERFACE=all	// wan,lan,wifi,all/any
	# local RULE_PROTO=tcp
	# local RULE_PORT_INCOMING=8080
	# local RULE_DEST_IP=10.63.168.97
	# local RULE_PORT_DEST=80
}

_pfilter_stats_user_traffic_list_today ()
{
	local   MEDIA=""
	local TRAFFIC=0	
	local MACLIST="$( _pfilter user_list )"

	for MAC in $MACLIST; do {
	
		TRAFFIC="$( _pfilter stats_user_traffic $MAC today )"
	
		[ "$TRAFFIC" != "0" ] && {
		
			TRAFFIC="$( _math bytes2unit $TRAFFIC mb )"
		
			  MAC="$( echo $MAC | sed 's/://g' )"
			MEDIA="$( _net mac2media $MAC short )"
				
			echo -en "${MEDIA}${MAC}:${TRAFFIC}"
		}
	} done
}

_pfilter_rules_nat_wifi_roaming ()
{
	_log do "pfilter_rules_nat_wifi_roaming" daemon info "installing masquerading"

	eval "$( _ipsystem do )"

	iptables -t nat -A POSTROUTING -o $WIFIDEV -s $ROAMING_IP4/$ROAMING_PRE -j MASQUERADE	# or SNAT?
}

_pfilter_user_probe_local_blacklist ()
{
	local MAC="$1"

	nvram get fff_ethers_blocked | grep -q -i $MAC && return 0
	return 1
}

_pfilter_rules_nat_inetoffer_lan ()	# SENS: masquerades traffic over lan-device for omitting "black hole"
{						#       and fetches IP from local DHCP-server, if gateway-IP is not from local IP-range
	local FUNC="masq_internet_traffic_over_lan_device"
	_log do pfilter daemon info "($FUNC) working"

	local GATEWAY="$( nvram get lan_gateway )"
	local COUNTER=0
												# is lan_gateway an alien network?
												# then add alien-ip-range to alias-interface...

	if [ -n "$GATEWAY" ] && [ -z "$( ip route list exact 0/0 via $GATEWAY )" ]; then	# def_route could'nt be set by /sbin/ifup
												# because kernel has no suiteable interface for gw
		while [ $COUNTER -lt 5 ]; do {
			_log do pfilter daemon info "($FUNC) detected alien LAN-gateway, trying to fetch DHCP-address"
			local ALIASIP="$( udhcpc -qfn --interface="$LANDEV:fantasy" 2>/dev/null | sed -n 's/.* \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .*/\1/p' )"
			[ -n "$ALIASIP" ] && break
			_log do pfilter daemon info "($FUNC) no alias-ip - trying again in 10 sec"
			sleep 10
			COUNTER=$(( $COUNTER + 1 ))		# fixme! even with "LAN:fantasy" /etc/resolv.conf gets applied, rewrite?
		} done
		
		[ -z "$ALIASIP" ] && {
			# last octett is now a 234, so when
			# gateway is 192.168.178.1, we set
			#            192.168.178.234 on our LAN-address		# fixme! uiuiui!
			ALIASIP="$( echo $GATEWAY | sed -n 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\..*/\1.\2.\3.234/p' )"
			_log do pfilter daemon info "($FUNC) couldt fetch IP-address from LAN-DHCP-server, guessing"
		}
		
		_log do pfilter daemon info "($FUNC) using alienip '$ALIASIP' to reach gateway"
		
		local ALIASPRE="$( ipcalc -p $ALIASIP           | sed -n 's/PREFIX=\(.*\)/\1/p' )"
		local ALIASNET="$( ipcalc -n $ALIASIP/$ALIASPRE | sed -n 's/NETWORK=\(.*\)/\1/p' )"
		local LANNET="$ALIASNET"
		local LANPRE="$ALIASPRE"

		_log do pfilter daemon info "($FUNC) local alien-address gateway"
		_log do pfilter daemon info "($FUNC) adding $ALIASIP/$ALIASPRE on $LANDEV:aliennet"
		_log do pfilter daemon info "($FUNC) adding default route"
		
		ip address add $ALIASIP/$ALIASPRE   dev $LANDEV label $LANDEV:aliennet
		ip route   add default via $GATEWAY dev               $LANDEV metric 0

		# fixme! apply now static_routes, which could be used till now?
	
		if [ "$?" -ne 0 ]; then
			_log do pfilter daemon info "($FUNC) error adding default route"
		else
			_log do pfilter daemon info "($FUNC) success adding default route"	# fixme! why we restart vpn?
			/etc/init.d/S*vpn* restart				# uiuiui! better use an central
										# function to automatically ifup/down
										# vpn-connection (cron.minutely hna4-hook?)
		fi
	fi	
	
	iptables -A POSTROUTING -t nat -o $LANDEV  -s ! $LANNET/$LANPRE -j MASQUERADE
	iptables -A POSTROUTING -t nat -o $WIFIDEV -s   $LANNET/$LANPRE -j MASQUERADE

	_pfilter stats_rules_count nat POSTROUTING
	_log do pfilter daemon info "($FUNC) done"
}

_pfilter_user_traffic_limit ()
{
	local MAC="$1"
	
	[ -z "$MAC" ] && {
		echo 0
		return
	}
	
	local OUT=0								# traffic variables are known from /etc/variables_fff+
	local WIFI_MODE="$( _wifi mode )"
	local MEDIA="$( _net mac2media $MAC )"
	
	_pfilter user_list_local_registered | grep -q -i $MAC
										# now we make differences for anonym or locally registered
										# and wire / wireless / wireless_in_non-mesh-disturbing ap-mode (other channel!)
										
	if [ "$?" -eq 0 ]; then							# locally registered
	
		if [ "$MEDIA" = "wire" ] || [ "$WIFI_MODE" = "ap" ] ; then	# locally registered, wire or AP
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f4 )"
		else								# locally registered, wifi
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f3 )"
		fi
	else
		if [ "$MEDIA" = "wire" ] || [ "$WIFI_MODE" = "ap" ]; then	# anonym, wire or AP
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f2 )"
		else								# anonym, wifi
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f1 )"
		fi
	fi

	echo "${OUT:-2500}000000"						# convert MBytes in Bytes 8-)
}

_pfilter_stats_user_traffic_used_percent ()		# ARG1: mac-address
{									# OUT1: integer - can be higher then 100% (!)
	local MAC="$1"
	local STEP1
	local STEP2
	local STEP3
	
	_pfilter user_list | grep -q -i $MAC || {
		echo "0"
		return
	}

	STEP1="$( _pfilter stats_user_traffic $MAC today )"					# hint: traffic_today * 100 / traffic_limit
	STEP2="$( _pfilter user_traffic_limit $MAC )"	#       is the same like:
	STEP3="$( _math divide100 $STEP2 )"						#       traffic_today / (traffic_limit/100)

	echo $(( $STEP1 / $STEP3 ))							#       doing it this way we avoid big numbers during bash-calculation
}

_pfilter_user_splash_remove_autounsplashed ()
{
	local ENTRY=""
	local MAC=""
	local IP=""
	local LIST="$( grep "^..:..:..:..:..:.. free-" /etc/ethers ; grep "^..:..:..:..:..:.. admin-" /etc/ethers)"

	_log do pfilter daemon info "(_pfilter user_splash_remove_autounsplashed) checking"

	for ENTRY in $LIST; do						# MAC NAME MAC NAME ...
		echo $ENTRY | grep -q "..:..:..:..:..:.."
		
		if [ "$?" -eq 0 ]; then
			MAC=$ENTRY
		else
			NAME=$ENTRY
			IP="$( grep $NAME /etc/local.hosts | cut -d" " -f1 )"

			_log do pfilter daemon info "(_pfilter user_splash_remove_autounsplashed) adding \"$NAME\""

			_pfilter user_add $MAC $IP
		fi
	done
}

_pfilter_user_splash_add_for_nonautounsplashed () {
	local FUNC="kick_all_nonfree_users"
	local LIST="$( _pfilter user_list )"

	for MAC in $LIST; do {
		
		[ "$( _pfilter user_probe_splash $MAC )" = "false" ] && {
			
			[ "$( _pfilter user_probe_autounsplashed $MAC )" = "false" ] && {
				_log do $FUNC daemon debug "kicking '$MAC'"
				_pfilter user_splash_control splash $MAC "$( _net mac2ip $MAC )"
			}
		}
	} done
}

_pfilter_user_kick_overlimit ()
{
	local FUNC="kick_all_users_which_are_over_limit"
	local LIST="$( _pfilter user_list )"
	local LIMIT
	local PERCENT
	local MAC

	for MAC in $LIST; do {

		[ "$( _pfilter stats_user_traffic $MAC today )" != "0" ] && {	# very fast check
		
			[ "$( _pfilter user_probe_splash $MAC )" = "false" ] && {
		
				[ "$( _pfilter user_probe_admin $MAC )" = "false" ] && {
		
					PERCENT="$( _pfilter stats_user_traffic_used_percent $MAC )"
					_log do $FUNC user debug "'$MAC'-traffic is ${PERCENT}%"
				
					[ $PERCENT -gt 100 ] && {
						LIMIT="$( _pfilter user_traffic_limit $MAC )"
						LIMIT="$( _sanitizer do "$LIMIT" number_humanreadable )"
						_log do $FUNC user info " -'$MAC' (traffic: ${PERCENT}% ~${LIMIT} bytes)"
						_pfilter user_splash_control splash $MAC "$( _net mac2ip $MAC )"
					}
				}
			}
		}
	} done
}

_pfilter_user_traffic_reset () {
	local FUNC="reset_all_daily_user_counters"
	local LIST="$( _pfilter user_list )"
	local MAC
	
	for MAC in $LIST; do {
		_pfilter user_traffic_reset_single $MAC today	
	} done
}

_pfilter_stats_olsr_traffic_wifi_in () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	iptables -nxvL olsr_in | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

_pfilter_stats_olsr_traffic_wifi_out () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	iptables -nxvL olsr_out_wifi | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

_pfilter_stats_layer7_hits () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	local ALL_BYTES="$(      iptables -t mangle -nxvL FORWARD | grep "CONNMARK restore" | while read PACK BYTES REST; do echo $BYTES; done )"
	local RESTORED_BYTES="$( iptables -t mangle -nxvL FORWARD | grep "CONNMARK match"   | while read PACK BYTES REST; do echo $BYTES; done )"
	local MATCHED_BYTES="$(  iptables -t mangle -nxvL marking | grep "CONNMARK"         | while read PACK BYTES REST; do echo $BYTES; done )"

	which awk >/dev/null || {
		echo 0
		return
	}
	awk -v A=$ALL_BYTES -v R=$RESTORED_BYTES -v M=$MATCHED_BYTES 'BEGIN{ printf("%.2f",(R+M)*100/A) }'

	# local STEP1="$(( $RESTORED_BYTES + $MATCHED_BYTES ))"
	# local STEP2="$(( $ALL_BYTES / 1000 ))"
	# _math divide10 "$(( $STEP1 / $STEP2 ))"
}

_pfilter_stats_user_cast () {					# if ARG2 = spread, then data goes out to $GW and $NEXTHOP
	local LIST="$( _pfilter user_list )"

	eval "$( tail -n 1 /tmp/ARCHIV_TRACEINET )"

	if [ -n "$LIST" ]; then
		for MAC in $LIST; do

			local DATE="$(         date +%d%b%Y-%Huhr%M                )"
			local TIME="$(         _system date unixtime                            )"
			
			local TRAFF_RECENT="$( _pfilter stats_user_traffic $MAC recent )"
			[ $TRAFF_RECENT -ne 0 ] && {
				_pfilter user_traffic_reset_single $MAC recent
			}
			local TRAFF_TODAY="$(  _pfilter stats_user_traffic $MAC today  )"
			local TRAFF_ALL="$(    _pfilter stats_user_traffic $MAC all    )"
			
			local MEDIA="$(        _net mac2media         $MAC )"
			local NAME="$(         _net mac2hostname           $MAC )"
			local NODE="local"
			local REG=0
	
			OUTPUT="NODE=$NODE TIME=$TIME DATE=$DATE MAC=$MAC NAME=$NAME REG=$REG MEDIA=$MEDIA TRAFF_RECENT=$TRAFF_RECENT TRAFF_TODAY=$TRAFF_TODAY TRAFF_ALL=$TRAFF_ALL"

			if [ "$1" = "spread" ] && [ $TRAFF_RECENT -gt 0 ]; then
				echo $OUTPUT
				echo $OUTPUT >>/tmp/ARCHIV_TRAFFIC
				
				local URL="http://$GW/cgi-bin-traffic_fff+?"
				local MSG="MAC=$MAC&NAME=$NAME&REG=$REG&MEDIA=$MEDIA&TRAFF_RECENT=$TRAFF_RECENT&TRAFF_TODAY=$TRAFF_TODAY&TRAFF_ALL=$TRAFF_ALL"			

				_wget do "${URL}${MSG}" 5 >/dev/null
			
				if [ "$GW" != "$NEXTHOP" ]; then
					local URL="http://$NEXTHOP/cgi-bin-traffic_fff+?"				
				
					_wget do "${URL}${MSG}" 5 >/dev/null
				fi
			fi
		done
	fi
}

_pfilter_user_probe ()
{
	iptables -t mangle -nL traff_${1:-unset} >/dev/null 2>/dev/null && return 0
	return 1
}

_pfilter_user_list ()					# SENS: list all MACs from logged in / shaped users
{
	iptables -t mangle -nL traff_users 2>/dev/null | sed -n 's/^traff_\([0-8abcdef][0-8abcdef]:..:..:..:..:..\) .*MAC .*$/\1/p'	# must not begin with '99' (=reserved user)
}

_pfilter_user_list_blocked () {
	IFS=";"
	for MAC in $( nvram get fff_ethers_blocked ); do
		echo "$MAC"
	done
	unset IFS
}

_pfilter_user_list_dhcp_active ()
{
	sed -n 's/^.* \(..:..:..:..:..:..\) .*/\1/p' /var/run/dhcp.leases
}

_pfilter_user_list_local_registered () {
	IFS=";"
	for MAC in $( nvram get fff_ethers_wifi ); do
		echo "${MAC%=*}"
	done
	
	for MAC in $( nvram get fff_ethers_lan ); do
		echo "${MAC%=*}"
	done
	unset IFS
}

_pfilter_user_traffic_reset_single ()
{
	local FUNC="reset_traffic_counter_for_mac"
	local RULE_NUM="$2"
	local MAC="$1"
	local LOGPRIO="info"
	
	case $RULE_NUM in
		recent) RULE_NUM=2
			LOGPRIO="debug" ;;	# last 15min
		 today) RULE_NUM=3 ;;		# today
		     *) RULE_NUM=4 ;;		# overall
	esac

	_log do $FUNC daemon $LOGPRIO "$MAC ('$2')"
	
	iptables -R traff_$MAC $RULE_NUM -t mangle --set-counters 0 0
}

_pfilter_stats_traffic_forwarded_intranet () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	iptables -nxvL FORWARD | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

_pfilter_stats_traffic_forwarded_internet () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	iptables -t mangle -nxvL FORWARD | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

_pfilter_stats_user_conns_start ()
{
	local MAC="$1"
	
	iptables -t mangle -nxvL traff_$MAC | grep "state NEW MARK set 0x91" | sed -n 's/^[^0-9]*\([0-9]*\)[^0-9]*.*/\1/p'
}

_pfilter_stats_user_conns_end ()
{
	local MAC="$1"

	iptables -t mangle -nxvL traff_$MAC | grep "flags:0x11/0x11 MARK" | tail -n1 | sed -n 's/^[^0-9]*\([0-9]*\)[^0-9]*.*/\1/p'
}

_pfilter_stats_user_conns_over_limit () {	# we count udp + tcp above's 	// fixme! what about adblock?
	local MAC="$1"
	local PACK=""
	local REST=""	

	iptables -t mangle -nxvL traff_$MAC | head -n 9 | tail -n 1 | while read PACK REST; do echo $PACK; done
}

_pfilter_stats_user_traffic ()	# OUT1: string
{
	local MAC="$1"
	local TIMESLOT="$2"
	local LINE
	
	case $TIMESLOT in
		recent) LINE="2" ;;	# last 15min
		today)  LINE="3" ;;	# today
		*)      LINE="4" ;;	# overall
	esac

	iptables -t mangle --line-numbers -nxvL traff_${MAC} | 
	 sed -n "/^${LINE} /s/^${LINE}[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p"
}

_pfilter_proto2id ()		# fixme! uses global var 'PROTO' + 'PORT'
{
	local N=0
	
	[ -n "$1" ] && {
		case $1 in
			PING)       N=98 ;;
			TRACE)      N=97 ;;
			NTP)        N=96 ;;
			FRAG)       N=95 ;;
			TTL0)       N=94 ;;
			UNREA)      N=93 ;;
			CONN_ABOVE) N=92 ;;
			CONN)       N=91 ;;
			GARDEN)     N=90 ;;
			REDIRECT)   N=89 ;;
			REJECT)     N=88 ;;
			DHCPIN)     N=87 ;;
			PICOPEER)   N=86 ;;
			GUESS)      N=85 ;;
			SMALL)      N=84 ;;
						
			*)          N=99 ;;
		esac
		
		echo -n "0x$N"
		return
	}
	
	for ENTRY in $( _pfilter l7proto_list ); do {		# fixme! this loop runs very often
	
		THIS_PROTO="${ENTRY%,*}"
		THIS_PORT="${ENTRY#*,}"

		[ -z "$PORT" ] && THIS_PORT=""
	
		let N+=1
		if [ "$PROTO" = "$THIS_PROTO" ] && [ "$PORT" = "$THIS_PORT" ]; then
			echo -n "0x$N"
			return
		fi
	} done
}

_pfilter_user_probe_admin () {
	local MAC="$1"
	local LIST="$(nvram get fff_ethers_lan) $(nvram get fff_ethers_wifi)"
	
	if [ -n "$( echo $LIST | grep -i "${MAC}=admin-" )" ]; then
		echo "true"
	else
		echo "false"
	fi
}

_pfilter_user_probe_autounsplashed () {				# free means no splashpage wished: username must begin with "admin-" or "free-"
	local MAC="$1"
	local LIST="$(nvram get fff_ethers_lan) $(nvram get fff_ethers_wifi)"
	
	if [ -n "$( echo $LIST | grep -i "${MAC}=free-" )" ] || [ -n "$( echo $LIST | grep -i "${MAC}=admin-" )" ]; then
		echo "true"
	else
		echo "false"
	fi
}

_pfilter_user_splash_probe ()
{
	iptables -t mangle -nL PREROUTING | grep -q -i ${1:-unsetmac} && return 1
	return 0
}

_pfilter_user_probe_splash () {
	local MAC="$1"

	iptables -t mangle -nL PREROUTING | grep -q -i $MAC
	
	if [ "$?" -eq 0 ]; then				# mac is accepted in prerouting/mangle: no redirection is made
		echo "false"
	else						# mac is not known in prerouting/mangle: user gets splash page
		echo "true"
	fi
}

_pfilter_user_splash_control ()				# SENS: controlling if a user must see splashpage before using internet or not
{							# ARG1: nosplash,splash
							# ARG2: mac
	local FUNC="pfilter_user_splash_control"	# ARG3: ip-address
	local MODE="$1"
	local  MAC="$2"
	local   IP="$3"

	_log do $FUNC daemon info "start - mode: $MODE - $MAC / $IP"

	if [ -z "$MODE" ] || [ -z "$MAC" ] || [ -z "$IP" ]; then
		_log do $FUNC daemon info "no mode nor mac nor ip given, aborting"
		return
	fi

	if [ "$MODE" = "nosplash" ]; then
		MODE="-I"
	else
		MODE="-D"
	fi

	iptables -t mangle $MODE PREROUTING -m mac --mac-source $MAC -j ACCEPT
	iptables -t mangle $MODE PREROUTING -d $IP                   -j ACCEPT	

	_log do $FUNC daemon info "end - mode: $MODE - $MAC / $IP"
}

_pfilter_user_add ()		# SENS: generate MAC-specific shaping/accounting-chain
{
	local FUNC="pfilter_user_add"
	local MAC="$1"
	local  IP="$2"
	local ARP="$3"		# fixme! sens of $3 ?
	local MYHNA="$( _config get net olsr hna4 )"

	[ "$4" != "reserve" ] && {
		_log do $FUNC daemon debug "instant call - trying to activate reserved user chain"
		_pfilter user_ruleset_activate $MAC $IP && {
			_log do $FUNC daemon debug "successfully activated reserved user chain"
			return 0
		}
	}

	[ -z "$IP" ] && {
		_log do $FUNC daemon info "no MAC or no IP given - aborting"
		return 1
	}
					# normal users
	local CONN_LIMIT_UDP="20"	# was 5
	local CONN_LIMIT_TCP="75"	# was 20

	if [ "$( _net local_inet_offer )" != "false" ]; then
	
		_log do $FUNC daemon info "raising connection-count for this user"

		CONN_LIMIT_UDP="20"		# free-users on node with inet-offer
		CONN_LIMIT_TCP="75"
	
		if [ "$( _pfilter user_probe_admin $MAC )" = "true" ]; then

			_log do $FUNC daemon info "boosting connection-count for this admin-user"

			CONN_LIMIT_UDP="1000"
			CONN_LIMIT_TCP="4096"
		fi
	fi
	
	_log do $FUNC daemon debug "$MAC / $IP (connlimit tcp/udp: $CONN_LIMIT_TCP/$CONN_LIMIT_UDP)"

	[ -z "$ARP" ] && _net arp_permanent $IP $MAC

	_log do $FUNC daemon debug "filling user chain - start"
	
	iptables -t mangle -N traff_$MAC 2>/dev/null || {
		_log do $FUNC daemon debug "chain traff_$MAC already exists - abort"
		return 1
	}
	
	iptables -t mangle -A traff_$MAC -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE -j shaper	# counter0 (intranet/mesh-intern)
	iptables -t mangle -A traff_$MAC							# counter1 (traffic interval-count)
	iptables -t mangle -A traff_$MAC							# counter2 (traffic_today)
	iptables -t mangle -A traff_$MAC							# counter3 (traffic_all)
	
	iptables -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW -d 1.1.0.0/20 -m limit --limit 6/min --limit-burst 10 -j LOG --log-prefix "ADBLOCK:"
	iptables -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW -d 1.1.0.0/20        -j MARK --set-mark $( _pfilter proto2id REJECT )    # adblock (special dest)
	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id REJECT )/0xFF  -j shaper
	
	iptables -t mangle -A traff_$MAC -m state --state NEW -p udp -m udplimit  --udplimit-above  $CONN_LIMIT_UDP -j MARK --set-mark $( _pfilter proto2id CONN_ABOVE )
	iptables -t mangle -A traff_$MAC -m state --state NEW -p tcp -m connlimit --connlimit-above $CONN_LIMIT_TCP -j MARK --set-mark $( _pfilter proto2id CONN_ABOVE )
	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN_ABOVE )/0xFF                           -j shaper	# connabove to shaper
	
	iptables -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW                   -j MARK --set-mark $( _pfilter proto2id CONN )	# all new packets
	
	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF       -j ULOG --ulog-prefix "$MAC>"       # inside2outside
	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF       -j shaper
	
	iptables -t mangle -A traff_$MAC -s $MYHNA -p tcp --tcp-flags fin,ack fin,ack     -j MARK --set-mark $( _pfilter proto2id CONN )    # FIN&ACK is set
	iptables -t mangle -A traff_$MAC -s $MYHNA -p tcp --tcp-flags rst rst             -j MARK --set-mark $( _pfilter proto2id CONN )    # RST     is set
	
	iptables -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags syn,ack syn,ack     -j MARK --set-mark $( _pfilter proto2id CONN )	# better? SYN&ACK in answer is set
	iptables -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags fin,ack fin,ack     -j MARK --set-mark $( _pfilter proto2id CONN )	# better? FIN&ACK in answer is set
	iptables -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags rst rst             -j MARK --set-mark $( _pfilter proto2id CONN )	# better? RST     in answer is set

	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF    -j ULOG --ulog-prefix "${MAC}<"	# outside2inside
	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF    -j shaper 
	
	iptables -t mangle -A traff_$MAC -m connbytes --connbytes   97999:99999   --connbytes-dir both --connbytes-mode bytes
	iptables -t mangle -A traff_$MAC -m connbytes --connbytes  997999:999999  --connbytes-dir both --connbytes-mode bytes
	iptables -t mangle -A traff_$MAC -m connbytes --connbytes 9997999:9999999 --connbytes-dir both --connbytes-mode bytes
	
	iptables -t mangle -A traff_users -m mac --mac-source $MAC -j traff_$MAC
	iptables -t mangle -A traff_users -d $IP                   -j traff_$MAC	# must be IP, not HNA!
	
	for ENTRY in $( _pfilter l7proto_list ); do {
		PROTO="${ENTRY%,*}"		# PORT="${ENTRY#*,}"
	
		iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id )/0xFF	-j shaper
		iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id )/0xFF	-j LOG --log-prefix "layer7_${PROTO}: "
		iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id )/0xFF	-j RETURN
	} done
	
	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j shaper				# unknown traffic
	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j LOG --log-prefix "layer7_UNKNOWN: "
	iptables -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j RETURN

	_pfilter user_splash_control nosplash $MAC $IP
	
	_log do $FUNC daemon info "filling user chain - end"
}

_pfilter_rules_install () {	# connbytes auswerten: http ab 200k = langsame klasse/download?
	_pfilter_kmodules_init			# connection-aufbau /pro user /pro zeiteinheit limitieren
						# connections /pro user limitieren
						# icmp /ping pro user /pro zeiteinheitlimitieren
						# unabhaengig von einteilung bestimmte packet trotzdem in prio veraendern (ACK...)
	local MYHNA="$( _config get net olsr hna4 )"
						
	_log do pfilter daemon info "(_pfilter rules_install) Installing"

	iptables -t mangle -N marking
	iptables -t mangle -N marking_unmarkable
	iptables -t mangle -N marking_layer7
	iptables -t mangle -N traff_all
	iptables -t mangle -N traff_users
	iptables -t mangle -N shaper

	iptables -A FORWARD -m mark --mark $( _pfilter proto2id REJECT )          -j REJECT
	iptables -A FORWARD -m mark --mark $( _pfilter proto2id CONN_ABOVE )/0xFF -j REJECT  # --reject-with tcp-reset (does not work?)
	iptables -A FORWARD -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE                                -j ACCEPT
	iptables -A FORWARD -m state --state ESTABLISHED,RELATED             -j ACCEPT
# maybe let already marked traffic go trough?
	iptables -A FORWARD -m ipp2p --ipp2p                                 -j LOG --log-prefix "ip_p2p: "
	iptables -A FORWARD -m ipp2p --ipp2p                                 -j DROP
	iptables -A FORWARD -m state --state NEW                             -j ACCEPT

	iptables -t mangle -A FORWARD -s ! $MYHNA -d ! $MYHNA  -j ACCEPT				# forwarding (but not my own forwarding)
	iptables -t mangle -A FORWARD -m mark ! --mark 0       -j ACCEPT				# already marked in e.g. PREROUTING
	iptables -t mangle -A FORWARD                          -j CONNMARK --restore-mark		# trying to get mark from maybe already known connection
	iptables -t mangle -A FORWARD -m connmark ! --mark 0x0 -j traff_all				# connection known/marked? then goto traff_all
	iptables -t mangle -A FORWARD                          -j marking				# connection not known! try to mark

	iptables -t mangle -A traff_all
	iptables -t mangle -A shaper    -j ACCEPT

	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 85:1500					-j RETURN
	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 0:40 --tcp-flags RST,URG     RST	-j MARK --set-mark $( _pfilter proto2id SMALL )
	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 0:52 --tcp-flags ACK,URG     ACK	-j MARK --set-mark $( _pfilter proto2id SMALL )
	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 0:64 --tcp-flags SYN,URG     SYN	-j MARK --set-mark $( _pfilter proto2id SMALL )
	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 0:64 --tcp-flags ACK,SYN,URG ACK,SYN	-j MARK --set-mark $( _pfilter proto2id SMALL )
	iptables -t mangle -A marking_unmarkable -p icmp -m length --length 84					-j MARK --set-mark $( _pfilter proto2id SMALL )	# ping
#	iptables -t mangle -A marking_unmarkable -m mark ! --mark 0							-j LOG --log-prefix "layer7_small: "
#	iptables -t mangle -A marking_unmarkable -m mark ! --mark 0							-j RETURN

	for ENTRY in $( _pfilter l7proto_list ); do {
		PROTO="${ENTRY%,*}"
	#	PORT="${ENTRY#*,}"
		
		_log do pfilter daemon info "(layer7-filter) Installing protocol $PROTO"
		
		iptables -t mangle -A marking_layer7 -m layer7 --l7proto $PROTO		-j MARK --set-mark $( _pfilter proto2id )
	#	iptables -t mangle -A marking_layer7 -m mark ! --mark 0			-j LOG --log-prefix "layer7_${PROTO}: "
		iptables -t mangle -A marking_layer7 -m mark ! --mark 0			-j RETURN
		iptables -t mangle -A traff_all      -m mark --mark $( _pfilter proto2id )/0xFF	-j traff_users
	} done

	iptables -t mangle -A marking_layer7 -j LOG --log-prefix "layer7_end: "
	
	iptables -t mangle -A traff_all -m mark --mark $( _pfilter proto2id UNKN )/0xFF -j traff_users	# list unknown traffic
	iptables -t mangle -A traff_all                                            -j traff_users
	iptables -t mangle -A traff_all                                            -j shaper
	
	iptables -t mangle -A marking -m mark ! --mark 0			-j traff_all					# already marked in prerouting?
	iptables -t mangle -A marking					-j marking_unmarkable				# fixme!
#	iptables -t mangle -A marking -m mark --mark $(_pfilter proto2id SMALL)	-j MARK --set-mark 0
	iptables -t mangle -A marking -m mark ! --mark 0			-j marking_layer7				# trying all layer7-filters
	iptables -t mangle -A marking -m mark ! --mark 0			-j CONNMARK --save-mark				# layer7-matching was successful!
	iptables -t mangle -A marking -m mark ! --mark 0			-j traff_all					# goto traff_all
	iptables -t mangle -A marking					-j MARK --set-mark $( _pfilter proto2id UNKN )	# mark unknown traffic
	iptables -t mangle -A marking					-j traff_all
}

_pfilter_kmodules_init ()	# fixme! alles durch _iptables () schleifen und erst bei bedarf laden
{
	local MODULE
	local LIST_MATCH="conntrack connbytes connlimit connmark udplimit length layer7 ipp2p ttl"
	local LIST_CONNTRACK="ftp irc sip h323 amanda proto_gre pptp rtsp tftp"
	local LIST_JUMP="CONNMARK CLASSIFY ULOG"
	local LIST_SCHEDULER="cbq"			# tc-scheduler: [C]lass [B]ased [Q]ueueing | http://man-wiki.net/index.php/8:tc-cbq

	_list_add_prefix ()
	{
		local PREFIX="$1"
		local LIST="$2"
		local OBJ

		for OBJ in $LIST; do {
			echo -n "${PREFIX}${OBJ} "
		} done
	}

	LIST_MATCH="$(		_list_add_prefix ipt_		"$LIST_MATCH"		)"
	LIST_CONNTRACK="$(	_list_add_prefix ip_conntrack_	"$LIST_CONNTRACK" 	)"	
	LIST_JUMP="$(		_list_add_prefix ipt_		"$LIST_JUMP"		)"
	LIST_SCHEDULER="$(	_list_add_prefix sch_		"$LIST_SCHEDULER"	)"
	
	for MODULE in ${LIST_MATCH} ${LIST_CONNTRACK} ${LIST_JUMP} ${LIST_SCHEDULER}; do {
		_system insmod $MODULE
	} done
}

_pfilter_user_splash_add ()
{
	local MYHNA="$( _config get net olsr hna4 )"

	_log do pfilter daemon info "(_pfilter user_splash_add) shutting doors"

	iptables -t mangle -A PREROUTING -p udp --sport 68 --dport 67 -d 255.255.255.255 -j ACCEPT		# DCHP requests to internal server
	iptables -t mangle -A PREROUTING -s ! $MYHNA -d ! $MYHNA                         -j ACCEPT		# forwarding internet from other nodes
	iptables -t mangle -A PREROUTING -s ! $MYHNA                                     -j ACCEPT          # from other nodes to me
	
	# iptables -t mangle -A PREROUTING -d ! $MYHNA                                     -j ACCEPT          # dest = internet
	
	iptables -t mangle -A PREROUTING -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE	-j ACCEPT		# picopeer
	iptables -t mangle -A PREROUTING -p udp --dport 698                              -j ACCEPT		# OLSR incoming
	iptables -t mangle -A PREROUTING -p tcp -m multiport --dports 80,443             -j MARK --set-mark $( _pfilter proto2id REDIRECT )
	iptables -t mangle -A PREROUTING -m mark --mark 0                                -j MARK --set-mark $( _pfilter proto2id REJECT )

	iptables -t nat    -A PREROUTING -m mark --mark $( _pfilter proto2id REDIRECT )       -j REDIRECT
}

_pfilter_rules_accept_all ()
{
	local FUNC="all_chains_acceptance"
	local CHAIN
	local ARG="$1"
	local MODE="I"				# default = insert
	
	[ "$ARG" = "off" ] && MODE="D"		# delete

	for CHAIN in filter mangle; do {
		_log do $FUNC daemon debug "table '$CHAIN', switching '$ARG'"
		
		iptables -t $CHAIN -$MODE INPUT              -j ACCEPT
		iptables -t $CHAIN -$MODE FORWARD            -j ACCEPT
		iptables -t $CHAIN -$MODE OUTPUT             -j ACCEPT
		iptables -t $CHAIN -$MODE PREROUTING  -t nat -j ACCEPT
	      # iptables -t $CHAIN -$MODE POSTROUTING -t nat -j ACCEPT	# let masquerading work
		iptables -t $CHAIN -$MODE OUTPUT      -t nat -j ACCEPT
	} done
}

_pfilter_rules_olsr_whitelist_vars ()
{
	      OLSR_WL_FRESH="/tmp/olsr_whitelist_fresh"		# <unixtime>-Tags at first and last line
              OLSR_WL_READY="/tmp/olsr_whitelist"		# nodenumber,mac (mac can be empty)
              OLSR_WL_CHAIN="olsr_in_whitelist"			# for iptables
}

_pfilter_rules_olsr_whitelist_fetch () {
	_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_fetch) fetching"

	wget -qO $OLSR_WL_FRESH "$( _links firmware_url_get olsr_whitelist )"

	TAG1="$( head -n 1 $OLSR_WL_FRESH )"
	TAG2="$( tail -n 1 $OLSR_WL_FRESH )"

	if [ -n "$TAG1" ] && [ "$TAG1" = "$TAG2" ]; then
		_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_fetch) went fine, sanitizing"
		sed -e '/[<>]/d' -e 's/[^A-Fa-f0-9:,]//g' $OLSR_WL_FRESH >$OLSR_WL_READY	# removing lines with "<unixtime>" and sanitize LF/CR
	else
		_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_fetch) abort - something's wrong"
	fi

	rm -f $OLSR_WL_FRESH
}

_pfilter_rules_olsr_whitelist_update ()				# fixme! new MACs are never added until fw-full-restart (!)
{
	local FUNC="pfilter_rules_olsr_whitelist_update"

	[ ! -e "$OLSR_WL_READY" ] && {
		_log do $FUNC daemon debug "no whitelist - no update"
		return
	}
	
	local N=0
	local ESTIMATED="$(( 8 * $( cat $OLSR_WL_READY | wc -l ) / 10 ))"	# counting lines and multipling 0.8 seconds for each line for time-message in syslog
	
	_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_update) inserting new rules (needs up to $ESTIMATED seconds)"

	while read LINE; do {							# each line is: "nodenumber,mac" - mac can be empty
		
		IP="$( _ipsystem do ${LINE%,*} | sed -n 's/^WIFIADR=\(.*\)/\1/p' )"
		
		iptables -nL $OLSR_WL_CHAIN | grep -q "$( _sanitizer do "$IP" esacpe_dots )" || {	# IP not in list yet?
			MAC="${LINE#*,}"
		
			MACFILTER=""		
			test -n "$MAC" && MACFILTER="-m mac --mac-source $MAC"
				
			let N+=1
			iptables -A $OLSR_WL_CHAIN -s $IP $MACFILTER -j olsr_in_wifi_valid
		}

	} done <$OLSR_WL_READY

	iptables -D $OLSR_WL_CHAIN -j ACCEPT 2>/dev/null			       # deleting accept. of all packets, activating whitelist
	
	_log do $FUNC daemon info "installed $N rules"
}

_pfilter_rules_olsr_whitelist_optimize () {
	local  NO_NEIGH="/tmp/we_have_no_olsr_neighbour.txt"
	touch $NO_NEIGH
	
	test ! -e "$OLSR_WL_READY" && return

	_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_optimize) working"

	test -z "$( iptables -nL $OLSR_WL_CHAIN 2>/dev/null | grep ACCEPT )" && iptables -I $OLSR_WL_CHAIN -j ACCEPT	# temp. accept. of all packets

	iptables -nxvL $OLSR_WL_CHAIN |
	 sed -e '/^ *0/d' -e '/valid/!d' -e 's/\*/_/g' |							# filtering packetcount 0 and stars,
          sort |
           while read LINE; do                                                                                                      
		set $LINE
                
                IP="$8"
                MAC="$11"                                                                                                                      
                HOST="$( _net ip2hostname $IP )"
                NODE="$( _ipsystem do            $IP )"
						                                                    
                _log do pfilter daemon info "(_pfilter rules_olsr_whitelist_optimize) moveup: $IP node_$NODE $HOST ${1}_packets)"

		test -e $NO_NEIGH && rm -f $NO_NEIGH

                if [ -z "$MAC" ]; then                                                         		# without MAC
                        iptables -D $OLSR_WL_CHAIN                      -s $IP -j olsr_in_wifi_valid        # delete old rule
                        iptables -I $OLSR_WL_CHAIN --set-counters $1 $2 -s $IP -j olsr_in_wifi_valid        # insert new rule at the beginning, reinsert old values
                else                                                                                                                                   
                        iptables -D $OLSR_WL_CHAIN                      -s $IP -m mac --mac-source $MAC -j olsr_in_wifi_valid
                        iptables -I $OLSR_WL_CHAIN --set-counters $1 $2 -s $IP -m mac --mac-source $MAC -j olsr_in_wifi_valid
                        
                        _net arp_permanent $IP $MAC wifi
                fi                                 
        done      

	iptables -D $OLSR_WL_CHAIN -j ACCEPT 2>/dev/null 						# removing temp. accept. of all packets

	if [ -e "$NO_NEIGH" ]; then
		_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_optimize) really no neighbours!"
		_pfilter rules_olsr_whitelist_bypass 
	fi
}

_pfilter_rules_olsr_whitelist_errorcheck ()
{
	local FUNC="pfilter_rules_olsr_whitelist_errorcheck"
	local LINES_IN_WL_CHAIN="$( iptables -nxvL $OLSR_WL_CHAIN | grep all | wc -l )"		# the grep removes chain-headers
	local LINES_IN_WL_FILE="$(         cat $OLSR_WL_READY |            wc -l )"
	local OUT="false"

	if [ $LINES_IN_WL_CHAIN -lt $LINES_IN_WL_FILE ]; then
		OUT="true"
	else
		OUT="false"
	fi

	_log do $FUNC daemon info "$OUT (lines in: $LINES_IN_WL_FILE - lines real: $LINES_IN_WL_CHAIN)"

	echo $OUT
}

_pfilter_rules_olsr_whitelist_bypass ()
{
	_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_bypass ) executing"	

	iptables -I $OLSR_WL_CHAIN -j ACCEPT
}

_pfilter_rules_olsr_control ()
{
	local FUNC="control_olsr"
	local MYHNA="$( _config get net olsr hna4 )"

	_log do pfilter daemon info "($FUNC) Installing management"

	rm -f "$OLSR_WL_READY"									# to be sure, that this list must be reread

	# ----- creating user-chains: -----

	iptables -N olsr_in
	iptables -N olsr_in_wifi
	iptables -N olsr_in_wire
	iptables -N olsr_in_sanitizer
	iptables -N olsr_in_malformed
	iptables -N olsr_in_homebrew
	iptables -N $OLSR_WL_CHAIN
	iptables -N olsr_in_wifi_valid
	iptables -N olsr_in_wifi_invalid
	iptables -N olsr_in_wire_valid

	iptables -N olsr_out
	iptables -N olsr_out_wifi
	iptables -N olsr_out_wire

	iptables -t nat -N olsr_in
	iptables -t nat -N olsr_out

	# ----- incoming OLSR: -----
	
	iptables -A PREROUTING -t nat -p udp --dport 698   -j olsr_in				# to me
	iptables -A INPUT             -p udp --dport 698   -j olsr_in				# to me

	iptables -A olsr_in -t nat			       -j ACCEPT				# no further parsing in table nat
	iptables -A olsr_in -i $WIFIDEV                    -j olsr_in_wifi  			# wifi in
	iptables -A olsr_in                                -j olsr_in_wire				# wire in
	
	iptables -A olsr_in_wifi                           -j olsr_in_sanitizer			# are packets good?
	iptables -A olsr_in_wifi                           -j $OLSR_WL_CHAIN			# try to pass whitelist, or...
	iptables -A olsr_in_wifi                           -j olsr_in_wifi_invalid			# away
	
	iptables -A olsr_in_wire -i tap+		       -j ACCEPT				# from tap?
	iptables -A olsr_in_wire -i tun+		       -j ACCEPT				# from tun?
	iptables -A olsr_in_wire -i $LANDEV		       -j olsr_in_sanitizer			# from lan?
	iptables -A olsr_in_wire -i $LANDEV                -j olsr_in_wire_valid			# from lan and sanitized
	iptables -A olsr_in_wire            	       -j olsr_in_sanitizer			# must be WANDEV...
	iptables -A olsr_in_wire                           -j olsr_in_wire_valid			# count all valid
	
	iptables -A olsr_in_sanitizer -s $MYHNA            -j olsr_in_homebrew			# selfgenerated packets from me to me
	iptables -A olsr_in_sanitizer -s $WIFINET/$WIFIPRE  -p udp --sport 698 -j RETURN	# all ok, back to further parsing (later: -d 255.255.255.255)
	iptables -A olsr_in_sanitizer -i $LANDEV -p udp --sport 698 -j RETURN			# from LAN
	iptables -A olsr_in_sanitizer -i tap+   -p udp --sport 698 -j RETURN			# from tunnel, not that restrictiv
	iptables -A olsr_in_sanitizer		       -j olsr_in_malformed			# something is wrong
	
	iptables -A olsr_in_malformed -m limit --limit 1/hour -j LOG --log-prefix "olsr_in_malformed: "  # first log and then...
	iptables -A olsr_in_malformed                      -j DROP					# better not parse these packets
	
	iptables -A olsr_in_homebrew -i $WIFIDEV	       -j DROP                                  # from WIFI? we don't need these packets
	iptables -A olsr_in_homebrew -i $LANDEV            -j DROP					# from LAN?
	iptables -A olsr_in_homebrew                       -j DROP                                  # must be from WAN
	
	iptables -A $OLSR_WL_CHAIN			       -j ACCEPT				# later we have to fill this chain with MAC/IP-tupels

	iptables -A olsr_in_wifi_valid                     -j ACCEPT				# all went ok, let olsrd parse it
	iptables -A olsr_in_wire_valid                     -j ACCEPT				# the same for wire

	iptables -A olsr_in_wifi_invalid -m limit --limit 3/hour -j LOG --log-prefix "olsr_in_wifi_invalid: "	# not useable
	iptables -A olsr_in_wifi_invalid                 -j DROP				        # better not parse these packets

	# ----- outgoing OLSR: -----
	
	iptables -A POSTROUTING -t nat -p udp --dport 698  -j olsr_out				# from me

	#								# gives errors: 'kern.err olsrd[3923]: OLSR: sendto IPv4 Operation not permitted'
	# [ "$( _wifi get_mode )" != "adhoc" ] && {			# fixme! must be device-specific
	#	[ "$( nvram get fff_profile )" != "versilia_ap" ] && {
	#		_log do $FUNC daemon info "deactivating wifi-olsr"
	#		iptables -A OUTPUT -o $WIFIDEV -p udp --dport 698 -j DROP		# in AP-mode, keep air clean
	#	}
	# }

	iptables -A OUTPUT -p udp --dport 698	-j olsr_out		# from me

	iptables -A olsr_out -t nat		-j ACCEPT		# no further parsing in table nat
	iptables -A olsr_out -o $WIFIDEV	-j olsr_out_wifi	# wifi out
	iptables -A olsr_out			-j olsr_out_wire	# wire out

	iptables -A olsr_out_wifi		-j ACCEPT		# maybe doing some statistics here (size, speed ...)
	iptables -A olsr_out_wire		-j ACCEPT		# maybe doing some statistics here (size, speed ...)
}

_pfilter_l7proto_list ()
{
	local	LAYER7="ntp,123 shoutcast,8000 http,80 irc,6665:6669 ftp,21 ssh,22 telnet,23 dns,53 pop3,110 nntp,119 imap,143 validcertssl,443 ssl,993"
		LAYER7="$LAYER7 smtp,25 msnmessenger,1863 rdp,3389 aim,5190 jabber,5222"
		LAYER7="$LAYER7 yahoo,5050 vnc,5900:5902 halflife2-deathmatch,7001 quake-halflife,26970 sip,0 lpd,0 skypetoskype,0 skypeout,0"

	echo -n "$LAYER7"
}

_pfilter_rules_walledgarden ()
{
	local FUNC="walled_garden_insert"
	local ENTRY WALLED_GARDEN
	
	WALLED_GARDEN="141.54.160.24/32 (ping01) 141.54.1.1/32 (BUW-DNS) 141.1.1.1/32 (DFN) 85.25.251.231/32 (vorratsdatenspeicherung.de)"
	WALLED_GARDEN="${WALLED_GARDEN} 82.149.225.169/32 (wiki.vorratsdatenspeicherung.de) 141.54.160.48/32 (m18.uni-weimar.de)"                          
	WALLED_GARDEN="${WALLED_GARDEN} 87.118.106.19/32 (www.weimarnetz.de) 88.198.146.230/32 (wiki_neu)"                       
	WALLED_GARDEN="${WALLED_GARDEN} 213.239.220.3/32 (vekingosegundo.de) 217.238.197.73 (vekingosegundo.de2)"
	
	for ENTRY in $WALLED_GARDEN; do {				# accepting marked packets is done in main_framework
		
		if _sanitizer do "${ENTRY%/*}" ip4 check ; then		# we have to filter IPs from comments (only check before '/')
		
			_log do $FUNC daemon info "no fence for '$ENTRY'"
		
			iptables -t mangle -A PREROUTING -s $ENTRY -j ACCEPT
			iptables -t mangle -A PREROUTING -d $ENTRY -j ACCEPT
		else
			_log do $FUNC daemon info "human_readable: $ENTRY"
		fi
	} done
}

_pfilter_rules_nat_no_wificlients ()
{
	local FUNC="pfilter_rules_nat_no_wificlients"
	local WIFI_DHCP_NET="$( nvram get ff_wldhcp | cut -d, -f1 )"	

	[ -z "$WIFI_DHCP_NET" ] && return
	
	_log do $FUNC daemon info "removing rules"

	iptables -D POSTROUTING -t nat -s $WIFI_DHCP_NET -j MASQUERADE
}

_pfilter_rules_nat_install ()		# fixme! also masq traffic from local lan to internet during startup (atm only local wifi gets masq)
{
	local INETOFFER="$( _net local_inet_offer )"

	case $INETOFFER in
		lan)
			_pfilter rules_nat_inetoffer_lan
		;;
		tun|tun0)
			iptables -t nat -A POSTROUTING -o tun+ -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		tap)
			iptables -t nat -A POSTROUTING -o tap+ -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		wan)
			iptables -t nat -A POSTROUTING -o $WANDEV -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		pppoe)
			iptables -t nat -A POSTROUTING -o ppp+ -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		*)	
			# should'nt break anything: sometimes WANDEV is not up yet when packetfilter starts up
			
			local WANDEV="$( nvram get wan_device )"			
			[ -n "$WANDEV" ] && iptables -t nat -A POSTROUTING -o ${WANDEV} -d ! $WIFINET/$WIFIPRE -j MASQUERADE
			iptables -t nat -A POSTROUTING -o ppp+ -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
	esac
	
	_pfilter rules_nat_no_wificlients
	_pfilter rules_nat_wifi_roaming
	_pfilter rules_portfw_install
}

_pfilter_stats_chain_show ()
{
	local FUNC="packetfilter_show_chain_postrouting"
	local TABLE="$1"
	local CHAIN="$2"
	local LINE
	
	[ -z "$CHAIN" ] && {		# defaults to 'filter' like iptables-usage
		TABLE="filter"
		CHAIN="$1"
	}
	
	iptables -t $TABLE -nxvL $CHAIN | while read LINE; do {
		_log do $FUNC daemon debug "$LINE"
	} done
}
