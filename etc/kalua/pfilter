# tc qdisc add dev eth0 root handle 1: cbq avpkt 1000 bandwidth [HN]
# tc qdisc show

_ipt ()		# for better logging and safer installing - have seen strange errors during iptables-insert-storms
{
	local LOCKFILE="/tmp/iptables_lock"

	while [ -e "$LOCKFILE" ]; do {		# fixme! make a trap()
		sleep 1
	} done
	touch $LOCKFILE

	local FUNC="iptables"
	local ARGS="$1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16} ${17} ${18} ${19} ${20}"
	local ERRORFILE="/tmp/iptables_$$"
	local LINE CLEANUP MATCH JUMP FILE BUILTIN

	# idea: *--l7proto*) detect this?

# /lib/modules/2.4.30/ipt_DSCP.o
# /lib/modules/2.4.30/ipt_ECN.o
# /lib/modules/2.4.30/ipt_MIRROR.o
# /lib/modules/2.4.30/ipt_TARPIT.o
# /lib/modules/2.4.30/ipt_TOS.o
# /lib/modules/2.4.30/ipt_TTL.o
# /lib/modules/2.4.30/ipt_ah.o
# /lib/modules/2.4.30/ipt_dscp.o
# /lib/modules/2.4.30/ipt_ecn.o
# /lib/modules/2.4.30/ipt_esp.o
# /lib/modules/2.4.30/ipt_helper.o		# match conntrack-tracked conns by string
# /lib/modules/2.4.30/ipt_owner.o
# /lib/modules/2.4.30/ipt_physdev.o
# /lib/modules/2.4.30/ipt_pkttype.o
# /lib/modules/2.4.30/ipt_recent.o
# /lib/modules/2.4.30/ipt_string.o
# /lib/modules/2.4.30/ipt_tcpmss.o
# /lib/modules/2.4.30/ipt_tos.o
# /lib/modules/2.4.30/ipt_unclean.o

# /usr/lib/iptables/libipt_*

	case "$ARGS" in
		*\ -m\ *)
			MATCH="$( echo "$ARGS" | sed -n 's/^.* -m \([a-z0-9]*\) .*/\1/p' )"

			[ -n "$MATCH" -a ! -e /tmp/iptables_match_$MATCH ] && {

				FILE="/usr/lib/iptables/libipt_${MATCH}.so"

				_log do $FUNC daemon debug "detected match '$MATCH' for first time"
				touch /tmp/iptables_match_$MATCH
			
				case "$MATCH" in
					conntrack|connlimit|connmark|connbytes|udplimit|length|layer7|ipp2p|ttl)
						_system insmod ipt_$MATCH
					;;
					state|limit|mac|mark|multiport)
						:
					;;
				esac
				
				if [ -e "$FILE" ]; then
					_log do $FUNC daemon debug "match '$MATCH' exists and is automatically loaded (or builtin)"
				else
					_log do $FUNC daemon debug "match '$MATCH' does not exist ('$FILE')"
				fi
			}
		;;
	esac
	
	case "$ARGS" in
		*\ -j\ *)	
			JUMP="$( echo "$ARGS" | sed -n 's/^.* -j \([A-Z]*\).*/\1/p' )"
			
			[ -n "$JUMP" -a ! -e /tmp/iptables_jump_$JUMP ] && {
	
				FILE="/usr/lib/iptables/libipt_${JUMP}.so"
	
				_log do $FUNC daemon debug "detected jump '$JUMP' for first time"
				touch /tmp/iptables_jump_${JUMP}
	
				case "$JUMP" in
					CONNMARK|CLASSIFY|ULOG|REDIRECT)
						_system insmod ipt_$JUMP
					;;
					ACCEPT|DROP|LOG|MASQUERADE|RETURN)
						BUILTIN=1
					;;
					REJECT|MARK)
						:
					;;
				esac
				
				if [ -e "$FILE" -o "$BUILTIN" = "1" ]; then
					_log do $FUNC daemon debug "jump '$JUMP' exists and is automatically loaded (or builtin)"
				else
					_log do $FUNC daemon debug "jump '$JUMP' does not exist ('$FILE')"
				fi
			}
		;;
	esac
	
	iptables $ARGS 2>$ERRORFILE || {
		_log do $FUNC daemon debug "something went wrong: '$ARGS' - retry"
		sleep 1
		iptables $ARGS 2>$ERRORFILE || {
			_log do $FUNC daemon info "giving up: '$ARGS'"
			CLEANUP=1
		}
	}

	[ -e $ERRORFILE ] && {
		while read LINE; do {
			_log do $FUNC daemon info "former error: '$LINE' (ARGS: '$ARGS')"
			
			case "$LINE" in
				"iptables: No chain/target/match by that name")
					_log do $FUNC daemon info "trap reached"	# fixme! try to list chain?
				;;
			esac
			
		} done <$ERRORFILE

		rm $ERRORFILE
	}
		
	rm $LOCKFILE
	return ${CLEANUP:-0}
}

_pfilter_user_splash_remove ()
{
	local MAC="$1"
	local IP="$2"

	[ -z "$MAC" -o -z "$IP" ] && return 1
								# user is known, but splashed
	_pfilter user_list | grep -q -i $MAC && {
		_pfilter user_splash_control nosplash $MAC $IP >/dev/null
		return
	}

	_pfilter user_ruleset_activate $MAC $IP || {		# user is new and splashed
		_pfilter user_add $MAC $IP
	}
}

_pfilter_rules_webserver_deny_incoming_nonlocal ()
{
	local FUNC="pfilter_rules_webserver_deny_incoming_nonlocal"
	local MYHNA="$( _config get net olsr hna4 )"

	_log do $FUNC daemon info "activate blocking for HTTP(S) to avoid lowmem situations during software-install"

	_ipt -I INPUT -p tcp -s ! $MYHNA  --dport  80 -j DROP		# if REJECT is not possible, then method DROP is fallback
	_ipt -I INPUT -p tcp -s ! $MYHNA  --dport 443 -j DROP

	_ipt -I INPUT -p tcp -s ! $MYHNA  --dport  80 -j REJECT
	_ipt -I INPUT -p tcp -s ! $MYHNA  --dport 443 -j REJECT

	_ipt -I INPUT -p tcp -s 127.0.0.1 --dport  80 -j ACCEPT
	_ipt -I INPUT -p tcp -s 127.0.0.1 --dport 443 -j ACCEPT
}

_pfilter_user_ruleset_activate ()
{
	local FUNC="pfilter_user_ruleset_activate"
	local MAC_RESERVE
	local MAC_RESERVE_LIST="99:99:99:99:99:99 99:99:99:99:99:98 99:99:99:99:99:97 99:99:99:99:99:96 99:99:99:99:99:95"
	local MAC="$1"
	local IP="$2"

	for MAC_RESERVE in $MAC_RESERVE_LIST; do {

		iptables -t mangle -E traff_${MAC_RESERVE} traff_$MAC 2>/dev/null && { 			# fixme! how to use _ipt()
	
			_log do $FUNC daemon info "found chain traff_${MAC_RESERVE} and renamed to 'traff_$MAC'"
			
			_ipt -t mangle -D traff_users -m mac --mac-source $MAC_RESERVE	-j traff_$MAC
			_ipt -t mangle -D traff_users -d 99.99.99.99			-j traff_$MAC

			_ipt -t mangle -D traff_$MAC 12
			_ipt -t mangle -I traff_$MAC 12 -m mark --mark $( _pfilter proto2id CONN )/0xFF -j ULOG --ulog-prefix "${MAC}>"	# inside2outside
			_ipt -t mangle -D traff_$MAC 19
			_ipt -t mangle -I traff_$MAC 19 -m mark --mark $( _pfilter proto2id CONN )/0xFF -j ULOG --ulog-prefix "${MAC}<"	# outside2inside

			_ipt -t mangle -A traff_users -m mac --mac-source $MAC		-j traff_$MAC
			_ipt -t mangle -A traff_users -d $IP				-j traff_$MAC

			_net arp_permanent $IP $MAC
			_pfilter user_splash_control nosplash $MAC $IP		
		
			_log do $FUNC daemon info "successfully activated 'traff_$MAC'"

			_scheduler add "/etc/local.fw-fff+ adduser_reserve $MAC_RESERVE 99.99.99.99"
			return 0
		}

		_log do $FUNC daemon debug "renaming chain 'traff_${MAC_RESERVE}' to 'traff_$MAC' didn't work"
		_scheduler add "/etc/local.fw-fff+ adduser_reserve $MAC_RESERVE 99.99.99.99"
		
		[ "$MAC_RESERVE" = "99:99:99:99:99:95" -a ! -e "/tmp/USER_PACKETFILTER" ] && {
			touch /tmp/USER_PACKETFILTER
			_scheduler add "/etc/local.fw-fff+ close_doors"
		}
	} done
	
	return 1
}

_pfilter_stats_rules_count ()
{
	local LIST="${1:-mangle filter nat}"
	local OPTION="$2"			# POSTROUTING
	local TABLE COUNT
	
	for TABLE in $LIST; do {
		COUNT="$( iptables -t $TABLE -nxL $OPTION | sed -e '/^target/d' -e '/^Chain /d' -ne '/[^.]$/p' | sed -n '$=' )"
		_log do packetfilter_count_rules daemon debug "$COUNT rules in '$TABLE' $OPTION"
	} done
}

_pfilter_rules_portfw_install ()
{
	local FUNC="pfilter_rules_portfw_install"
	local ENTRY
	local PROTO
	local PORTFORWARDING="$( nvram get fff_portfw )"
	local MYHNA="$( _config get net olsr hna4 )"

	_ipt -I FORWARD -i $WANDEV -d $MYHNA -j ACCEPT

	for ENTRY in $PORTFORWARDING; do {
	
		eval $( _pfilter rules_portfw_config_serialize $ENTRY )
		
		[ $RULE_ACTIVE = "on" ] && {
		
			case $RULE_INCOMING_INTERFACE in
				 wan) RULE_INCOMING_INTERFACE="-i $WANDEV"	;;
				 lan) RULE_INCOMING_INTERFACE="-i $LANDEV"	;;
				wifi) RULE_INCOMING_INTERFACE="-i $WIFIDEV"	;;
			     tun|tap) RULE_INCOMING_INTERFACE="-i ${RULE_INCOMING_INTERFACE}+" ;;
				   *) RULE_INCOMING_INTERFACE=""		;;
			esac

			[ $RULE_DEST_IP = "me" ] && RULE_DEST_IP=		# this works!
			[ $RULE_PROTO = "both" ] && RULE_PROTO="tcp udp"
			
			for PROTO in $RULE_PROTO; do {
				
				RULE_ACTIVE="-t nat -I PREROUTING $RULE_INCOMING_INTERFACE -p $PROTO --dport $RULE_PORT_INCOMING -j DNAT --to-destination $RULE_DEST_IP:$RULE_PORT_DEST"
				
					if _ipt $RULE_ACTIVE ; then
				     		_log do $FUNC user info "success adding rule '$RULE_NAME'"
				     	else
				     		_log do $FUNC user err  "error adding rule '$ENTRY' ('_ipt $RULE_ACTIVE')"
				     	fi
			} done
		}
	} done
}

_pfilter_rules_dhcp_ignore_specific_macs ()	# SENS: mario
{
	local FUNC="pfilter_rules_dhcp_ignore_specific_macs"
	local MAC
	
	for MAC in $( nvram get fff_dhcp_ignore ); do {		# format: 'MAC1 MAC2 MACn"

		_log do $FUNC daemon debug "ignoring '$MAC'"
		_ipt -I INPUT -p udp --sport 68 -d 255.255.255.255 --dport 67 -m mac --mac-source $MAC -j DROP
	} done
}

_pfilter_rules_portfw_config_serialize ()
{
	# like in DD-WRT (but with incoming interface!)

	# name:active:incoming_interface:proto:dport>dest_ip:dest_port name:...
	# name:on/off:any/wan/lan/wifi:tcp/udp/both:dport>dest_ip:dest_port name:...

	# emule:off:wan:both:4661>10.63.45.100:4661
	# webcam:on:any:tcp:8080>10.63.168.97:80
	# myssh:on:wan:tcp:10022>me:22
	
	echo $1 | sed 's/\(.*\):\(.*\):\(.*\):\(.*\):\(.*\)>\(.*\):\(.*\)/local RULE_NAME=\1\nlocal RULE_ACTIVE=\2\nlocal RULE_INCOMING_INTERFACE=\3\nlocal RULE_PROTO=\4\nlocal RULE_PORT_INCOMING=\5\nlocal RULE_DEST_IP=\6\nlocal RULE_PORT_DEST=\7/'

	# output is like:
	# local RULE_NAME=webcam
	# local RULE_ACTIVE=on
	# local RULE_INCOMING_INTERFACE=all	// wan,lan,wifi,all/any
	# local RULE_PROTO=tcp
	# local RULE_PORT_INCOMING=8080
	# local RULE_DEST_IP=10.63.168.97	// ip4 or 'me' = myself
	# local RULE_PORT_DEST=80
}

_pfilter_stats_user_traffic_list_today ()
{
	local   MEDIA=""
	local TRAFFIC=0	
	local MACLIST="$( _pfilter user_list )"

	for MAC in $MACLIST; do {
	
		TRAFFIC="$( _pfilter stats_user_traffic $MAC today )"
	
		[ "$TRAFFIC" != "0" ] && {
		
			TRAFFIC="$( _math bytes2unit "$TRAFFIC" mb )"
		
			  MAC="$( echo $MAC | sed 's/://g' )"
			MEDIA="$( _net mac2media $MAC short )"
				
			echo -en "${MEDIA}${MAC}:${TRAFFIC}"
		}
	} done
}

_pfilter_rules_nat_wifi_roaming ()
{
	local FUNC="pfilter_rules_nat_wifi_roaming"
	
	_log do $FUNC daemon info "masquerading outgoing wifi '$WIFIDEV'"

	eval "$( _ipsystem do | grep ^ROAMING_ )"

	_ipt -t nat -A POSTROUTING -o $WIFIDEV -s $ROAMING_IP4/$ROAMING_PRE -j MASQUERADE	# or SNAT?
}

_pfilter_user_probe_local_blacklist ()
{
	local MAC="$1"

	nvram get fff_ethers_blocked | grep -q -i $MAC && return 0
	return 1
}

_pfilter_rules_nat_inetoffer_lan ()		# SENS: masquerades traffic over lan-device for omitting "black hole"
{						#       and fetches IP from local DHCP-server, if gateway-IP is not from local IP-range
	local FUNC="pfilter_rules_nat_inetoffer_lan"
	_log do pfilter daemon info "($FUNC) working"

	local GATEWAY="$( nvram get lan_gateway )"
	local COUNTER=0
												# is lan_gateway an alien network?
												# then add alien-ip-range to alias-interface...

	if [ -n "$GATEWAY" ] && [ -z "$( ip route list exact 0/0 via $GATEWAY )" ]; then	# def_route could'nt be set by /sbin/ifup
												# because kernel has no suiteable interface for gw
		while [ $COUNTER -lt 5 ]; do {
			_log do pfilter daemon info "($FUNC) detected alien LAN-gateway, trying to fetch DHCP-address"
			local ALIASIP="$( udhcpc -qfn --interface="$LANDEV:fantasy" 2>/dev/null | sed -n 's/.* \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .*/\1/p' )"
			[ -n "$ALIASIP" ] && break
			_log do pfilter daemon info "($FUNC) no alias-ip - trying again in 10 sec"
			sleep 10
			COUNTER=$(( $COUNTER + 1 ))		# fixme! even with "LAN:fantasy" /etc/resolv.conf gets applied, rewrite?
		} done
		
		[ -z "$ALIASIP" ] && {
			
			# last octett is now hard set to 234, so when
			# gateway is 192.168.178.1   , we set
			#            192.168.178.234 on our LAN-address		# fixme! uiuiui! what when lan_gateway is not reachable anymore?
			
			ALIASIP="$( echo $GATEWAY | sed -n 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\..*/\1.\2.\3.234/p' )"
			
			_log do pfilter daemon info "($FUNC) couldt fetch IP-address from LAN-DHCP-server, guessing"
		}
		
		_log do pfilter daemon info "($FUNC) using alienip '$ALIASIP' to reach gateway"
		
		local ALIASPRE="$( ipcalc -p $ALIASIP           | sed -n 's/PREFIX=\(.*\)/\1/p' )"
		local ALIASNET="$( ipcalc -n $ALIASIP/$ALIASPRE | sed -n 's/NETWORK=\(.*\)/\1/p' )"
		local LANNET="$ALIASNET"
		local LANPRE="$ALIASPRE"

		_log do pfilter daemon info "($FUNC) local alien-address gateway"
		_log do pfilter daemon info "($FUNC) adding $ALIASIP/$ALIASPRE on $LANDEV:aliennet"
		_log do pfilter daemon info "($FUNC) adding default route"
		
		ip address add $ALIASIP/$ALIASPRE   dev $LANDEV label $LANDEV:aliennet
		ip route   add default via $GATEWAY dev               $LANDEV metric 0

		# fixme! apply now static_routes, which could be used till now?
	
		if [ "$?" -ne 0 ]; then
			_log do pfilter daemon info "($FUNC) error adding default route"
		else
			_log do pfilter daemon info "($FUNC) success adding default route"	# fixme! why we restart vpn?
			/etc/init.d/S*vpn* restart				# uiuiui! better use an central
										# function to automatically ifup/down
										# vpn-connection (cron.minutely hna4-hook?)
		fi
	fi	
	
	_ipt -A POSTROUTING -t nat -o $LANDEV  -s ! $LANNET/$LANPRE -j MASQUERADE
	_ipt -A POSTROUTING -t nat -o $WIFIDEV -s   $LANNET/$LANPRE -j MASQUERADE

	_pfilter stats_rules_count nat POSTROUTING
	_log do pfilter daemon info "($FUNC) done"
}

_pfilter_user_traffic_limit ()
{
	local MAC="$1"
	
	[ -z "$MAC" ] && {
		echo 0
		return
	}
	
	local OUT=0								# traffic variables are known from /etc/variables_fff+
	local WIFI_MODE="$( _wifi mode )"
	local MEDIA="$( _net mac2media $MAC )"
	
	_pfilter user_list_local_registered | grep -q -i $MAC
										# now we make differences for anonym or locally registered
										# and wire / wireless / wireless_in_non-mesh-disturbing ap-mode (other channel!)
										
	if [ "$?" -eq 0 ]; then							# locally registered
	
		if [ "$MEDIA" = "wire" ] || [ "$WIFI_MODE" = "ap" ] ; then	# locally registered, wire or AP
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f4 )"
		else								# locally registered, wifi
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f3 )"
		fi
	else
		if [ "$MEDIA" = "wire" ] || [ "$WIFI_MODE" = "ap" ]; then	# anonym, wire or AP
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f2 )"
		else								# anonym, wifi
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f1 )"
		fi
	fi

	echo "${OUT:-2500}000000"						# convert MBytes in Bytes 8-)
}

_pfilter_stats_user_traffic_used_percent ()		# ARG1: mac-address
{									# OUT1: integer - can be higher then 100% (!)
	local MAC="$1"
	local STEP1
	local STEP2
	local STEP3
	
	_pfilter user_list | grep -q -i $MAC || {
		echo "0"
		return
	}

	STEP1="$( _pfilter stats_user_traffic $MAC today )"					# hint: traffic_today * 100 / traffic_limit
	STEP2="$( _pfilter user_traffic_limit $MAC )"	#       is the same like:
	STEP3="$( _math divide100 $STEP2 )"						#       traffic_today / (traffic_limit/100)

	echo $(( $STEP1 / $STEP3 ))							#       doing it this way we avoid big numbers during bash-calculation
}

_pfilter_user_splash_remove_autounsplashed ()
{
	local FUNC="pfilter_user_splash_remove_autounsplashed"
	local ENTRY MAC IP
	local LIST="$( grep "^..:..:..:..:..:.. free-" /etc/ethers ; grep "^..:..:..:..:..:.. admin-" /etc/ethers)"

	_log do $FUNC daemon info "checking"

	for ENTRY in $LIST; do {					# MAC NAME MAC NAME ...

		if   _sanitizer do "$ENTRY" mac check ; then
			MAC=$ENTRY					# remember for next loop-cycle
		else
			IP="$( fgrep "$ENTRY" /etc/local.hosts | cut -d" " -f1 )"	# is a hack!

			_log do $FUNC daemon info "adding name/mac/ip '$NAME' / '$IP' / '$MAC'"

			_pfilter user_add $MAC $IP
		fi
	} done
}

_pfilter_user_splash_add_for_nonautounsplashed ()
{
	local FUNC="pfilter_user_splash_add_for_nonautounsplashed"
	local LIST="$( _pfilter user_list )"

	for MAC in $LIST; do {
		
		_pfilter user_probe_splash $MAC || {
			
			_pfilter user_probe_autounsplashed $MAC || {
				_log do $FUNC daemon debug "kicking '$MAC'"
				_pfilter user_splash_control splash $MAC "$( _net mac2ip $MAC )"
			}
		}
	} done
}

_pfilter_user_kick_overlimit ()
{
	local FUNC="pfilter_user_kick_overlimit"
	local LIST="$( _pfilter user_list )"
	local LIMIT
	local PERCENT
	local MAC

	for MAC in $LIST; do {

		[ "$( _pfilter stats_user_traffic $MAC today )" != "0" ] && {	# very fast check
		
			_pfilter user_probe_splash $MAC || {
		
				_pfilter user_probe_admin $MAC || {
		
					PERCENT="$( _pfilter stats_user_traffic_used_percent $MAC )"
					_log do $FUNC user debug "'$MAC'-traffic is ${PERCENT}%"
				
					[ $PERCENT -gt 100 ] && {
						LIMIT="$( _pfilter user_traffic_limit $MAC )"
						LIMIT="$( _sanitizer do "$LIMIT" number_humanreadable )"
						_log do $FUNC user info " -'$MAC' (traffic: ${PERCENT}% ~${LIMIT} bytes)"
						_pfilter user_splash_control splash $MAC "$( _net mac2ip $MAC )"
					}
				}
			}
		}
	} done
}

_pfilter_user_traffic_reset ()
{
	local FUNC="pfilter_user_traffic_reset"
	local LIST="$( _pfilter user_list )"
	local MAC
	
	for MAC in $LIST; do {
		_pfilter user_traffic_reset_single $MAC today	
	} done
}

_pfilter_stats_olsr_traffic_wifi_in ()
{
	local PACK BYTES REST
	
	iptables -nxvL olsr_in 2>/dev/null | head -n3 | tail -n1 | while read PACK BYTES REST; do echo -n ${BYTES:-0}; done
}

_pfilter_stats_olsr_traffic_wifi_out ()
{
	local PACK BYTES REST
	
	iptables -nxvL olsr_out_wifi 2>/dev/null | tail -n1 | while read PACK BYTES REST; do echo ${BYTES:-0}; done
}

_pfilter_stats_layer7_hits ()
{
	local PACK BYTES REST
	
	local ALL_BYTES="$(      iptables -t mangle -nxvL FORWARD | grep "CONNMARK restore" | while read PACK BYTES REST; do echo $BYTES; done )"
	local RESTORED_BYTES="$( iptables -t mangle -nxvL FORWARD | grep "CONNMARK match"   | while read PACK BYTES REST; do echo $BYTES; done )"
	local MATCHED_BYTES="$(  iptables -t mangle -nxvL marking | grep "CONNMARK"         | while read PACK BYTES REST; do echo $BYTES; done )"

	which awk >/dev/null || {
		echo 0
		return
	}
	awk -v A=$ALL_BYTES -v R=$RESTORED_BYTES -v M=$MATCHED_BYTES 'BEGIN{ printf("%.2f",(R+M)*100/A) }'

	# local STEP1="$(( $RESTORED_BYTES + $MATCHED_BYTES ))"
	# local STEP2="$(( $ALL_BYTES / 1000 ))"
	# _math divide10 "$(( $STEP1 / $STEP2 ))"
}

_pfilter_stats_user_cast ()
{
	local KEYWORD="$1"			# ARG1: 'spread' = data goes out to $GW and $NEXTHOP
	local LIST="$( _pfilter user_list )"
	local URL MSG DATE TIME TRAFF_RECENT TRAFF_TODAY TRAFF_ALL MEDIA NAME NODE REG OUTPUT MAC GW NEXTHOP

	eval "$( tail -n 1 /tmp/ARCHIV_TRACEINET )"

	for MAC in $LIST; do {

		DATE="$( _system date humanreadable )"
		TIME="$( _system date unixtime	    )"
			
		TRAFF_RECENT="$( _pfilter stats_user_traffic $MAC recent )"

		[ $TRAFF_RECENT -ne 0 ] && {
			_pfilter user_traffic_reset_single $MAC recent
		}

		TRAFF_TODAY="$(  _pfilter stats_user_traffic $MAC today  )"
		TRAFF_ALL="$(    _pfilter stats_user_traffic $MAC all    )"
			
		MEDIA="$( _net mac2media    $MAC )"
		NAME="$(  _net mac2hostname $MAC )"
		NODE="local"
		REG=0
	
		OUTPUT="NODE=$NODE TIME=$TIME DATE=$DATE MAC=$MAC NAME=$NAME REG=$REG MEDIA=$MEDIA TRAFF_RECENT=$TRAFF_RECENT TRAFF_TODAY=$TRAFF_TODAY TRAFF_ALL=$TRAFF_ALL"

		MAC="$( _sanitizer do "$MAC" mac lowercase urlvalue )"

		[ "$KEYWORD" = "spread" -a $TRAFF_RECENT -gt 0 ] && {

			echo $OUTPUT				# fixme! better _log()?
			echo $OUTPUT >>/tmp/ARCHIV_TRAFFIC

			URL="http://$GW/cgi-bin-traffic_fff+?"
			MSG="MAC=${MAC}&NAME=${NAME}&REG=${REG}&MEDIA=${MEDIA}&TRAFF_RECENT=${TRAFF_RECENT}&TRAFF_TODAY=${TRAFF_TODAY}&TRAFF_ALL=${TRAFF_ALL}"

			_wget do "${URL}${MSG}" 5 >/dev/null
			
			[ "$GW" != "$NEXTHOP" ] && {
				URL="http://$NEXTHOP/cgi-bin-traffic_fff+?"				
				_wget do "${URL}${MSG}" 5 >/dev/null
			}
		}
	} done
}

_pfilter_user_probe ()
{
	local MAC="${1:-unset}"
	
	iptables -t mangle -nL traff_${MAC} >/dev/null 2>/dev/null && return 0		# not using _ipt()
	return 1
}

_pfilter_user_list ()					# SENS: list all MACs from logged in / shaped users
{
	iptables -t mangle -nL traff_users 2>/dev/null |
	 sed -n 's/^traff_\([0-8abcdef][0-8abcdef]:..:..:..:..:..\) .*MAC .*$/\1/p'	# must not begin with '99' (=reserved user)
}

_pfilter_user_list_blocked ()
{
	IFS=";"
	for MAC in $( nvram get fff_ethers_blocked ); do {
		echo "$MAC"
	} done
	unset IFS
}

_pfilter_user_list_dhcp_active ()
{
	sed -n 's/^.* \(..:..:..:..:..:..\) .*/\1/p' /var/run/dhcp.leases	# is lowercase (dnsmasq)
}

_pfilter_user_list_local_registered ()
{
	local MAC
	
	IFS=";"
	for MAC in $( nvram get fff_ethers_wifi ) $( nvram get fff_ethers_lan ); do {
		echo "${MAC%=*}"				# print word before "="
	} done
	unset IFS
}

_pfilter_user_traffic_reset_single ()
{
	local FUNC="pfilter_user_traffic_reset_single"
	local MAC="$1"
	local RULE_NUM="$2"
	local LOGPRIO="info"
	
	case $RULE_NUM in
		recent) RULE_NUM=2
			LOGPRIO="debug"		# last 15min
		;;
		 today) RULE_NUM=3		# today
		;;
		     *) RULE_NUM=4		# overall
		;;
	esac

	_log do $FUNC daemon $LOGPRIO "$MAC ('$2')"
	
	_ipt -R traff_$MAC $RULE_NUM -t mangle --set-counters 0 0
}

_pfilter_stats_traffic_forwarded_intranet ()
{
	local PACK BYTES REST
	
	iptables -nxvL FORWARD 2>/dev/null | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

_pfilter_stats_traffic_forwarded_internet ()	# fixme! empty chains -> output = "bytes", but should be '0'
{
	local PACK BYTES REST
	
	iptables -t mangle -nxvL FORWARD 2>/dev/null | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

_pfilter_stats_user_conns_start ()	# we don't use _ipt() abstraction because chains maybe does not exist / avoid syslog errors
{
	local MAC="$1"
	
	iptables -t mangle -nxvL traff_$MAC | fgrep "state NEW MARK set 0x91" | sed -n 's/^[^0-9]*\([0-9]*\)[^0-9]*.*/\1/p'
}

_pfilter_stats_user_conns_end ()
{
	local MAC="$1"

	iptables -t mangle -nxvL traff_$MAC | fgrep "flags:0x11/0x11 MARK" | tail -n1 | sed -n 's/^[^0-9]*\([0-9]*\)[^0-9]*.*/\1/p'
}

_pfilter_stats_user_conns_over_limit ()		# we count udp + tcp above's 	// fixme! what about adblock?
{
	local MAC="$1"
	local PACK=""
	local REST=""	

	iptables -t mangle -nxvL traff_$MAC | head -n 9 | tail -n 1 | while read PACK REST; do echo $PACK; done
}

_pfilter_stats_user_traffic ()	# OUT1: string
{
	local MAC="$1"
	local TIMESLOT="$2"
	local LINE
	
	case $TIMESLOT in
		recent) LINE="2" ;;	# last 15min
		today)  LINE="3" ;;	# today
		*)      LINE="4" ;;	# overall
	esac

	iptables -t mangle --line-numbers -nxvL traff_${MAC} | 
	 sed -n "/^${LINE} /s/^${LINE}[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p"
}

_pfilter_proto2id ()		# fixme! uses global var 'PROTO' + 'PORT'
{
	local N=0
	
	[ -n "$1" ] && {
		case $1 in
			PING)       N=98 ;;
			TRACE)      N=97 ;;
			NTP)        N=96 ;;
			FRAG)       N=95 ;;
			TTL0)       N=94 ;;
			UNREA)      N=93 ;;
			CONN_ABOVE) N=92 ;;
			CONN)       N=91 ;;
			GARDEN)     N=90 ;;
			REDIRECT)   N=89 ;;
			REJECT)     N=88 ;;
			DHCPIN)     N=87 ;;
			PICOPEER)   N=86 ;;
			GUESS)      N=85 ;;
			SMALL)      N=84 ;;
						
			*)          N=99 ;;
		esac
		
		echo -n "0x$N"
		return
	}
	
	for ENTRY in $( _pfilter l7proto_list ); do {		# fixme! this loop runs very often
	
		THIS_PROTO="${ENTRY%,*}"
		THIS_PORT="${ENTRY#*,}"

		[ -z "$PORT" ] && THIS_PORT=""
	
		let N+=1
		if [ "$PROTO" = "$THIS_PROTO" ] && [ "$PORT" = "$THIS_PORT" ]; then
			echo -n "0x$N"
			return
		fi
	} done
}

_pfilter_user_probe_admin ()
{
	local MAC="$1"
	local LIST="$( nvram get fff_ethers_lan ) $( nvram get fff_ethers_wifi )"
	
	echo $LIST | grep -qi "${MAC}=admin-" && return 0
	return 1
}

_pfilter_user_probe_autounsplashed ()		# free means no splashpage wished: username must begin with "admin-" or "free-"
{
	local MAC="$1"
	local LIST="$( nvram get fff_ethers_lan ) $( nvram get fff_ethers_wifi )"
	
	echo $LIST | grep -qi "${MAC}=free-"  && return 0
	echo $LIST | grep -qi "${MAC}=admin-" && return 0
	return 1
}

_pfilter_user_probe_splash ()
{
	local MAC="${1:-unset}"			# not using _ipt()

	iptables -t mangle -nL PREROUTING | grep -qi $MAC && return 1	# mac is accepted in prerouting/mangle: no redirection is made
	return 0							# mac is not known in prerouting/mangle: user gets splash page
}

_pfilter_user_splash_control ()				# SENS: controlling if a user must see splashpage before using internet or not
{							# ARG1: nosplash,splash
							# ARG2: mac
	local FUNC="pfilter_user_splash_control"	# ARG3: ip-address
	local MODE="$1"
	local  MAC="$2"
	local   IP="$3"

	_log do $FUNC daemon info "start - mode: $MODE - $MAC / $IP"

	echo "$IP" >/tmp/MAC2IP_${MAC}			# fixme! is a hack for _net_mac2ip

	[ -z "$MODE" -o -z "$MAC" -o -z "$IP" ] && {
		_log do $FUNC daemon info "no mode nor mac nor ip given, aborting"
		return
	}

	if [ "$MODE" = "nosplash" ]; then
		MODE="-I"
	else
		MODE="-D"
	fi

	_ipt -t mangle $MODE PREROUTING -m mac --mac-source $MAC -j ACCEPT
	_ipt -t mangle $MODE PREROUTING -d $IP                   -j ACCEPT	

	_log do $FUNC daemon info "end - mode: $MODE - $MAC / $IP"
}

_pfilter_user_add ()		# SENS: generate MAC-specific shaping/accounting-chain
{
	local FUNC="pfilter_user_add"
	local MAC="$1"
	local  IP="$2"
	local ARP="$3"		# fixme! sens of $3 ?
	local KEYWORD="$4"
	
	local MYHNA="$( _config get net olsr hna4 )"

	[ "$KEYWORD" != "reserve" ] && {
		_log do $FUNC daemon debug "instant call - trying to activate reserved user chain"

		_pfilter user_ruleset_activate $MAC $IP && {
			_log do $FUNC daemon debug "successfully activated reserved user chain"
			return 0
		}
	}

	[ -z "$IP" ] && {
		_log do $FUNC daemon info "no MAC or no IP given - aborting"
		return 1
	}
					# normal users
	local CONN_LIMIT_UDP="20"	# was 5
	local CONN_LIMIT_TCP="75"	# was 20

	_net local_inet_offer >/dev/null && {
	
		_log do $FUNC daemon info "raising connection-count for this user"

		CONN_LIMIT_UDP="50"		# free-users on node with inet-offer
		CONN_LIMIT_TCP="100"
	
		_pfilter user_probe_admin $MAC && {

			_log do $FUNC daemon info "boosting connection-count for this admin-user"

			CONN_LIMIT_UDP="1000"
			CONN_LIMIT_TCP="4096"
		}
	}
	
	_log do $FUNC daemon debug "$MAC / $IP (connlimit tcp/udp: $CONN_LIMIT_TCP/$CONN_LIMIT_UDP)"

	[ -z "$ARP" ] && _net arp_permanent $IP $MAC

	_log do $FUNC daemon debug "filling user chain - start"
	
	_ipt -t mangle -N traff_$MAC 2>/dev/null || {
		_log do $FUNC daemon debug "chain traff_$MAC already exists - abort"
		return 1
	}
	
	_ipt -t mangle -A traff_$MAC -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE -j shaper	# counter0 (intranet/mesh-intern)
	_ipt -t mangle -A traff_$MAC								# counter1 (traffic interval-count)
	_ipt -t mangle -A traff_$MAC								# counter2 (traffic_today)
	_ipt -t mangle -A traff_$MAC								# counter3 (traffic_all)
	
	_ipt -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW -d 1.1.0.0/20 -m limit --limit 6/min --limit-burst 10 -j LOG --log-prefix "ADBLOCK:"
	_ipt -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW -d 1.1.0.0/20        -j MARK --set-mark $( _pfilter proto2id REJECT )    # adblock (special dest)
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id REJECT )/0xFF  -j shaper
	
	_ipt -t mangle -A traff_$MAC -m state --state NEW -p udp -m udplimit  --udplimit-above  $CONN_LIMIT_UDP -j MARK --set-mark $( _pfilter proto2id CONN_ABOVE )
	_ipt -t mangle -A traff_$MAC -m state --state NEW -p tcp -m connlimit --connlimit-above $CONN_LIMIT_TCP -j MARK --set-mark $( _pfilter proto2id CONN_ABOVE )
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN_ABOVE )/0xFF                           -j shaper	# connabove to shaper
	
	_ipt -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW                   -j MARK --set-mark $( _pfilter proto2id CONN )	# all new packets
	
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF       -j ULOG --ulog-prefix "$MAC>"       # inside2outside
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF       -j shaper
	
	_ipt -t mangle -A traff_$MAC -s $MYHNA -p tcp --tcp-flags fin,ack fin,ack     -j MARK --set-mark $( _pfilter proto2id CONN )    # FIN&ACK is set
	_ipt -t mangle -A traff_$MAC -s $MYHNA -p tcp --tcp-flags rst rst             -j MARK --set-mark $( _pfilter proto2id CONN )    # RST     is set
	
	_ipt -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags syn,ack syn,ack     -j MARK --set-mark $( _pfilter proto2id CONN )	# better? SYN&ACK in answer is set
	_ipt -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags fin,ack fin,ack     -j MARK --set-mark $( _pfilter proto2id CONN )	# better? FIN&ACK in answer is set
	_ipt -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags rst rst             -j MARK --set-mark $( _pfilter proto2id CONN )	# better? RST     in answer is set

	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF    -j ULOG --ulog-prefix "${MAC}<"	# outside2inside
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF    -j shaper 
	
	_ipt -t mangle -A traff_$MAC -m connbytes --connbytes   97999:99999   --connbytes-dir both --connbytes-mode bytes
	_ipt -t mangle -A traff_$MAC -m connbytes --connbytes  997999:999999  --connbytes-dir both --connbytes-mode bytes
	_ipt -t mangle -A traff_$MAC -m connbytes --connbytes 9997999:9999999 --connbytes-dir both --connbytes-mode bytes
	
	_ipt -t mangle -A traff_users -m mac --mac-source $MAC -j traff_$MAC
	_ipt -t mangle -A traff_users -d $IP                   -j traff_$MAC	# must be IP, not HNA!
	
	for ENTRY in $( _pfilter l7proto_list ); do {
		PROTO="${ENTRY%,*}"		# PORT="${ENTRY#*,}"
	
		_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id )/0xFF	-j shaper
		_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id )/0xFF	-j LOG --log-prefix "layer7_${PROTO}: "
		_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id )/0xFF	-j RETURN
	} done
	
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j shaper				# unknown traffic
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j LOG --log-prefix "layer7_UNKNOWN: "
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j RETURN

	_pfilter user_splash_control nosplash $MAC $IP
	
	_log do $FUNC daemon info "filling user chain - end"
}

_pfilter_rules_install ()			# fixme! connbytes auswerten: http ab 200k = langsame klasse/download?
{
	local FUNC="pfilter_rules_install"

	_pfilter kmodules_init			# connection-aufbau /pro user /pro zeiteinheit limitieren
						# connections /pro user limitieren
						# icmp /ping pro user /pro zeiteinheitlimitieren
						# unabhaengig von einteilung bestimmte packet trotzdem in prio veraendern (ACK...)

	local MYHNA="$( _config get net olsr hna4 )"
						
	_log do $FUNC daemon info "start"

	_ipt -t mangle -N marking
	_ipt -t mangle -N marking_unmarkable
	_ipt -t mangle -N marking_layer7
	_ipt -t mangle -N traff_all
	_ipt -t mangle -N traff_users
	_ipt -t mangle -N shaper

	_ipt -A FORWARD -m mark --mark $( _pfilter proto2id REJECT )          -j REJECT
	_ipt -A FORWARD -m mark --mark $( _pfilter proto2id CONN_ABOVE )/0xFF -j REJECT  # --reject-with tcp-reset (does not work?)
	_ipt -A FORWARD -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE                                -j ACCEPT
	_ipt -A FORWARD -m state --state ESTABLISHED,RELATED             -j ACCEPT

	# maybe let already marked traffic go trough?

	_ipt -A FORWARD -m ipp2p --ipp2p                                 -j LOG --log-prefix "ip_p2p: "
	_ipt -A FORWARD -m ipp2p --ipp2p                                 -j DROP
	_ipt -A FORWARD -m state --state NEW                             -j ACCEPT

	_ipt -t mangle -A FORWARD -s ! $MYHNA -d ! $MYHNA  -j ACCEPT				# forwarding (but not my own forwarding)
	_ipt -t mangle -A FORWARD -m mark ! --mark 0       -j ACCEPT				# already marked in e.g. PREROUTING
	_ipt -t mangle -A FORWARD                          -j CONNMARK --restore-mark		# trying to get mark from maybe already known connection
	_ipt -t mangle -A FORWARD -m connmark ! --mark 0x0 -j traff_all				# connection known/marked? then goto traff_all
	_ipt -t mangle -A FORWARD                          -j marking				# connection not known! try to mark

	_ipt -t mangle -A traff_all
	_ipt -t mangle -A shaper    -j ACCEPT

	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 85:1500					-j RETURN
	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 0:40 --tcp-flags RST,URG     RST	-j MARK --set-mark $( _pfilter proto2id SMALL )
	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 0:52 --tcp-flags ACK,URG     ACK	-j MARK --set-mark $( _pfilter proto2id SMALL )
	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 0:64 --tcp-flags SYN,URG     SYN	-j MARK --set-mark $( _pfilter proto2id SMALL )
	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 0:64 --tcp-flags ACK,SYN,URG ACK,SYN	-j MARK --set-mark $( _pfilter proto2id SMALL )
	_ipt -t mangle -A marking_unmarkable -p icmp -m length --length 84					-j MARK --set-mark $( _pfilter proto2id SMALL )	# ping
#	_ipt -t mangle -A marking_unmarkable -m mark ! --mark 0							-j LOG --log-prefix "layer7_small: "
#	_ipt -t mangle -A marking_unmarkable -m mark ! --mark 0							-j RETURN

	for ENTRY in $( _pfilter l7proto_list ); do {
		PROTO="${ENTRY%,*}"
	#	PORT="${ENTRY#*,}"
		
		_log do $FUNC daemon info "loop_layer7: installing protocol '$PROTO'"
		
		_ipt -t mangle -A marking_layer7 -m layer7 --l7proto $PROTO		-j MARK --set-mark $( _pfilter proto2id )
	#	_ipt -t mangle -A marking_layer7 -m mark ! --mark 0			-j LOG --log-prefix "layer7_${PROTO}: "
		_ipt -t mangle -A marking_layer7 -m mark ! --mark 0			-j RETURN
		_ipt -t mangle -A traff_all      -m mark --mark $( _pfilter proto2id )/0xFF	-j traff_users
	} done

	_ipt -t mangle -A marking_layer7 -j LOG --log-prefix "layer7_end: "
	
	_ipt -t mangle -A traff_all -m mark --mark $( _pfilter proto2id UNKN )/0xFF -j traff_users	# list unknown traffic
	_ipt -t mangle -A traff_all                                            -j traff_users
	_ipt -t mangle -A traff_all                                            -j shaper
	
	_ipt -t mangle -A marking -m mark ! --mark 0			-j traff_all					# already marked in prerouting?
	_ipt -t mangle -A marking					-j marking_unmarkable				# fixme!
#	_ipt -t mangle -A marking -m mark --mark $(_pfilter proto2id SMALL)	-j MARK --set-mark 0
	_ipt -t mangle -A marking -m mark ! --mark 0			-j marking_layer7				# trying all layer7-filters
	_ipt -t mangle -A marking -m mark ! --mark 0			-j CONNMARK --save-mark				# layer7-matching was successful!
	_ipt -t mangle -A marking -m mark ! --mark 0			-j traff_all					# goto traff_all
	_ipt -t mangle -A marking					-j MARK --set-mark $( _pfilter proto2id UNKN )	# mark unknown traffic
	_ipt -t mangle -A marking					-j traff_all

	_log do $FUNC daemon info "end"
}

_pfilter_kmodules_init ()	# fixme! alles durch _ipt () schleifen und erst bei bedarf laden
{
	local MODULE
#	local LIST_MATCH="conntrack connbytes connlimit connmark udplimit length layer7 ipp2p ttl"
	local LIST_CONNTRACK="ftp irc sip h323 amanda proto_gre pptp rtsp tftp"
#	local LIST_JUMP="CONNMARK CLASSIFY ULOG"
#	local LIST_SCHEDULER="cbq"			# tc-scheduler: [C]lass [B]ased [Q]ueueing | http://man-wiki.net/index.php/8:tc-cbq

	_list_add_prefix ()
	{
		local PREFIX="$1"
		local LIST="$2"
		local OBJ

		for OBJ in $LIST; do {
			echo -n "${PREFIX}${OBJ} "
		} done
	}

#	LIST_MATCH="$(		_list_add_prefix ipt_		"$LIST_MATCH"		)"
	LIST_CONNTRACK="$(	_list_add_prefix ip_conntrack_	"$LIST_CONNTRACK" 	)"	
#	LIST_JUMP="$(		_list_add_prefix ipt_		"$LIST_JUMP"		)"
#	LIST_SCHEDULER="$(	_list_add_prefix sch_		"$LIST_SCHEDULER"	)"
	
	for MODULE in ${LIST_MATCH} ${LIST_CONNTRACK} ${LIST_JUMP} ${LIST_SCHEDULER}; do {
		_system insmod $MODULE
	} done
}

_pfilter_user_splash_add ()
{
	local FUNC="pfilter_user_splash_add"
	local MYHNA="$( _config get net olsr hna4 )"

	eval $( _ipsystem do | grep ^WIFI_IP= )

	_log do $FUNC daemon info "shutting doors"

	_ipt -t mangle -A PREROUTING -p udp --sport 68 --dport 67 -d 255.255.255.255 -j ACCEPT		# DCHP requests to internal server
	_ipt -t mangle -A PREROUTING -s ! $MYHNA -d ! $MYHNA                         -j ACCEPT		# forwarding internet from other nodes
	_ipt -t mangle -A PREROUTING -s ! $MYHNA                                     -j ACCEPT          # from other nodes to me
	
	# _ipt -t mangle -A PREROUTING -d ! $MYHNA                                     -j ACCEPT          # dest = internet

	_ipt -t mangle -A PREROUTING -i tap+ -d $WIFI_IP			-j ACCEPT		# picopeer from tunnel
	_ipt -t mangle -A PREROUTING -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE	-j ACCEPT		# picopeer small (myhna2myhna)
	_ipt -t mangle -A PREROUTING -s $WIFI_IP -d $WIFI_IP			-j ACCEPT		# picopeer big ("10.63.17.1/8")
	
	_ipt -t mangle -A PREROUTING -p udp --dport 698                              -j ACCEPT		# OLSR incoming
	_ipt -t mangle -A PREROUTING -p tcp -m multiport --dports 80,443             -j MARK --set-mark $( _pfilter proto2id REDIRECT )
	_ipt -t mangle -A PREROUTING -m mark --mark 0                                -j MARK --set-mark $( _pfilter proto2id REJECT )

	_ipt -t nat    -A PREROUTING -m mark --mark $( _pfilter proto2id REDIRECT )       -j REDIRECT

	_log do $FUNC daemon info "doors closed"
}

_pfilter_rules_accept_all ()
{
	local FUNC="pfilter_rules_accept_all"
	local CHAIN
	local ARG="$1"
	local MODE="I"				# default = insert
	
	[ "$ARG" = "off" ] && MODE="D"		# delete

	for CHAIN in filter mangle; do {
		_log do $FUNC daemon debug "table '$CHAIN', switching '$ARG'"
		
		_ipt -t $CHAIN -$MODE INPUT              -j ACCEPT
		_ipt -t $CHAIN -$MODE FORWARD            -j ACCEPT
		_ipt -t $CHAIN -$MODE OUTPUT             -j ACCEPT
		_ipt -t $CHAIN -$MODE PREROUTING  -t nat -j ACCEPT
	      # _ipt -t $CHAIN -$MODE POSTROUTING -t nat -j ACCEPT	# let masquerading work
		_ipt -t $CHAIN -$MODE OUTPUT      -t nat -j ACCEPT
	} done
}

_pfilter_rules_olsr_ignore_ignored_neighs ()		# ignoring neighs is really annoying, we delete the rules and autoconvert this to LQ_MULT x 0.1
{
	local LIST_IGNORE=$( nvram get ff_ign )
	local FILL IP
	
	IFS=";"
	for IP in $LIST_IGNORE; do {
		_ipt -D INPUT -i $WIFIDEV -s $IP -p udp --sport 698 -j DROP

		nvram get ff_lqmult | grep -q "$IP:" || {
		
			FILL=";"
			[ -z "$( nvram get ff_lqmult )" ] && FILL=""
			_nvram set ff_lqmult "$( nvram get ff_lqmult )${FILL}${IP}:0.1"		# appending to LQmult-list
		}
	} done
	unset IFS
}

_pfilter_rules_olsr_whitelist_fetch ()
{
	local FUNC="pfilter_rules_olsr_whitelist_fetch"
	local FILE="/tmp/olsr_whitelist_fresh"
	
	_log do $FUNC daemon info "fetching"

	wget -qO $FILE "$( _links firmware_url_get olsr_whitelist )"	# <unixtime>-Tags at first and last line

	local TAG1="$( head -n 1 $FILE )"
	local TAG2="$( tail -n 1 $FILE )"

	if [ -n "$TAG1" ] && [ "$TAG1" = "$TAG2" ]; then
		_log do $FUNC daemon info "went fine, sanitizing"
		sed -e '/[<>]/d' -e 's/[^A-Fa-f0-9:,]//g' $FILE >/tmp/olsr_whitelist		# removing lines with "<unixtime>" and sanitize LF/CR
	else											# results in: "nodenumber,mac (can be empty)
		_log do $FUNC daemon info "abort - something went wrong"
	fi

	rm $FILE
}

_pfilter_rules_olsr_whitelist_update ()				# fixme! new MACs are never added until fw-full-restart (!)
{
	local FUNC="pfilter_rules_olsr_whitelist_update"

	[ ! -e "/tmp/olsr_whitelist" ] && {
		_log do $FUNC daemon debug "no whitelist - no update"
		return
	}
	
	local N=0
	local ESTIMATED="$(( 8 * $( _file lines /tmp/olsr_whitelist ) / 10 ))"	# counting lines and multipling 0.8 seconds for each line for time-message in syslog
	
	_log do $FUNC daemon info "inserting new rules (needs up to $ESTIMATED seconds)"

	while read LINE; do {							# each line is: "nodenumber,mac" - mac can be empty
		
		IP="$( _ipsystem do ${LINE%,*} | sed -n 's/^WIFIADR=\(.*\)/\1/p' )"
		
		_ipt -nL olsr_in_whitelist | grep -q "$( _sanitizer do "$IP" esacpe_dots )" || {	# IP not in list yet?
			MAC="${LINE#*,}"
		
			MACFILTER=""		
			test -n "$MAC" && MACFILTER="-m mac --mac-source $MAC"
				
			let N+=1
			_ipt -A olsr_in_whitelist -s $IP $MACFILTER -j olsr_in_wifi_valid
		}

	} done </tmp/olsr_whitelist

	_ipt -D olsr_in_whitelist -j ACCEPT 2>/dev/null			       # deleting accept. of all packets, activating whitelist
	
	_log do $FUNC daemon info "installed $N rules"
}

_pfilter_rules_olsr_whitelist_optimize ()
{
	local FUNC="pfilter_rules_olsr_whitelist_optimize"
	local  NO_NEIGH="/tmp/we_have_no_olsr_neighbour.txt"
	touch $NO_NEIGH
	
	[ ! -e "/tmp/olsr_whitelist" ] && return

	_log do $FUNC daemon info "start"

	iptables -nL olsr_in_whitelist 2>/dev/null | grep -q ACCEPT || {
		_ipt -I olsr_in_whitelist -j ACCEPT				# temp. accept. of all packets
	}

	iptables -nxvL olsr_in_whitelist |
	 sed -e '/^ *0/d' -e '/valid/!d' -e 's/\*/_/g' |			# filtering packetcount 0 and stars,
          sort |
           while read LINE; do                                                                                                      
		set $LINE
                
                IP="$8"
                MAC="$11"                                                                                                                      
                HOST="$( _net ip2hostname $IP )"
                NODE="$( _ipsystem do            $IP )"
						                                                    
                _log do pfilter daemon info "(_pfilter rules_olsr_whitelist_optimize) moveup: $IP node_$NODE $HOST ${1}_packets)"

		test -e $NO_NEIGH && rm -f $NO_NEIGH

                if [ -z "$MAC" ]; then                                                         		# without MAC
                        _ipt -D olsr_in_whitelist                      -s $IP -j olsr_in_wifi_valid        # delete old rule
                        _ipt -I olsr_in_whitelist --set-counters $1 $2 -s $IP -j olsr_in_wifi_valid        # insert new rule at the beginning, reinsert old values
                else                                                                                                                                   
                        _ipt -D olsr_in_whitelist                      -s $IP -m mac --mac-source $MAC -j olsr_in_wifi_valid
                        _ipt -I olsr_in_whitelist --set-counters $1 $2 -s $IP -m mac --mac-source $MAC -j olsr_in_wifi_valid
                        
                        _net arp_permanent $IP $MAC wifi
                fi                                 
        done      

	_ipt -D olsr_in_whitelist -j ACCEPT 2>/dev/null 						# removing temp. accept. of all packets

	[ -e "$NO_NEIGH" ] && {
		_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_optimize) really no neighbours!"
		_pfilter rules_olsr_whitelist_bypass 
	}
}

_pfilter_rules_olsr_whitelist_errorcheck ()
{
	local FUNC="pfilter_rules_olsr_whitelist_errorcheck"
	local LINES_IN_WL_CHAIN="$( iptables -nxvL olsr_in_whitelist | fgrep all | wc -l )"		# the grep removes chain-headers
	local LINES_IN_WL_FILE="$( _file lines "/tmp/olsr_whitelist" )"
	local OUT="false"

	_log do $FUNC daemon info "$OUT (lines in: $LINES_IN_WL_FILE - lines real: $LINES_IN_WL_CHAIN)"

	if [ ${LINES_IN_WL_CHAIN:-0} -lt ${LINES_IN_WL_FILE:-0} ]; then
		return 0
	else
		return 1
	fi
}

_pfilter_rules_olsr_whitelist_bypass ()
{
	_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_bypass ) executing"	

	_ipt -I olsr_in_whitelist -j ACCEPT
}

_pfilter_rules_olsr_control ()
{
	local FUNC="pfilter_rules_olsr_control"
	local MYHNA="$( _config get net olsr hna4 )"

	_log do pfilter daemon info "($FUNC) Installing management"

	rm -f "/tmp/olsr_whitelist"									# to be sure, that this list must be reread

	# ----- creating user-chains: -----

	_ipt -N olsr_in
	_ipt -N olsr_in_wifi
	_ipt -N olsr_in_wire
	_ipt -N olsr_in_sanitizer
	_ipt -N olsr_in_malformed
	_ipt -N olsr_in_homebrew
	_ipt -N olsr_in_whitelist
	_ipt -N olsr_in_wifi_valid
	_ipt -N olsr_in_wifi_invalid
	_ipt -N olsr_in_wire_valid

	_ipt -N olsr_out
	_ipt -N olsr_out_wifi
	_ipt -N olsr_out_wire

	_ipt -t nat -N olsr_in
	_ipt -t nat -N olsr_out

	# ----- incoming OLSR: -----
	
	_ipt -A PREROUTING -t nat -p udp --dport 698   -j olsr_in				# to me
	_ipt -A INPUT             -p udp --dport 698   -j olsr_in				# to me

	_ipt -A olsr_in -t nat			       -j ACCEPT				# no further parsing in table nat
	_ipt -A olsr_in -i $WIFIDEV                    -j olsr_in_wifi  			# wifi in
	_ipt -A olsr_in                                -j olsr_in_wire				# wire in
	
	_ipt -A olsr_in_wifi                           -j olsr_in_sanitizer			# are packets good?
	_ipt -A olsr_in_wifi                           -j olsr_in_whitelist			# try to pass whitelist, or...
	_ipt -A olsr_in_wifi                           -j olsr_in_wifi_invalid			# away
	
	_ipt -A olsr_in_wire -i tap+	-j ACCEPT				# from tap?
	_ipt -A olsr_in_wire -i tun+	-j ACCEPT				# from tun?
	_ipt -A olsr_in_wire -i $LANDEV	-j olsr_in_sanitizer			# from lan?
	_ipt -A olsr_in_wire -i $LANDEV	-j olsr_in_wire_valid			# from lan and sanitized
	_ipt -A olsr_in_wire		-j olsr_in_sanitizer			# must be WANDEV...
	_ipt -A olsr_in_wire		-j olsr_in_wire_valid			# count all valid
	
	_ipt -A olsr_in_sanitizer -s $MYHNA				-j olsr_in_homebrew		# selfgenerated packets from me to me
	_ipt -A olsr_in_sanitizer -s $WIFINET/$WIFIPRE		-p udp --sport 698 -j RETURN	# all ok, back to further parsing (later: -d 255.255.255.255)
	_ipt -A olsr_in_sanitizer -i $WIFIDEV			-j RETURN			# from WIFI
	_ipt -A olsr_in_sanitizer -i $LANDEV  -p udp --sport 698	-j RETURN			# from LAN
	_ipt -A olsr_in_sanitizer -i tap+     -p udp --sport 698	-j RETURN			# from tunnel, not that restrictiv
	_ipt -A olsr_in_sanitizer					-j olsr_in_malformed		# something is wrong
	
	_ipt -A olsr_in_malformed -m limit --limit 1/hour -j LOG --log-prefix "olsr_in_malformed: "  # first log and then...
	_ipt -A olsr_in_malformed                      -j DROP					# better not parse these packets
	
	_ipt -A olsr_in_homebrew -i $WIFIDEV	       -j DROP                                  # from WIFI? we don't need these packets
	_ipt -A olsr_in_homebrew -i $LANDEV            -j DROP					# from LAN?
	_ipt -A olsr_in_homebrew                       -j DROP                                  # must be from WAN
	
	_ipt -A olsr_in_whitelist			       -j ACCEPT				# later we have to fill this chain with MAC/IP-tupels

	_ipt -A olsr_in_wifi_valid                     -j ACCEPT				# all went ok, let olsrd parse it
	_ipt -A olsr_in_wire_valid                     -j ACCEPT				# the same for wire

	_ipt -A olsr_in_wifi_invalid -m limit --limit 3/hour -j LOG --log-prefix "olsr_in_wifi_invalid: "	# not useable
	_ipt -A olsr_in_wifi_invalid                 -j DROP				        # better not parse these packets

	# ----- outgoing OLSR: -----
	
	_ipt -A POSTROUTING -t nat -p udp --dport 698  -j olsr_out				# from me

	#								# gives errors: 'kern.err olsrd[3923]: OLSR: sendto IPv4 Operation not permitted'
	# [ "$( _wifi mode )" != "adhoc" ] && {				# fixme! must be device-specific
	#	[ "$( nvram get fff_profile )" != "versilia_ap" ] && {
	#		_log do $FUNC daemon info "deactivating wifi-olsr"
	#		_ipt -A OUTPUT -o $WIFIDEV -p udp --dport 698 -j DROP		# in AP-mode, keep air clean
	#	}
	# }

	_ipt -A OUTPUT -p udp --dport 698	-j olsr_out		# from me

	_ipt -A olsr_out -t nat		-j ACCEPT		# no further parsing in table nat
	_ipt -A olsr_out -o $WIFIDEV	-j olsr_out_wifi	# wifi out
	_ipt -A olsr_out			-j olsr_out_wire	# wire out

	_ipt -A olsr_out_wifi		-j ACCEPT		# maybe doing some statistics here (size, speed ...)
	_ipt -A olsr_out_wire		-j ACCEPT		# maybe doing some statistics here (size, speed ...)
}

_pfilter_l7proto_list ()
{
	local	LAYER7="ntp,123 shoutcast,8000 http,80 irc,6665:6669 ftp,21 ssh,22 telnet,23 dns,53 pop3,110 nntp,119 imap,143 validcertssl,443 ssl,993"
		LAYER7="$LAYER7 smtp,25 msnmessenger,1863 rdp,3389 aim,5190 jabber,5222"
		LAYER7="$LAYER7 yahoo,5050 vnc,5900:5902 halflife2-deathmatch,7001 sip,0 lpd,0 skypetoskype,0 skypeout,0"

		# quake-halflife,26970

	echo -n "$LAYER7"
}

_pfilter_rules_walledgarden ()				# fixme! this must be profile-sensitive
{
	local FUNC="pfilter_rules_walledgarden"
	local TABLE="walled_garden"
	local ENTRY WALLED_GARDEN
	
	WALLED_GARDEN="
		141.54.160.24/32	ping01/mediathek
		141.54.1.1/32		BUW-DNS
		141.1.1.1/32		DFN
		85.25.251.231/32	vorratsdatenspeicherung.de
		82.149.225.169/32	wiki.vorratsdatenspeicherung.de
		141.54.160.48/32	m18.uni-weimar.de
		87.118.106.19/32	www.weimarnetz.de
		88.198.146.230/32	wireless.subsignal.org
		213.239.220.3/32	vekingosegundo.de
		217.238.197.73		vekingosegundo.de2
		92.123.193.15/32	http://www.apple.com/library/test/success.html_some_iPhones_needs_this
		"

	_ipt -t mangle -N $TABLE
	
	for ENTRY in $WALLED_GARDEN; do {				# accepting marked packets is done in main_framework
		
		if _sanitizer do "${ENTRY%/*}" ip4 check ; then		# we have to filter IPs from comments (only check before '/')
		
			_log do $FUNC daemon info "no fence for '$ENTRY'"
		
			_ipt -t mangle -A $TABLE -s $ENTRY -j ACCEPT
			_ipt -t mangle -A $TABLE -d $ENTRY -j ACCEPT
		else
			_log do $FUNC daemon info "comment: $ENTRY"
		fi
	} done

	_ipt -t mangle -A PREROUTING -j $TABLE
}

_pfilter_rules_nat_no_wificlients ()
{
	local FUNC="pfilter_rules_nat_no_wificlients"
	local WIFI_DHCP_NET="$( nvram get ff_wldhcp | cut -d, -f1 )"	

	[ -z "$WIFI_DHCP_NET" ] && return
	
	_log do $FUNC daemon info "removing rules"

	_ipt -D POSTROUTING -t nat -s $WIFI_DHCP_NET -j MASQUERADE
}

_pfilter_rules_nat_dns_enforce_own ()
{
	local FUNC="pfilter_rules_nat_dns_enforce_own"
	local DNS_FIRST_SERVER="$( nvram get wan_dns | cut -d ';' -f1 )"

	_net ip4_is_private "$DNS_FIRST_SERVER" && {
		_log do $FUNC daemon info "enforcing server '$DNS_FIRST_SERVER' for all"

		_ipt -t nat -A PREROUTING -p udp --dport 53 -d ! $DNS_FIRST_SERVER -j DNAT --to-destination $DNS_FIRST_SERVER
	}
}

_pfilter_rules_nat_install ()		# fixme! also masq traffic from local lan to internet during startup (atm only local wifi gets masq)
{
	local INETOFFER="$( _net local_inet_offer )"

	case $INETOFFER in
		lan)
			_pfilter rules_nat_inetoffer_lan
		;;
		tun|tun0)
			_ipt -t nat -A POSTROUTING -o tun+ -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		tap)
			_ipt -t nat -A POSTROUTING -o tap+ -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		wan)
			_ipt -t nat -A POSTROUTING -o $WANDEV -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		pppoe)
			_ipt -t nat -A POSTROUTING -o ppp+ -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		*)	
			# should'nt break anything: sometimes WANDEV is not up yet when packetfilter starts up
			
			WANDEV="$( nvram get wan_ifname )"
			[ -n "$WANDEV" ] && _ipt -t nat -A POSTROUTING -o ${WANDEV} -d ! $WIFINET/$WIFIPRE -j MASQUERADE
			_ipt -t nat -A POSTROUTING -o ppp+ -d ! $WIFINET/$WIFIPRE -j MASQUERADE
		;;
	esac
	
	_pfilter rules_nat_no_wificlients
	_pfilter rules_nat_wifi_roaming
	_pfilter rules_portfw_install
	_pfilter rules_nat_dns_enforce_own
}

_pfilter_stats_chain_show ()
{
	local FUNC="pfilter_stats_chain_show"
	local TABLE="$1"
	local CHAIN="$2"
	local LINE
	
	[ -z "$CHAIN" ] && {		# defaults to 'filter' like _ipt-usage
		TABLE="filter"
		CHAIN="$1"
	}
	
	iptables -t $TABLE -nxvL $CHAIN | while read LINE; do {
		_log do $FUNC daemon debug "$LINE"
	} done
}
