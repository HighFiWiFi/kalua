IPT="/usr/sbin/iptables"

# tc qdisc add dev eth0 root handle 1: cbq avpkt 1000 bandwidth [HN]
# tc qdisc show

func_pfilter_user_unsplash ()
{
	local MAC="$1"
	local IP="$2"

	[ -z "$MAC" -o -z "$IP" ] && return 1
								# user is known, but splashed
	fkt_list_user_macs | grep -q -i $MAC && {
		fkt_control_redirect_for_user_with_mac_and_ip nosplash $MAC $IP >/dev/null
		return
	}

	func_activate_reserved_user_chain $MAC $IP || {		# user is new and splashed
		fkt_add_user_with_mac_and_ip $MAC $IP
	}
}

func_reject_traffic_from_nonlocal_hosts_to_local_webserver ()
{
	local FUNC="reject_traffic_from_nonlocal_hosts_to_local_webserver"

	_log do $FUNC daemon info "activate blocking for HTTP(S) to avoid lowmem situations during software-install"

	iptables -I INPUT -p tcp -s ! $MYHNA --dport 80  -j DROP	# if REJECT is not possible DROP is fallback
	iptables -I INPUT -p tcp -s ! $MYHNA --dport 443 -j DROP
	iptables -I INPUT -p tcp -s ! $MYHNA --dport 80  -j REJECT
	iptables -I INPUT -p tcp -s ! $MYHNA --dport 443 -j REJECT
}

func_activate_reserved_user_chain ()
{
	local FUNC="activate_reserved_user_chain"
	local MAC_RESERVE
	local MAC_RESERVE_LIST="99:99:99:99:99:99 99:99:99:99:99:98 99:99:99:99:99:97 99:99:99:99:99:96 99:99:99:99:99:95"
	local MAC="$1"
	local IP="$2"
	
	for MAC_RESERVE in $MAC_RESERVE_LIST; do {

		iptables -t mangle -E traff_${MAC_RESERVE} traff_$MAC 2>/dev/null && { 
	
			_log do $FUNC daemon info "found chain traff_${MAC_RESERVE} and renamed to 'traff_$MAC'"
			
			iptables -t mangle -D traff_users -m mac --mac-source $MAC_RESERVE	-j traff_$MAC
			iptables -t mangle -D traff_users -d 99.99.99.99			-j traff_$MAC

			iptables -t mangle -D traff_$MAC 12
			iptables -t mangle -I traff_$MAC 12 -m mark --mark $( fkt_proto2id CONN )/0xFF -j ULOG --ulog-prefix "${MAC}>"	# inside2outside
			iptables -t mangle -D traff_$MAC 19
			iptables -t mangle -I traff_$MAC 19 -m mark --mark $( fkt_proto2id CONN )/0xFF -j ULOG --ulog-prefix "${MAC}<"	# outside2inside

			iptables -t mangle -A traff_users -m mac --mac-source $MAC		-j traff_$MAC
			iptables -t mangle -A traff_users -d $IP				-j traff_$MAC

			fkt_make_arp_entry_permanent $IP $MAC
			fkt_control_redirect_for_user_with_mac_and_ip nosplash $MAC $IP		
		
			_log do $FUNC daemon info "successfully activated 'traff_$MAC'"

			scheduler -a "/etc/local.fw-fff+ adduser_reserve $MAC_RESERVE 99.99.99.99"
			return 0
		}

		_log do $FUNC daemon debug "renaming chain 'traff_${MAC_RESERVE}' to 'traff_$MAC' didn't work"
		scheduler -a "/etc/local.fw-fff+ adduser_reserve $MAC_RESERVE 99.99.99.99"
		
		if [ "$MAC_RESERVE" = "99:99:99:99:99:95" ] && [ ! -e "/tmp/USER_PACKETFILTER" ]; then
			touch /tmp/USER_PACKETFILTER
			scheduler -a "/etc/local.fw-fff+ close_doors"
		fi
	} done
	
	return 1
}

func_packetfilter_count_rules ()
{
	local LIST="${1:-mangle filter nat}"
	local TABLE
	local COUNT
	
	for TABLE in $LIST; do {
		COUNT="$( iptables -t $TABLE -nxL | sed -e '/^target/d' -e '/^Chain /d' -ne '/[^.]$/p' | sed -n '$=' )"
		_log do packetfilter_count_rules daemon debug "$COUNT rules in '$TABLE'"
	} done
}

func_packetfilter_install_portforwarding ()			# fixme! howto redirect to myself?
{
	local FUNC="packetfilter_install_portforwarding"
	local ENTRY
	local PROTO
	local PORTFORWARDING="$( nvram get fff_portfw )"

	for ENTRY in $PORTFORWARDING; do {
	
		eval $( func_packetfilter_portforwarding_serialize_config_entry $ENTRY )
		
		[ $RULE_ACTIVE = "on" ] && {
		
			case $RULE_INCOMING_INTERFACE in
				 wan) RULE_INCOMING_INTERFACE="-i $WANDEV"	;;
				 lan) RULE_INCOMING_INTERFACE="-i $LANDEV"	;;
				wifi) RULE_INCOMING_INTERFACE="-i $WIFIDEV"	;;
			     tun|tap) RULE_INCOMING_INTERFACE="-i ${RULE_INCOMING_INTERFACE}+" ;;
				   *) RULE_INCOMING_INTERFACE=""		;;
			esac

			[ $RULE_PROTO = "both" ] && RULE_PROTO="tcp udp"
			
			for PROTO in $RULE_PROTO; do {
				
				RULE_ACTIVE="-t nat -I PREROUTING $RULE_INCOMING_INTERFACE -p $PROTO --dport $RULE_PORT_INCOMING -j DNAT --to-destination $RULE_DEST_IP:$RULE_PORT_DEST"
				
					if iptables $RULE_ACTIVE ; then
				     		_log do $FUNC user info "success adding rule '$RULE_NAME'"
				     	else
				     		_log do $FUNC user err  "error adding rule '$ENTRY' ('iptables $RULE_ACTIVE')"
				     	fi
			} done
		}
	} done
}

func_packetfilter_dhcp_ignore_specific_macs ()		# nvram set fff_dhcp_ignore="MAC MAC MAC"
{
	local FUNC="packetfilter_dhcp_ignore_specific_macs"
	local MAC
	
	for MAC in $(nvram get fff_dhcp_ignore); do {

		_log do $FUNC daemon debug "ignoring '$MAC'"
		iptables -I INPUT -p udp --sport 68 -d 255.255.255.255 --dport 67 -m mac --mac-source $MAC -j DROP
	} done
}

func_packetfilter_portforwarding_serialize_config_entry ()
{
	# like in DD-WRT (but with incoming interface!)

	# name:active:incoming_interface:proto:dport>dest_ip:dest_port name:...
	# name:on/off:any/wan/lan/wifi:tcp/udp/both:dport>dest_ip:dest_port name:...

	# emule:off:wan:both:4661>10.63.45.100:4661
	# webcam:on:any:tcp:8080>10.63.168.97:80
	
	echo $1 | sed 's/\(.*\):\(.*\):\(.*\):\(.*\):\(.*\)>\(.*\):\(.*\)/local RULE_NAME=\1\nlocal RULE_ACTIVE=\2\nlocal RULE_INCOMING_INTERFACE=\3\nlocal RULE_PROTO=\4\nlocal RULE_PORT_INCOMING=\5\nlocal RULE_DEST_IP=\6\nlocal RULE_PORT_DEST=\7/'

	# output is like:
	# local RULE_NAME=webcam
	# local RULE_ACTIVE=on
	# local RULE_INCOMING_INTERFACE=all	// wan,lan,wifi,all/any
	# local RULE_PROTO=tcp
	# local RULE_PORT_INCOMING=8080
	# local RULE_DEST_IP=10.63.168.97
	# local RULE_PORT_DEST=80
}

fkt_insmod ()
{
	local KMOD="$1"
	local MEM_BEFORE="$( _system ram_free )"
	local MEM_AFTER=0
	local MEM_DIFF=0
	local FUNC="insmod"

	if lsmod | grep -q ^$KMOD ; then

		_log do $FUNC daemon debug "kernel-module '${KMOD}' already loaded"
	else
		_log do $FUNC daemon info "loading kernel-module '${KMOD}'"
		
		if insmod $KMOD ; then
			MEM_AFTER="$( _system ram_free )"
			MEM_DIFF=$(( $MEM_BEFORE - $MEM_AFTER ))
			[ $MEM_DIFF -gt 0 ] && MEM_DIFF="+$MEM_DIFF"
	
			_log do $FUNC daemon debug "[OK] memoryusage: ${MEM_DIFF} bytes"
		else
			_log do $FUNC daemon alert "[ERR] failing to insert kernel-module '${KMOD}.o'"
		
			local FILE="$( find /lib/modules/ | grep ${KMOD}.o )"
		
			if [ -n "$FILE" ]; then
				_log do $FUNC daemon info "but found '$FILE'"
			else
				_log do $FUNC daemon info "seems that ${KMOD}.o is not in filesystem"
			fi
		
			return 1
		fi
	fi
}

func_get_all_user_macs_with_traffic_today ()
{
	fkt_definitions

	local   MEDIA=""
	local TRAFFIC=0	
	local MACLIST="$( fkt_list_user_macs )"

	for MAC in $MACLIST; do {
	
		TRAFFIC="$( fkt_get_traffic_for_mac $MAC today )"
	
		[ "$TRAFFIC" != "0" ] && {
		
			TRAFFIC="$( fkt_convert_to_unit $TRAFFIC mb )"
		
			  MAC="$( echo $MAC | sed 's/://g' )"
			MEDIA="$( fkt_get_media_from_mac $MAC short )"
				
			echo -en "${MEDIA}${MAC}:${TRAFFIC}"
		}
	} done
}

fkt_nat_for_roaming_wifi_clients ()
{
	_log do pfilter daemon info "(fkt_nat_for_roaming_wifi_clients) Installing masquerading"

	eval "$( func_ipsystem )"

	iptables -t nat -A POSTROUTING -o $WIFIDEV -s $ROAMING_IP4/$ROAMING_PRE -j MASQUERADE	# or SNAT?
}

fkt_check_if_user_with_mac_is_locally_blacklisted () {
	local MAC="$1"

	nvram get fff_ethers_blocked | grep -q -i $MAC
	
	if [ "$?" -eq 0 ]; then
		echo "true"
	else
		echo "false"
	fi
}

fkt_masq_internet_traffic_over_lan_device ()	# SENS: masquerades traffic over lan-device for omitting "black hole"
{						#       and fetches IP from local DHCP-server, if gateway-IP is not from local IP-range
	local FUNC="masq_internet_traffic_over_lan_device"
	_log do pfilter daemon info "($FUNC) working"

	local LANDEV="$( sed -n 's/^LANDEV=\(.*\)/\1/p' /tmp/NETPARAM )"
	local GATEWAY="$( nvram get lan_gateway )"
	local COUNTER=0
												# is lan_gateway an alien network?
												# then add alien-ip-range to alias-interface...

	if [ -n "$GATEWAY" ] && [ -z "$( ip route list exact 0/0 via $GATEWAY )" ]; then	# def_route could'nt be set by /sbin/ifup
												# because kernel has no suiteable interface for gw
		while [ $COUNTER -lt 5 ]; do {
			_log do pfilter daemon info "($FUNC) detected alien LAN-gateway, trying to fetch DHCP-address"
			local ALIASIP="$( udhcpc -qfn --interface="$LANDEV:fantasy" 2>/dev/null | sed -n 's/.* \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .*/\1/p' )"
			[ -n "$ALIASIP" ] && break
			_log do pfilter daemon info "($FUNC) no alias-ip - trying again in 10 sec"
			sleep 10
			COUNTER=$(( $COUNTER + 1 ))		# fixme! even with "LAN:fantasy" /etc/resolv.conf gets applied, rewrite?
		} done
		
		[ -z "$ALIASIP" ] && {
			# last octett is now a 234, so when
			# gateway is 192.168.178.1, we set
			#            192.168.178.234 on our LAN-address		# fixme! uiuiui!
			ALIASIP="$( echo $GATEWAY | sed -n 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\..*/\1.\2.\3.234/p' )"
			_log do pfilter daemon info "($FUNC) couldt fetch IP-address from LAN-DHCP-server, guessing"
		}
		
		_log do pfilter daemon info "($FUNC) using alienip '$ALIASIP' to reach gateway"
		
		local ALIASPRE="$( ipcalc -p $ALIASIP           | sed -n 's/PREFIX=\(.*\)/\1/p' )"
		local ALIASNET="$( ipcalc -n $ALIASIP/$ALIASPRE | sed -n 's/NETWORK=\(.*\)/\1/p' )"
		local LANNET="$ALIASNET"
		local LANPRE="$ALIASPRE"

		_log do pfilter daemon info "($FUNC) local alien-address gateway"
		_log do pfilter daemon info "($FUNC) adding $ALIASIP/$ALIASPRE on $LANDEV:aliennet"
		_log do pfilter daemon info "($FUNC) adding default route"
		
		ip address add $ALIASIP/$ALIASPRE   dev $LANDEV label $LANDEV:aliennet
		ip route   add default via $GATEWAY dev               $LANDEV metric 0

		# fixme! apply now static_routes, which could be used till now?
	
		if [ "$?" -ne 0 ]; then
			_log do pfilter daemon info "($FUNC) error adding default route"
		else
			_log do pfilter daemon info "($FUNC) success adding default route"	# fixme! why we restart vpn?
			/etc/init.d/S*vpn* restart				# uiuiui! better use an central
										# function to automatically ifup/down
										# vpn-connection (cron.minutely hna4-hook?)
		fi
	fi	
	
	iptables -A POSTROUTING -t nat -o $LANDEV  -s ! $LANNET/$LANPRE -j MASQUERADE
	iptables -A POSTROUTING -t nat -o $WIFIDEV -s   $LANNET/$LANPRE -j MASQUERADE

	func_packetfilter_show nat POSTROUTING
	_log do pfilter daemon info "($FUNC) done"
}

fkt_get_daily_traffic_limit_in_bytes_from_user_with_mac ()
{
	local MAC="$1"
	
	[ -z "$MAC" ] && {
		echo 0
		return
	}
	
	[ -z "$FUNC_BASE" ] && . /etc/functions_base_fff+
	func_need wifi
	
	local OUT=0								# traffic variables are known from /etc/variables_fff+
	local WIFI_MODE="$( _wifi mode )"
	local MEDIA="$( fkt_get_media_from_mac $MAC )"
	
	fkt_list_locally_registered_users | grep -q -i $MAC
										# now we make differences for anonym or locally registered
										# and wire / wireless / wireless_in_non-mesh-disturbing ap-mode (other channel!)
										
	if [ "$?" -eq 0 ]; then							# locally registered
	
		if [ "$MEDIA" = "wire" ] || [ "$WIFI_MODE" = "ap" ] ; then	# locally registered, wire or AP
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f4 )"
		else								# locally registered, wifi
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f3 )"
		fi
	else
		if [ "$MEDIA" = "wire" ] || [ "$WIFI_MODE" = "ap" ]; then	# anonym, wire or AP
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f2 )"
		else								# anonym, wifi
			OUT="$( nvram get fff_traffic_borders | cut -d':' -f1 )"
		fi
	fi

	echo "${OUT:-2500}000000"						# convert MBytes in Bytes 8-)
}

fkt_get_used_traffic_limit_from_user_with_mac_in_percent () {		# ARG1: mac-address
	local MAC="$1"							# OUT1: integer - can be higher then 100% (!)
	local STEP1
	local STEP2
	local STEP3
	
	fkt_list_user_macs | grep -q -i $MAC || {
		echo "0"
		return
	}

	STEP1="$( fkt_get_traffic_for_mac $MAC today )"					# hint: traffic_today * 100 / traffic_limit
	STEP2="$( fkt_get_daily_traffic_limit_in_bytes_from_user_with_mac $MAC )"	#       is the same like:
	STEP3="$( fkt_divide_by_100 $STEP2 )"						#       traffic_today / (traffic_limit/100)

	echo $(( $STEP1 / $STEP3 ))							#       doing it this way we avoid big numbers during bash-calculation
}

fkt_free_all_users_which_dont_want_splash () {
	local ENTRY=""
	local MAC=""
	local IP=""
	local LIST="$( grep "^..:..:..:..:..:.. free-" /etc/ethers ; grep "^..:..:..:..:..:.. admin-" /etc/ethers)"

	fkt_definitions

	_log do pfilter daemon info "(fkt_free_all_users_which_dont_want_splash) checking"

	for ENTRY in $LIST; do						# MAC NAME MAC NAME ...
		echo $ENTRY | grep -q "..:..:..:..:..:.."
		
		if [ "$?" -eq 0 ]; then
			MAC=$ENTRY
		else
			NAME=$ENTRY
			IP="$( grep $NAME /etc/local.hosts | cut -d" " -f1 )"

			_log do pfilter daemon info "(fkt_free_all_users_which_dont_want_splash) adding \"$NAME\""

			fkt_add_user_with_mac_and_ip $MAC $IP
		fi
	done
}

fkt_get_media_from_mac ()					# SENS: ...
{
	local     MAC="$1"					# ARG1: (string) mac-address
	local   SHORT="$2"					# ARG2: (string) keyword "short" (optional)
	local     OUT=0						# OUT1: (string) wifi,wire OR ~,-
	
	local PHYSDEV="$( ip neigh | grep -v "^127\.0\.0\.1" | grep -i $MAC | cut -d" " -f3 )"	# from local ARP-cache
												# in ARP-cache OR locally registered/blocked user
	. /tmp/NETPARAM
	  
	  if [ "$PHYSDEV" = "$WIFIDEV" ]; then
	  	OUT=wifi
	elif [ -n "$( nvram get fff_ethers_wifi | grep -i $MAC )" ]; then
		OUT=wifi
	elif [ -n "$( grep "^$(fkt_escape $(fkt_get_ip_from_mac $MAC) );" $CLIENTS_WIFI )" ]; then
		OUT=wifi
	else
		OUT=wire		# fixme! this can also be guessed!
	fi

	[ -n "$SHORT" ] && {
		[ "$OUT" = "wifi" ] && {
			echo "~"
			return
		}
		echo "-"
		return
	}

	echo "$OUT"
}

fkt_get_name_for_mac ()
{
	local MAC="$1"
	local NAME="$( grep -i $MAC /etc/ethers | sed -n 's/^..:..:..:..:..:.. \(.*\)-.*-.*\..*$/\1/p' )"	# cutting off e.g. "-lan1-n364.domain"
	
	echo ${NAME:=anonym}
}

fkt_get_ip_from_mac ()
{
	local MAC="$( _sanitizer do "$1" lowercase )

	[ -z "$MAC" ] && return 1

	local  IP="$( ip neigh | grep -v "^127\.0\.0\.1" | grep $MAC | cut -d" " -f1 )"		# try ARP-cache

	[ -z "$IP" ] && {									# try DHCP-lease-file
	
		IP="$( sed -e "/$MAC/!d" -ne 's/^.* ..:..:..:..:..:.. \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .*/\1/p' /var/run/dhcp.leases )"
	}

	[ -z "$IP" ] && {
		local HOSTNAME="$( sed -n "s/^$MAC \(.*\)/\1/p" /etc/ethers )"
		
		[ -n "$HOSTNAME" ] && {
			IP="$( sed -n "/$HOSTNAME/s/^\([0-9\.]*\) ${HOSTNAME}.*/\1/p" /etc/local.hosts )"
		}
	}

	echo "$IP"
}

fkt_kick_all_nonfree_users () {
	local FUNC="kick_all_nonfree_users"
	local LIST="$( fkt_list_user_macs )"

	for MAC in $LIST; do {
		
		[ "$( fkt_check_if_user_with_mac_is_redirected $MAC )" = "false" ] && {
			
			[ "$( fkt_check_if_mac_is_free $MAC )" = "false" ] && {
				_log do $FUNC daemon debug "kicking '$MAC'"
				fkt_control_redirect_for_user_with_mac_and_ip splash $MAC "$( fkt_get_ip_from_mac $MAC )"
			}
		}
	} done
}

fkt_kick_all_users_which_are_over_limit ()
{
	local FUNC="kick_all_users_which_are_over_limit"
	local LIST="$( fkt_list_user_macs )"
	local LIMIT
	local PERCENT
	local MAC

	for MAC in $LIST; do {

		[ "$( fkt_get_traffic_for_mac $MAC today )" != "0" ] && {	# very fast check
		
			[ "$( fkt_check_if_user_with_mac_is_redirected $MAC )" = "false" ] && {
		
				[ "$( fkt_check_if_mac_is_admin $MAC )" = "false" ] && {
		
					PERCENT="$( fkt_get_used_traffic_limit_from_user_with_mac_in_percent $MAC )"
					_log do $FUNC user debug "'$MAC'-traffic is ${PERCENT}%"
				
					[ $PERCENT -gt 100 ] && {
						LIMIT="$( fkt_get_daily_traffic_limit_in_bytes_from_user_with_mac $MAC )"
						LIMIT="$( _sanitizer do "$LIMIT" number_humanreadable )"
						_log do $FUNC user info " -'$MAC' (traffic: ${PERCENT}% ~${LIMIT} bytes)"
						fkt_control_redirect_for_user_with_mac_and_ip splash $MAC "$( fkt_get_ip_from_mac $MAC )"
					}
				}
			}
		}
	} done
}

fkt_reset_all_daily_user_counters () {
	local FUNC="reset_all_daily_user_counters"
	local LIST="$( fkt_list_user_macs )"
	local MAC
	
	for MAC in $LIST; do {
		fkt_reset_traffic_counter_for_mac $MAC today	
	} done
}

fkt_get_traffic_olsr_wifi_incoming () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	iptables -nxvL olsr_in | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

fkt_get_traffic_olsr_wifi_outgoing () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	iptables -nxvL olsr_out_wifi | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

fkt_get_layer7_hit_ratio_in_percent () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	local ALL_BYTES="$(      iptables -t mangle -nxvL FORWARD | grep "CONNMARK restore" | while read PACK BYTES REST; do echo $BYTES; done )"
	local RESTORED_BYTES="$( iptables -t mangle -nxvL FORWARD | grep "CONNMARK match"   | while read PACK BYTES REST; do echo $BYTES; done )"
	local MATCHED_BYTES="$(  iptables -t mangle -nxvL marking | grep "CONNMARK"         | while read PACK BYTES REST; do echo $BYTES; done )"

	which awk >/dev/null || {
		echo 0
		return
	}
	awk -v A=$ALL_BYTES -v R=$RESTORED_BYTES -v M=$MATCHED_BYTES 'BEGIN{ printf("%.2f",(R+M)*100/A) }'

	# local STEP1="$(( $RESTORED_BYTES + $MATCHED_BYTES ))"
	# local STEP2="$(( $ALL_BYTES / 1000 ))"
	# fkt_divide_by_10 "$(( $STEP1 / $STEP2 ))"
}

fkt_divide_by_10 () {						# sets an point in front of last digit 976 = 97.6
	local NUM=$1
	
	test $NUM -lt 10 && NUM="0$NUM"				# leading zero, looks better ".4 -> 0.4"

	echo $NUM | sed -n 's/^\(.*\)\([0-9]\)$/\1\.\2/p'	# 976 = 97.6 , bash can't calc with floats
}

fkt_divide_by_100 () {						# simply cuts off the last 2 digits: 976 -> 9
	local NUM=$1

	test $NUM 2>/dev/null -lt 100 && NUM="100"		# this leads to never a zero - is this good?

	echo $NUM | sed -n 's/^\([0-9].*\)[0-9][0-9]$/\1/p'
}

fkt_show_user_traff () {					# if ARG2 = spread, then data goes out to $GW and $NEXTHOP
	local LIST="$( fkt_list_user_macs )"

	eval "$( tail -n 1 $TRACE_INET_GATEWAY )"

	if [ -n "$LIST" ]; then
		for MAC in $LIST; do

			local DATE="$(         date +%d%b%Y-%Huhr%M                )"
			local TIME="$(         date +%s                            )"
			
			local TRAFF_RECENT="$( fkt_get_traffic_for_mac $MAC recent )"
			[ $TRAFF_RECENT -ne 0 ] && {
				fkt_reset_traffic_counter_for_mac $MAC recent
			}
			local TRAFF_TODAY="$(  fkt_get_traffic_for_mac $MAC today  )"
			local TRAFF_ALL="$(    fkt_get_traffic_for_mac $MAC all    )"
			
			local MEDIA="$(        fkt_get_media_from_mac         $MAC )"
			local NAME="$(         fkt_get_name_for_mac           $MAC )"
			local NODE="local"
			local REG=0
	
			OUTPUT="NODE=$NODE TIME=$TIME DATE=$DATE MAC=$MAC NAME=$NAME REG=$REG MEDIA=$MEDIA TRAFF_RECENT=$TRAFF_RECENT TRAFF_TODAY=$TRAFF_TODAY TRAFF_ALL=$TRAFF_ALL"

			if [ "$1" = "spread" ] && [ $TRAFF_RECENT -gt 0 ]; then
				echo $OUTPUT
				echo $OUTPUT >>$NETFILTER_COUNT
				
				local URL="http://$GW/cgi-bin-traffic_fff+?"
				local MSG="MAC=$MAC&NAME=$NAME&REG=$REG&MEDIA=$MEDIA&TRAFF_RECENT=$TRAFF_RECENT&TRAFF_TODAY=$TRAFF_TODAY&TRAFF_ALL=$TRAFF_ALL"			

				_wget do "${URL}${MSG}" 5 >/dev/null
			
				if [ "$GW" != "$NEXTHOP" ]; then
					local URL="http://$NEXTHOP/cgi-bin-traffic_fff+?"				
				
					_wget do "${URL}${MSG}" 5 >/dev/null
				fi
			fi
		done
	fi
}

func_pfilter_is_usermac ()
{
	iptables -t mangle -nL traff_${1:-unset} >/dev/null 2>/dev/null && return 0
	return 1
}

fkt_list_user_macs ()					# SENS: list all MACs from logged in / shaped users
{
	iptables -t mangle -nL traff_users 2>/dev/null | sed -n 's/^traff_\([0-8abcdef][0-8abcdef]:..:..:..:..:..\) .*MAC .*$/\1/p'	# must not begin with '99' (=reserved user)
}

fkt_list_blocked_macs () {
	IFS=";"
	for MAC in $( nvram get fff_ethers_blocked ); do
		echo "$MAC"
	done
	unset IFS
}

func_list_macs_in_dhcp_leases ()
{
	sed -n 's/^.* \(..:..:..:..:..:..\) .*/\1/p' /var/run/dhcp.leases
}

fkt_list_locally_registered_users () {
	IFS=";"
	for MAC in $( nvram get fff_ethers_wifi ); do
		echo "${MAC%=*}"
	done
	
	for MAC in $( nvram get fff_ethers_lan ); do
		echo "${MAC%=*}"
	done
	unset IFS
}

fkt_reset_traffic_counter_for_mac ()
{
	local FUNC="reset_traffic_counter_for_mac"
	local RULE_NUM="$2"
	local MAC="$1"
	local LOGPRIO="info"
	
	case $RULE_NUM in
		recent) RULE_NUM=2
			LOGPRIO="debug" ;;	# last 15min
		 today) RULE_NUM=3 ;;		# today
		     *) RULE_NUM=4 ;;		# overall
	esac

	_log do $FUNC daemon $LOGPRIO "$MAC ('$2')"
	
	iptables -R traff_$MAC $RULE_NUM -t mangle --set-counters 0 0
}

fkt_get_traffic_forward_intranet () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	iptables -nxvL FORWARD | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

fkt_get_traffic_forward_alien () {
	local PACK=""
	local BYTES=""
	local REST=""
	
	iptables -t mangle -nxvL FORWARD | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

fkt_get_conn_starts_for_mac ()
{
	local MAC="$1"
	
	iptables -t mangle -nxvL traff_$MAC | grep "state NEW MARK set 0x91" | sed -n 's/^[^0-9]*\([0-9]*\)[^0-9]*.*/\1/p'
}

fkt_get_conn_ends_for_mac ()
{
	local MAC="$1"

	iptables -t mangle -nxvL traff_$MAC | grep "flags:0x11/0x11 MARK" | tail -n1 | sed -n 's/^[^0-9]*\([0-9]*\)[^0-9]*.*/\1/p'
}

fkt_get_conn_above_limits_for_mac () {	# we count udp + tcp above's 	// fixme! what about adblock?
	local MAC="$1"
	local PACK=""
	local REST=""	

	iptables -t mangle -nxvL traff_$MAC | head -n 9 | tail -n 1 | while read PACK REST; do echo $PACK; done
}

fkt_get_traffic_for_mac ()	# OUT1: string
{
	local MAC="$1"
	local TIMESLOT="$2"
	local LINE
	
	case $TIMESLOT in
		recent) LINE="2" ;;	# last 15min
		today)  LINE="3" ;;	# today
		*)      LINE="4" ;;	# overall
	esac

	iptables -t mangle --line-numbers -nxvL traff_${MAC} | 
	 sed -n "/^${LINE} /s/^${LINE}[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p"
}

fkt_convert_to_unit () {		# fixme! sad but true, we have to use AWK - numbers >2.000.000.000 (2 gigbytes) are a "bash: out of range"
	local VALUE="$1"
	local UNIT="$2"			# can be kb, mb, gb
	local ARG3="$3"			# can be "dotted" - so we convert 123456789 = 123.456.789	
	local ARG4="$4"			# can be "pre" - so we enclose the number in html-<tt>'s
	local OUT=""

	which awk >/dev/null || UNIT=""		# fixme! this is a workaround
						# maybe cut off last numbers?
	case $UNIT in
		kb|KB) OUT="$( awk -v VALUE=$VALUE 'BEGIN{ printf("%i",VALUE/1000) }'       )" ;;		# this
		mb|MB) OUT="$( awk -v VALUE=$VALUE 'BEGIN{ printf("%i",VALUE/1000000) }'    )" ;;		# is not
		gb|GB) OUT="$( awk -v VALUE=$VALUE 'BEGIN{ printf("%i",VALUE/1000000000) }' )" ;;		# very correct ;-)
		    *) OUT=$VALUE ;;
	esac

	test "$ARG3" = "dotted" && OUT="$( echo "$OUT" | sed -e :a -e 's/^\(.*[0-9]\)\([0-9]\{3\}\)/\1\.\2/;ta' )"

	if [ "$ARG4" = "pre" ]; then
		OUT="<tt>$OUT</tt>"
		
		if [ "$ARG3" = "dotted" ]; then							# dotted and preformatted text?
		
			OUT="$( echo $OUT | sed 's/\./<\/tt><small>\.<\/small><tt>/g' )"	# looks nicer 8-)
		fi
	fi

	echo $OUT
}

fkt_proto2id () {
	local N=0
	
	if [ -n "$1" ]; then			# better doing this in a loop?
		case $1 in
			PING)       N=98 ;;
			TRACE)      N=97 ;;
			NTP)        N=96 ;;
			FRAG)       N=95 ;;
			TTL0)       N=94 ;;
			UNREA)      N=93 ;;
			CONN_ABOVE) N=92 ;;
			CONN)       N=91 ;;
			GARDEN)     N=90 ;;
			REDIRECT)   N=89 ;;
			REJECT)     N=88 ;;
			DHCPIN)     N=87 ;;
			PICOPEER)   N=86 ;;
			GUESS)      N=85 ;;
			SMALL)      N=84 ;;
						
			*)          N=99 ;;
		esac
		
		echo -n "0x$N"
		#printf "0x%2.2i" $N
		
		return
	fi
	
	for ENTRY in $PROTOCOLS; do {
		THIS_PROTO="${ENTRY%,*}"
		THIS_PORT="${ENTRY#*,}"

		test -z "$PORT" && THIS_PORT=""
	
		let N+=1
		if [ "$PROTO" = "$THIS_PROTO" ] && [ "$PORT" = "$THIS_PORT" ]; then
			echo -n "0x$N"
			#printf "0x%2.2i" $N
			return
		fi
	} done
}

fkt_check_if_mac_is_admin () {
	local MAC="$1"
	local LIST="$(nvram get fff_ethers_lan) $(nvram get fff_ethers_wifi)"
	
	if [ -n "$( echo $LIST | grep -i "${MAC}=admin-" )" ]; then
		echo "true"
	else
		echo "false"
	fi
}

fkt_check_if_mac_is_free () {				# free means no splashpage wished: username must begin with "admin-" or "free-"
	local MAC="$1"
	local LIST="$(nvram get fff_ethers_lan) $(nvram get fff_ethers_wifi)"
	
	if [ -n "$( echo $LIST | grep -i "${MAC}=free-" )" ] || [ -n "$( echo $LIST | grep -i "${MAC}=admin-" )" ]; then
		echo "true"
	else
		echo "false"
	fi
}

func_pfilter_is_redirected ()
{
	iptables -t mangle -nL PREROUTING | grep -q -i ${1:-unsetmac} && return 1
	return 0
}

fkt_check_if_user_with_mac_is_redirected () {
	local MAC="$1"

	iptables -t mangle -nL PREROUTING | grep -q -i $MAC
	
	if [ "$?" -eq 0 ]; then				# mac is accepted in prerouting/mangle: no redirection is made
		echo "false"
	else						# mac is not known in prerouting/mangle: user gets splash page
		echo "true"
	fi
}

fkt_control_redirect_for_user_with_mac_and_ip () {		# SENS: controlling if a user must see splashpage before using internet or not
								# ARG1: nosplash,splash
								# ARG2: mac
	local FUNC="control_redirect_for_user_with_mac_and_ip"	# ARG3: ip-address
	local MODE="$1"
	local  MAC="$2"
	local   IP="$3"

	_log do pfilter daemon info "(fkt_control_redirect_for_user_with_mac_and_ip) start - mode: $MODE - $MAC / $IP"

	if [ -z "$MODE" ] || [ -z "$MAC" ] || [ -z "$IP" ]; then
		_log do pfilter daemon info "(fkt_control_redirect_for_user_with_mac_and_ip) no mode nor mac nor ip given, aborting"
		return
	fi

	if [ "$MODE" = "nosplash" ]; then
		MODE="-I"
	else
		MODE="-D"
	fi

	iptables -t mangle $MODE PREROUTING -m mac --mac-source $MAC -j ACCEPT
	iptables -t mangle $MODE PREROUTING -d $IP                   -j ACCEPT	

	_log do pfilter daemon info "(fkt_control_redirect_for_user_with_mac_and_ip) end - mode: $MODE - $MAC / $IP"
}

fkt_add_user_with_mac_and_ip ()		# SENS: generate MAC-specific shaping/accounting-chain
{
	local FUNC="add_user_with_mac_and_ip"
	local MAC="$1"
	local  IP="$2"
	local ARP="$3"		# fixme! sens of $3 ?

	[ "$4" != "reserve" ] && {
		_log do $FUNC daemon debug "instant call - trying to activate reserved user chain"
		func_activate_reserved_user_chain $MAC $IP && {
			_log do $FUNC daemon debug "successfully activated reserved user chain"
			return 0
		}
	}

	[ -z "$IP" ] && {
		_log do pfilter daemon info "(fkt_add_user_with_mac_and_ip) no MAC or no IP given - aborting"
		return 1
	}
					# normal users
	local CONN_LIMIT_UDP="20"	# was 5
	local CONN_LIMIT_TCP="75"	# was 20

	if [ "$( _net local_inet_offer )" != "false" ]; then
	
		_log do pfilter daemon info "(fkt_add_user_with_mac_and_ip) raising connection-count for this user"

		CONN_LIMIT_UDP="20"		# free-users on node with inet-offer
		CONN_LIMIT_TCP="75"
	
		if [ "$( fkt_check_if_mac_is_admin $MAC )" = "true" ]; then

			_log do pfilter daemon info "(fkt_add_user_with_mac_and_ip) boosting connection-count for this admin-user"

			CONN_LIMIT_UDP="1000"
			CONN_LIMIT_TCP="4096"
		fi
	fi
	
	_log do $FUNC daemon debug "$MAC / $IP (connlimit tcp/udp: $CONN_LIMIT_TCP/$CONN_LIMIT_UDP)"

	[ -z "$ARP" ] && fkt_make_arp_entry_permanent $IP $MAC

	_log do $FUNC daemon debug "filling user chain - start"
	
	iptables -t mangle -N traff_$MAC 2>/dev/null || {
		_log do $FUNC daemon debug "chain traff_$MAC already exists - abort"
		return 1
	}
	
	iptables -t mangle -A traff_$MAC -s $WIFINET -d $WIFINET -j shaper   # counter0 (intranet/mesh-intern)
	iptables -t mangle -A traff_$MAC		                   # counter1 (traffic interval-count)
	iptables -t mangle -A traff_$MAC		                   # counter2 (traffic_today)
	iptables -t mangle -A traff_$MAC                               # counter3 (traffic_all)
	
	iptables -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW -d 1.1.0.0/20 -m limit --limit 6/min --limit-burst 10 -j LOG --log-prefix "ADBLOCK:"
	iptables -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW -d 1.1.0.0/20        -j MARK --set-mark $( fkt_proto2id REJECT )    # adblock (special dest)
	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id REJECT )/0xFF  -j shaper
	
	iptables -t mangle -A traff_$MAC -m state --state NEW -p udp -m udplimit  --udplimit-above  $CONN_LIMIT_UDP -j MARK --set-mark $( fkt_proto2id CONN_ABOVE )
	iptables -t mangle -A traff_$MAC -m state --state NEW -p tcp -m connlimit --connlimit-above $CONN_LIMIT_TCP -j MARK --set-mark $( fkt_proto2id CONN_ABOVE )
	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id CONN_ABOVE )/0xFF                           -j shaper	# connabove to shaper
	
	iptables -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW                   -j MARK --set-mark $( fkt_proto2id CONN )	# all new packets
	
	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id CONN )/0xFF       -j ULOG --ulog-prefix "$MAC>"       # inside2outside
	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id CONN )/0xFF       -j shaper
	
	iptables -t mangle -A traff_$MAC -s $MYHNA -p tcp --tcp-flags fin,ack fin,ack     -j MARK --set-mark $( fkt_proto2id CONN )    # FIN&ACK is set
	iptables -t mangle -A traff_$MAC -s $MYHNA -p tcp --tcp-flags rst rst             -j MARK --set-mark $( fkt_proto2id CONN )    # RST     is set
	
	iptables -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags syn,ack syn,ack     -j MARK --set-mark $( fkt_proto2id CONN )	# better? SYN&ACK in answer is set
	iptables -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags fin,ack fin,ack     -j MARK --set-mark $( fkt_proto2id CONN )	# better? FIN&ACK in answer is set
	iptables -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags rst rst             -j MARK --set-mark $( fkt_proto2id CONN )	# better? RST     in answer is set

	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id CONN )/0xFF    -j ULOG --ulog-prefix "${MAC}<"	# outside2inside
	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id CONN )/0xFF    -j shaper 
	
	iptables -t mangle -A traff_$MAC -m connbytes --connbytes   97999:99999   --connbytes-dir both --connbytes-mode bytes
	iptables -t mangle -A traff_$MAC -m connbytes --connbytes  997999:999999  --connbytes-dir both --connbytes-mode bytes
	iptables -t mangle -A traff_$MAC -m connbytes --connbytes 9997999:9999999 --connbytes-dir both --connbytes-mode bytes
	
	iptables -t mangle -A traff_users -m mac --mac-source $MAC -j traff_$MAC
	iptables -t mangle -A traff_users -d $IP                   -j traff_$MAC	# must be IP, not HNA!
	
	for ENTRY in $PROTOCOLS; do {
		PROTO="${ENTRY%,*}"		# PORT="${ENTRY#*,}"
	
		iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id )/0xFF	-j shaper
		iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id )/0xFF	-j LOG --log-prefix "layer7_${PROTO}: "
		iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id )/0xFF	-j RETURN
	} done
	
	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id UNKN )/0xFF		-j shaper				# unknown traffic
	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id UNKN )/0xFF		-j LOG --log-prefix "layer7_UNKNOWN: "
	iptables -t mangle -A traff_$MAC -m mark --mark $( fkt_proto2id UNKN )/0xFF		-j RETURN

	fkt_control_redirect_for_user_with_mac_and_ip nosplash $MAC $IP
	
	_log do pfilter daemon info "(fkt_add_user_with_mac_and_ip) filling user chain - end"
}

fkt_scaleable_packetfilter_with_QoS () {	# connbytes auswerten: http ab 200k = langsame klasse/download?
	_pfilter_kmodules_init			# connection-aufbau /pro user /pro zeiteinheit limitieren
						# connections /pro user limitieren
						# icmp /ping pro user /pro zeiteinheitlimitieren
						# unabhaengig von einteilung bestimmte packet trotzdem in prio veraendern (ACK...)
						
	_log do pfilter daemon info "(fkt_scaleable_packetfilter_with_QoS) Installing"

	iptables -t mangle -N marking
	iptables -t mangle -N marking_unmarkable
	iptables -t mangle -N marking_layer7
	iptables -t mangle -N traff_all
	iptables -t mangle -N traff_users
	iptables -t mangle -N shaper

	iptables -A FORWARD -m mark --mark $( fkt_proto2id REJECT )          -j REJECT
	iptables -A FORWARD -m mark --mark $( fkt_proto2id CONN_ABOVE )/0xFF -j REJECT  # --reject-with tcp-reset (does not work?)
	iptables -A FORWARD -s $WIFINET -d $WIFINET                                -j ACCEPT
	iptables -A FORWARD -m state --state ESTABLISHED,RELATED             -j ACCEPT
# maybe let already marked traffic go trough?
	iptables -A FORWARD -m ipp2p --ipp2p                                 -j LOG --log-prefix "ip_p2p: "
	iptables -A FORWARD -m ipp2p --ipp2p                                 -j DROP
	iptables -A FORWARD -m state --state NEW                             -j ACCEPT

	iptables -t mangle -A FORWARD -s ! $MYHNA -d ! $MYHNA  -j ACCEPT				# forwarding (but not my own forwarding)
	iptables -t mangle -A FORWARD -m mark ! --mark 0       -j ACCEPT				# already marked in e.g. PREROUTING
	iptables -t mangle -A FORWARD                          -j CONNMARK --restore-mark		# trying to get mark from maybe already known connection
	iptables -t mangle -A FORWARD -m connmark ! --mark 0x0 -j traff_all				# connection known/marked? then goto traff_all
	iptables -t mangle -A FORWARD                          -j marking				# connection not known! try to mark

	iptables -t mangle -A traff_all
	iptables -t mangle -A shaper    -j ACCEPT

	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 85:1500					-j RETURN
	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 0:40 --tcp-flags RST,URG     RST	-j MARK --set-mark $( fkt_proto2id SMALL )
	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 0:52 --tcp-flags ACK,URG     ACK	-j MARK --set-mark $( fkt_proto2id SMALL )
	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 0:64 --tcp-flags SYN,URG     SYN	-j MARK --set-mark $( fkt_proto2id SMALL )
	iptables -t mangle -A marking_unmarkable -p tcp  -m length --length 0:64 --tcp-flags ACK,SYN,URG ACK,SYN	-j MARK --set-mark $( fkt_proto2id SMALL )
	iptables -t mangle -A marking_unmarkable -p icmp -m length --length 84					-j MARK --set-mark $( fkt_proto2id SMALL )	# ping
#	iptables -t mangle -A marking_unmarkable -m mark ! --mark 0							-j LOG --log-prefix "layer7_small: "
#	iptables -t mangle -A marking_unmarkable -m mark ! --mark 0							-j RETURN

	for ENTRY in $PROTOCOLS; do {
		PROTO="${ENTRY%,*}"
	#	PORT="${ENTRY#*,}"
		
		_log do pfilter daemon info "(layer7-filter) Installing protocol $PROTO"
		
		iptables -t mangle -A marking_layer7 -m layer7 --l7proto $PROTO		-j MARK --set-mark $( fkt_proto2id )
	#	iptables -t mangle -A marking_layer7 -m mark ! --mark 0			-j LOG --log-prefix "layer7_${PROTO}: "
		iptables -t mangle -A marking_layer7 -m mark ! --mark 0			-j RETURN
		iptables -t mangle -A traff_all      -m mark --mark $( fkt_proto2id )/0xFF	-j traff_users
	} done

	iptables -t mangle -A marking_layer7 -j LOG --log-prefix "layer7_end: "
	
	iptables -t mangle -A traff_all -m mark --mark $( fkt_proto2id UNKN )/0xFF -j traff_users	# list unknown traffic
	iptables -t mangle -A traff_all                                            -j traff_users
	iptables -t mangle -A traff_all                                            -j shaper
	
	iptables -t mangle -A marking -m mark ! --mark 0			-j traff_all					# already marked in prerouting?
	iptables -t mangle -A marking					-j marking_unmarkable				# fixme!
#	iptables -t mangle -A marking -m mark --mark $(fkt_proto2id SMALL)	-j MARK --set-mark 0
	iptables -t mangle -A marking -m mark ! --mark 0			-j marking_layer7				# trying all layer7-filters
	iptables -t mangle -A marking -m mark ! --mark 0			-j CONNMARK --save-mark				# layer7-matching was successful!
	iptables -t mangle -A marking -m mark ! --mark 0			-j traff_all					# goto traff_all
	iptables -t mangle -A marking					-j MARK --set-mark $( fkt_proto2id UNKN )	# mark unknown traffic
	iptables -t mangle -A marking					-j traff_all
}

_pfilter_kmodules_init ()	# fixme! alles durch _iptables () schleifen und erst bei bedarf laden
{
	local MODULE
	local LIST_MATCH="conntrack connbytes connlimit connmark udplimit length layer7 ipp2p ttl"
	local LIST_CONNTRACK="ftp irc sip h323 amanda proto_gre pptp rtsp tftp"
	local LIST_JUMP="CONNMARK CLASSIFY ULOG"
	local LIST_SCHEDULER="cbq"			# tc-scheduler: [C]lass [B]ased [Q]ueueing | http://man-wiki.net/index.php/8:tc-cbq

	_list_add_prefix ()
	{
		local PREFIX="$1"
		local LIST="$2"
		local OBJ

		for OBJ in $LIST; do {
			echo -n "${PREFIX}${OBJ} "
		} done
	}

	LIST_MATCH="$(		_list_add_prefix ipt_		"$LIST_MATCH"		)"
	LIST_CONNTRACK="$(	_list_add_prefix ip_conntrack_	"$LIST_CONNTRACK" 	)"	
	LIST_JUMP="$(		_list_add_prefix ipt_		"$LIST_JUMP"		)"
	LIST_SCHEDULER="$(	_list_add_prefix sch_		"$LIST_SCHEDULER"	)"
	
	for MODULE in ${LIST_MATCH} ${LIST_CONNTRACK} ${LIST_JUMP} ${LIST_SCHEDULER}; do {
		fkt_insmod $MODULE
	} done
}

fkt_activate_splashpage () {
	_log do pfilter daemon info "(fkt_activate_splashpage) shutting doors"

	iptables -t mangle -A PREROUTING -p udp --sport 68 --dport 67 -d 255.255.255.255 -j ACCEPT		# DCHP requests to internal server
	iptables -t mangle -A PREROUTING -s ! $MYHNA -d ! $MYHNA                         -j ACCEPT		# forwarding internet from other nodes
	iptables -t mangle -A PREROUTING -s ! $MYHNA                                     -j ACCEPT          # from other nodes to me
	
	# iptables -t mangle -A PREROUTING -d ! $MYHNA                                     -j ACCEPT          # dest = internet
	
	iptables -t mangle -A PREROUTING -s $WIFINET -d $WIFINET                               -j ACCEPT          # picopeer
	iptables -t mangle -A PREROUTING -p udp --dport 698                              -j ACCEPT          # OLSR incoming
	iptables -t mangle -A PREROUTING -p tcp -m multiport --dports 80,443             -j MARK --set-mark $( fkt_proto2id REDIRECT )
	iptables -t mangle -A PREROUTING -m mark --mark 0                                -j MARK --set-mark $( fkt_proto2id REJECT )

	iptables -t nat    -A PREROUTING -m mark --mark $( fkt_proto2id REDIRECT )       -j REDIRECT
}

fkt_all_chains_acceptance ()
{
	local FUNC="all_chains_acceptance"
	local CHAIN
	local ARG="$1"
	local MODE="I"				# default = insert
	
	[ "$ARG" = "off" ] && MODE="D"		# delete

	for CHAIN in filter mangle; do {
		_log do $FUNC daemon debug "table '$CHAIN', switching '$ARG'"
		
		iptables -t $CHAIN -$MODE INPUT              -j ACCEPT
		iptables -t $CHAIN -$MODE FORWARD            -j ACCEPT
		iptables -t $CHAIN -$MODE OUTPUT             -j ACCEPT
		iptables -t $CHAIN -$MODE PREROUTING  -t nat -j ACCEPT
	      # iptables -t $CHAIN -$MODE POSTROUTING -t nat -j ACCEPT	# let masquerading work
		iptables -t $CHAIN -$MODE OUTPUT      -t nat -j ACCEPT
	} done
}

fkt_olsr_whitelist_variables () {
	      OLSR_WL_FRESH="/tmp/olsr_whitelist_fresh"		# <unixtime>-Tags at first and last line
              OLSR_WL_READY="/tmp/olsr_whitelist"		# nodenumber,mac (mac can be empty)
              OLSR_WL_CHAIN="olsr_in_whitelist"			# for iptables
}

fkt_olsr_whitelist_fetch () {
	_log do pfilter daemon info "(fkt_olsr_whitelist_fetch) fetching"

	. /bin/needs links

	wget -qO $OLSR_WL_FRESH "$( _links firmware_url_get olsr_whitelist )"

	TAG1="$( head -n 1 $OLSR_WL_FRESH )"
	TAG2="$( tail -n 1 $OLSR_WL_FRESH )"

	if [ -n "$TAG1" ] && [ "$TAG1" = "$TAG2" ]; then
		_log do pfilter daemon info "(fkt_olsr_whitelist_fetch) went fine, sanitizing"
		sed -e '/[<>]/d' -e 's/[^A-Fa-f0-9:,]//g' $OLSR_WL_FRESH >$OLSR_WL_READY	# removing lines with "<unixtime>" and sanitize LF/CR
	else
		_log do pfilter daemon info "(fkt_olsr_whitelist_fetch) abort - something's wrong"
	fi

	rm -f $OLSR_WL_FRESH
}

fkt_escape () {
	echo -n $1 | sed 's/\./\\\./g'
}

fkt_olsr_whitelist_update ()				# fixme! new MACs are never added until fw-full-restart (!)
{
	local FUNC="olsr_whitelist_update"

	[ ! -e "$OLSR_WL_READY" ] && {
		_log do $FUNC daemon debug "no whitelist - no update"
		return
	}
	
	local N=0
	local ESTIMATED="$(( 8 * $( cat $OLSR_WL_READY | wc -l ) / 10 ))"	# counting lines and multipling 0.8 seconds for each line for time-message in syslog
	
	_log do pfilter daemon info "(fkt_olsr_whitelist_update) inserting new rules (needs up to $ESTIMATED seconds)"

	while read LINE; do							# each line is: "nodenumber,mac" - mac can be empty
		
		IP="$( func_ipsystem ${LINE%,*} | sed -n 's/^WIFIADR=\(.*\)/\1/p' )"
		
		if [ -z "$( iptables -nL $OLSR_WL_CHAIN | grep $( fkt_escape $IP ) )" ]; then	# IP not in list yet?
			MAC="${LINE#*,}"
		
			MACFILTER=""		
			test -n "$MAC" && MACFILTER="-m mac --mac-source $MAC"
				
			let N+=1
			iptables -A $OLSR_WL_CHAIN -s $IP $MACFILTER -j olsr_in_wifi_valid
		fi

	done <$OLSR_WL_READY

	iptables -D $OLSR_WL_CHAIN -j ACCEPT 2>/dev/null			       # deleting accept. of all packets, activating whitelist
	
	_log do pfilter daemon info "(fkt_olsr_whitelist_install) installed $N rules"
}

fkt_get_hostname_from_ip () {
	HOST="$( nslookup $1 | sed -n 's/^Name: *\([A-Za-z0-9\._-]*\)/\1/p' )"
	test -z "$HOST" && HOST="?"
	
	echo $HOST
}

fkt_make_arp_entry_permanent ()				# ARG1:ip ARG2:mac ARG3:wifi or wire
{
	local FUNC="make_arp_entry_permanent"
        local IP="$1"
        local MAC="$( _sanitizer do "$2" lowercase )"
        local FORCE="$3"						# fixme! use also IP to guess interface
        
        _log do $FUNC daemon debug "IP: '$IP' MAC: '$MAC' PHY: '$FORCE'"
        
        local IP_ESCAPED="$( echo $IP | sed 's/\./\\\./g' )"
 	local PHYSDEV="$( ip neigh | grep -i $MAC | cut -d" " -f3 | head -n1 )"		# fetch DEV from neigh-list
	# ip neigh show 10.63.246.225 | sed -n "s/^[0-9\.]* dev \(.*\) lladdr .*/\1/p"
	
	local MODE="add"

	ip neigh | grep "^$IP_ESCAPED " | grep -q "nud permanent" && {			# fixme! faster, only one call to 'ip'
		_log do $FUNC daemon debug "already permanent - do nothing"
		return
	}
	
	ip neigh | grep -q "^$IP_ESCAPED " && {
		_log do $FUNC daemon debug "already found - MODE: 'change'"
		MODE="change"
	}

 	if [ -z "$PHYSDEV" ]; then

		_log do $FUNC daemon debug "not in neigh-list, probing"
 		  
 		  if [ "$FORCE" = "wifi" ]; then
 			
 			_log do $FUNC daemon debug "enforced wifi"
 			PHYSDEV=$WIFIDEV
 		
 		elif [ "$( fkt_get_media_from_mac $MAC )" = "wire" ]; then
 		
 			_log do $FUNC daemon debug "detected wire"
 			PHYSDEV=$LANDEV
 		else
 			_log do $FUNC daemon debug "fallback to wifi"
 			PHYSDEV=$WIFIDEV
 		fi
 	
 		_log do $FUNC daemon debug "DEV from NV-RAM or forced: '$PHYSDEV'"
 	else
 		_log do $FUNC daemon debug "DEV from ip_neigh: '$PHYSDEV'"
 	fi
 
	_log do $FUNC daemon debug "applying IP: '$IP' MAC: '$MAC' PHY: '$FORCE' PHYSDEV: '$PHYSDEV'"

	_log do $FUNC daemon debug "ip neigh $MODE $IP dev $PHYSDEV lladdr $MAC nud permanent"
        # ip neigh $MODE $IP dev $PHYSDEV lladdr $MAC nud permanent
}

fkt_olsr_whitelist_optimize () {
	local  NO_NEIGH="/tmp/we_have_no_olsr_neighbour.txt"
	touch $NO_NEIGH
	
	test ! -e "$OLSR_WL_READY" && return

	_log do pfilter daemon info "(fkt_olsr_whitelist_optimize) working"

	test -z "$( iptables -nL $OLSR_WL_CHAIN 2>/dev/null | grep ACCEPT )" && iptables -I $OLSR_WL_CHAIN -j ACCEPT	# temp. accept. of all packets

	iptables -nxvL $OLSR_WL_CHAIN |
	 sed -e '/^ *0/d' -e '/valid/!d' -e 's/\*/_/g' |							# filtering packetcount 0 and stars,
          sort |
           while read LINE; do                                                                                                      
		set $LINE
                
                IP="$8"
                MAC="$11"                                                                                                                      
                HOST="$( fkt_get_hostname_from_ip $IP )"
                NODE="$( func_ipsystem            $IP )"
						                                                    
                _log do pfilter daemon info "(fkt_olsr_whitelist_optimize) moveup: $IP node_$NODE $HOST ${1}_packets)"

		test -e $NO_NEIGH && rm -f $NO_NEIGH

                if [ -z "$MAC" ]; then                                                         		# without MAC
                        iptables -D $OLSR_WL_CHAIN                      -s $IP -j olsr_in_wifi_valid        # delete old rule
                        iptables -I $OLSR_WL_CHAIN --set-counters $1 $2 -s $IP -j olsr_in_wifi_valid        # insert new rule at the beginning, reinsert old values
                else                                                                                                                                   
                        iptables -D $OLSR_WL_CHAIN                      -s $IP -m mac --mac-source $MAC -j olsr_in_wifi_valid
                        iptables -I $OLSR_WL_CHAIN --set-counters $1 $2 -s $IP -m mac --mac-source $MAC -j olsr_in_wifi_valid
                        
                        fkt_make_arp_entry_permanent $IP $MAC wifi
                fi                                 
        done      

	iptables -D $OLSR_WL_CHAIN -j ACCEPT 2>/dev/null 						# removing temp. accept. of all packets

	if [ -e "$NO_NEIGH" ]; then
		_log do pfilter daemon info "(fkt_olsr_whitelist_optimize) really no neighbours!"
		olsr_whitelist_set_inactive
	fi
}

fkt_olsr_whitelist_check_for_error () {
	local LINES_IN_WL_CHAIN="$( iptables -nxvL $OLSR_WL_CHAIN | grep all | wc -l )"		# the grep removes chain-headers
	local LINES_IN_WL_FILE="$(         cat $OLSR_WL_READY |            wc -l )"
	local OUT="false"

	if [ $LINES_IN_WL_CHAIN -lt $LINES_IN_WL_FILE ]; then
		OUT="true"
	else
		OUT="false"
	fi

	logger "fff+ (fkt_olsr_whitelist_check_for_error) $OUT (lines in: $LINES_IN_WL_FILE - lines real: $LINES_IN_WL_CHAIN)"

	echo $OUT
}

olsr_whitelist_set_inactive () {
	_log do pfilter daemon info "(olsr_whitelist_set_inactive) executing"	

	iptables -I $OLSR_WL_CHAIN -j ACCEPT
}

fkt_control_olsr ()
{
	local FUNC="control_olsr"
	_log do pfilter daemon info "($FUNC) Installing management"

	rm -f "$OLSR_WL_READY"									# to be sure, that this list must be reread

	# ----- creating user-chains: -----

	iptables -N olsr_in
	iptables -N olsr_in_wifi
	iptables -N olsr_in_wire
	iptables -N olsr_in_sanitizer
	iptables -N olsr_in_malformed
	iptables -N olsr_in_homebrew
	iptables -N $OLSR_WL_CHAIN
	iptables -N olsr_in_wifi_valid
	iptables -N olsr_in_wifi_invalid
	iptables -N olsr_in_wire_valid

	iptables -N olsr_out
	iptables -N olsr_out_wifi
	iptables -N olsr_out_wire

	iptables -t nat -N olsr_in
	iptables -t nat -N olsr_out

	# ----- incoming OLSR: -----
	
	iptables -A PREROUTING -t nat -p udp --dport 698   -j olsr_in				# to me
	iptables -A INPUT             -p udp --dport 698   -j olsr_in				# to me

	iptables -A olsr_in -t nat			       -j ACCEPT				# no further parsing in table nat
	iptables -A olsr_in -i $WIFIDEV                    -j olsr_in_wifi  			# wifi in
	iptables -A olsr_in                                -j olsr_in_wire				# wire in
	
	iptables -A olsr_in_wifi                           -j olsr_in_sanitizer			# are packets good?
	iptables -A olsr_in_wifi                           -j $OLSR_WL_CHAIN			# try to pass whitelist, or...
	iptables -A olsr_in_wifi                           -j olsr_in_wifi_invalid			# away
	
	iptables -A olsr_in_wire -i tap+		       -j ACCEPT				# from tap?
	iptables -A olsr_in_wire -i tun+		       -j ACCEPT				# from tun?
	iptables -A olsr_in_wire -i $LANDEV		       -j olsr_in_sanitizer			# from lan?
	iptables -A olsr_in_wire -i $LANDEV                -j olsr_in_wire_valid			# from lan and sanitized
	iptables -A olsr_in_wire            	       -j olsr_in_sanitizer			# must be WANDEV...
	iptables -A olsr_in_wire                           -j olsr_in_wire_valid			# count all valid
	
	iptables -A olsr_in_sanitizer -s $MYHNA            -j olsr_in_homebrew                      # selfgenerated packets from me to me
	iptables -A olsr_in_sanitizer -s $WIFINET  -p udp --sport 698 -j RETURN			# all ok, back to further parsing (later: -d 255.255.255.255)
	iptables -A olsr_in_sanitizer -i tap+   -p udp --sport 698 -j RETURN			# from tunnel, not that restrictiv
	iptables -A olsr_in_sanitizer		       -j olsr_in_malformed			# something is wrong
	
	iptables -A olsr_in_malformed -m limit --limit 1/hour -j LOG --log-prefix "olsr_in_malformed: "  # first log and then...
	iptables -A olsr_in_malformed                      -j DROP					# better not parse these packets
	
	iptables -A olsr_in_homebrew -i $WIFIDEV	       -j DROP                                  # from WIFI? we don't need these packets
	iptables -A olsr_in_homebrew -i $LANDEV            -j DROP					# from LAN?
	iptables -A olsr_in_homebrew                       -j DROP                                  # must be from WAN
	
	iptables -A $OLSR_WL_CHAIN			       -j ACCEPT				# later we have to fill this chain with MAC/IP-tupels

	iptables -A olsr_in_wifi_valid                     -j ACCEPT				# all went ok, let olsrd parse it
	iptables -A olsr_in_wire_valid                     -j ACCEPT				# the same for wire

	iptables -A olsr_in_wifi_invalid -m limit --limit 3/hour -j LOG --log-prefix "olsr_in_wifi_invalid: "	# not useable
	iptables -A olsr_in_wifi_invalid                 -j DROP				        # better not parse these packets

	# ----- outgoing OLSR: -----
	
	iptables -A POSTROUTING -t nat -p udp --dport 698  -j olsr_out				# from me

	# func_need wifi								# gives errors: 'kern.err olsrd[3923]: OLSR: sendto IPv4 Operation not permitted'
	# [ "$(func_wifi_get_mode)" != "adhoc" ] && {					# fixme! must be device-specific
	#	[ "$(nvram get fff_profile)" != "versilia_ap" ] && {
	#		_log do $FUNC daemon info "deactivating wifi-olsr"
	#		iptables -A OUTPUT -o $WIFIDEV -p udp --dport 698 -j DROP		# in AP-mode, keep air clean
	#	}
	# }

	iptables -A OUTPUT             -p udp --dport 698  -j olsr_out				# from me

	iptables -A olsr_out -t nat                        -j ACCEPT				# no further parsing in table nat
	iptables -A olsr_out -o $WIFIDEV                   -j olsr_out_wifi				# wifi out
	iptables -A olsr_out                               -j olsr_out_wire				# wire out

	iptables -A olsr_out_wifi                          -j ACCEPT				# maybe doing some statistics here (size, speed ...)
	iptables -A olsr_out_wire			       -j ACCEPT				# maybe doing some statistics here (size, speed ...)
}

fkt_definitions ()
{
	MYHNA="$( nvram get ff_hna4 )"		# fixme! needs support for serveral entries
	
	if [ -z "$CLIENTS_LAN" ]; then
		CLIENTS_LAN="$(  func_ipsystem | sed -n 's/^LANNET=\(.*\)/\1/p'  )/$( func_ipsystem | sed -n 's/^LANPRE=\(.*\)/\1/p'  )"
		CLIENTS_WIFI="$( func_ipsystem | sed -n 's/^WIFINET=\(.*\)/\1/p' )/$( func_ipsystem | sed -n 's/^WIFIPRE=\(.*\)/\1/p' )"
		
		[ -z "$WANADR" ] && WANADR="$( func_ipsystem | sed -n 's/^WANADR=\(.*\)/\1/p' )"
		[ -z "$WANDEV" ] && WANDEV="wandev_NA"
	fi
	
	PROTOCOLS="ntp,123 shoutcast,8000 http,80 irc,6665:6669 ftp,21 ssh,22 telnet,23 dns,53 pop3,110 nntp,119 imap,143 validcertssl,443 ssl,993"
	PROTOCOLS="$PROTOCOLS smtp,25 msnmessenger,1863 rdp,3389 aim,5190 jabber,5222"
	PROTOCOLS="$PROTOCOLS yahoo,5050 vnc,5900:5902 halflife2-deathmatch,7001 quake-halflife,26970 sip,0 lpd,0 skypetoskype,0 skypeout,0"
}

fkt_insert_walled_garden ()
{
	local FUNC="walled_garden_insert"
	local ENTRY WALLED_GARDEN
	
	WALLED_GARDEN="141.54.160.24/32 (ping01) 141.54.1.1/32 (BUW-DNS) 141.1.1.1/32 (DFN) 85.25.251.231/32 (vorratsdatenspeicherung.de)"
	WALLED_GARDEN="${WALLED_GARDEN} 82.149.225.169/32 (wiki.vorratsdatenspeicherung.de) 141.54.160.48/32 (m18.uni-weimar.de)"                          
	WALLED_GARDEN="${WALLED_GARDEN} 87.118.106.19/32 (www.weimarnetz.de) 88.198.146.230/32 (wiki_neu)"                       
	WALLED_GARDEN="${WALLED_GARDEN} 213.239.220.3/32 (vekingosegundo.de) 217.238.197.73 (vekingosegundo.de2)"
	
	for ENTRY in $WALLED_GARDEN; do {				# accepting marked packets is done in main_framework
		
		if _sanitizer do "${ENTRY%/*}" ip4 check ; then		# we have to filter IPs from comments (only check before '/')
		
			_log do $FUNC daemon info "no fence for '$ENTRY'"
		
			iptables -t mangle -A PREROUTING -s $ENTRY -j ACCEPT
			iptables -t mangle -A PREROUTING -d $ENTRY -j ACCEPT
		else
			_log do $FUNC daemon info "human_readable: $ENTRY"
		fi
	} done
}

fkt_no_nat_for_wifi_clients ()
{
	local WIFI_DHCP_NET="$( nvram get ff_wldhcp | cut -d, -f1 )"	

	[ -z "$WIFI_DHCP_NET" ] && return
	
	_log do pfilter daemon info "(fkt_no_nat_for_wifi_clients) Removing rules"

	iptables -D POSTROUTING -t nat -s $WIFI_DHCP_NET -j MASQUERADE
}

func_masq ()		# fixme! also masq traffic from local lan to internet during startup (atm only local wifi gets masq)
{
	local INETOFFER="$( _net local_inet_offer )"

	case $INETOFFER in
		lan)
			fkt_masq_internet_traffic_over_lan_device
		;;
		tun|tun0)
			iptables -t nat -A POSTROUTING -o tun+ -d ! $WIFINET -j MASQUERADE
		;;
		tap)
			iptables -t nat -A POSTROUTING -o tap+ -d ! $WIFINET -j MASQUERADE
		;;
		wan)
			iptables -t nat -A POSTROUTING -o $WANDEV -d ! $WIFINET -j MASQUERADE
		;;
		pppoe)
			iptables -t nat -A POSTROUTING -o ppp+ -d ! $WIFINET -j MASQUERADE
		;;
		*)	
			# should'nt break anything: sometimes WANDEV is not up yet when packetfilter starts up
			
			local WANDEV="$(nvram get wan_device)"			
			[ -n "$WANDEV" ] && iptables -t nat -A POSTROUTING -o ${WANDEV} -d ! $WIFINET -j MASQUERADE
			iptables -t nat -A POSTROUTING -o ppp+ -d ! $WIFINET -j MASQUERADE
		;;
	esac
	
	fkt_no_nat_for_wifi_clients
	fkt_nat_for_roaming_wifi_clients
	func_packetfilter_install_portforwarding
}

func_packetfilter_show_chain ()
{
	local FUNC="packetfilter_show_chain_postrouting"
	local TABLE="$1"
	local CHAIN="$2"
	local LINE
	
	[ -z "$CHAIN" ] && {		# defaults to 'filter' like iptables-usage
		TABLE="filter"
		CHAIN="$1"
	}
	
	iptables -t $TABLE -nxvL $CHAIN | while read LINE; do {
		_log do $FUNC daemon debug "$LINE"
	} done
}
