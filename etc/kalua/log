_log_do ()				# CALL: _log do my_func_name daemon info "mytext"
{
	[ -e /tmp/LOWMEM ] && return	# fixme! maybe everlasting and log to console should work?

	local FATHER_PROCESS="$0"
	local       FUNCTION="$1"	# ARG1, string (name of function, from where call was invoked)
	local       FACILITY="$2"	# ARG2, string (kern,user,mail,daemon,syslog,lpr,news,uucp,cron,authpriv,local0-7)
	local           PRIO="$3"	# ARG3, string (emerg,alert,crit,err,warning,notice,info,debug)
	local        MESSAGE="$4"	# ARG4, string (humanreadable verbose message, all is syslog-alike)
	local        EVERLOG="/www/everlasting_syslog.txt"

	case $PRIO in
		debug|emerg|alert|crit)
			local MEM="$( sed -n '/^Mem:/s/^Mem:[^0-9]*[0-9]*[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p' /proc/meminfo )"
			local UPTIME="$( cut -d" " -f1 /proc/uptime )"
			local DATE="$( date "+%b %d %H:%M:%S" )"	# Oct 29 12:45:06
			
			[ "$PRIO" != "debug" ] && {		# write to logfile in flash, which is not lost after reboot
			
				[ -z "$FUNC_BASE" ] && . /etc/functions_base_fff+
				func_need vars_old
			
				[ "$(func_system_flash_free)" -gt 150 ] && {
					echo >>$EVERLOG "$DATE | [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE"
				}
				
				local LINE
				MESSAGE="$( echo "$MESSAGE" | while read LINE; do echo -n $LINE; done )"	# strip newline chars
				local UNIXTIME="$( date +%s )"
				local ARCHIV_NODE_MESSAGE="$DATE | [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE"
				echo >>$ARCHIV_NODE_DATA "log=$( _sanitizer do "$ARCHIV_NODE_MESSAGE" urlvalue )&time=${UNIXTIME}"
				touch /tmp/SEND_ALIVE_FAILED
			}
		;;
	esac

	[ "$SHELL" = "/bin/ash" -o "$SHELL" = "/bin/sh" ] && {		# executing from commandline (ssh/telnet) (maybe using: "$TERM" != "vt102" ?)
	
		[ -z "$MEM" ] && {
			local MEM="$( sed -n '/^Mem:/s/^Mem:[^0-9]*[0-9]*[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p' /proc/meminfo )"
			local UPTIME="$( cut -d" " -f1 /proc/uptime )"				# fixme! this section is doubled (see above)
			local DATE="$( date "+%b %d %H:%M:%S" )"	# Oct 29 12:45:06
		}
		
		FATHER_PROCESS="TERM:${TERM} $0"
		echo "$DATE | [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE" 1>&2   # to stderr
	}

	if [ "$PRIO" = "debug" ]; then

		[ ! -e /tmp/DEBUG ] && [ "$SHELL" != "/bin/ash" ] && return

		[ -e /tmp/BOOT ] && {
			pidof syslogd >/dev/null || {		# write to special logfile
				echo >>/tmp/messages "$DATE | [up $(cut -d" " -f1 /proc/uptime)s] ${FACILITY}.${PRIO} fff+ $FATHER_PROCESS ${FUNCTION}() $MESSAGE"
				# func_netmessage "$MESSAGE"	# fixme!
			}
		}
	else
		[ -e /tmp/BOOT ] && {
			pidof syslogd >/dev/null || {		# write to special logfile
				echo >>/tmp/messages "$DATE | [up $(cut -d" " -f1 /proc/uptime)s] ${FACILITY}.${PRIO} fff+ $FATHER_PROCESS ${FUNCTION}() $MESSAGE"	
				# func_netmessage "$MESSAGE"	# fixme!
			}
		}
	fi

	# fixme! howto print out logging when webserver executes a script?

	logger -t "fff+ $FATHER_PROCESS ${FUNCTION}()" -p "${FACILITY}.${PRIO}" "$MESSAGE"
}

_log_netmessage () 		# SENS: sends a human-readable UDP netmessage to all broadcast-destinations
{
	# readable per tcpdump: (each line are 16 bytes)
	# tcpdump -s 500 -nXi $DEVICE udp and port 2049

	local  MESSAGE="$1"	# ARG1: string
	local  BROADCAST
	local  DESTINATIONS="$( ip address show |
	                         sed -n 's/^.* brd \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\).*/255.255.255.255\n\1/p' |
	                          sort | uniq )"

	for BROADCAST in ${DESTINATIONS:=255.255.255.255}; do {
		netmsg $BROADCAST "__$MESSAGE"				# fixme! at early boot, there are no interfaces up...
	} done
}

func_get_number_from_name_in_phonebook () {
	local      DEST="$1"							# ARG1: string (peter or 0177/2821234)
	local       OUT=""							# OUT1: string (number or keyword "invalid")
	local PHONEBOOK="$( nvram get fff_sms_phonebook )"			# klaus=0177/2821234;peter=0179/1234567;...

	[ -z "$DEST" ] && {							# output hole phonebook

		IFS=";"
		for DEST in $PHONEBOOK; do {
			echo $DEST
		} done
		unset IFS
	
		return 1
	}
	
	if [ -n "$( echo "$PHONEBOOK" | grep "${DEST}=" )" ]; then		# is in phonebook, convert NAME to NUMBER
	
		OUT="$( echo "$PHONEBOOK" | sed 's/[^0-9a-zA-Z;=]//g' | sed "s/.*$DEST=\([0-9]*\).*/\1/" )"
	else
		OUT="$DEST"							# not in phonebook
	fi

	OUT="$( echo "$OUT" | sed 's/[^0-9]//g' )"				# allow only numbers

	if [ -z "$OUT" ] || [ -z "$DEST" ]; then
		echo "invalid"
		return 1
	fi
	
	echo "$OUT"
}

func_number2caller ()
{
	local NUMBER="$1"
	local CALLER_NAME
	local CALLER_DETAILS

	func_number2caller_dasoertliche $NUMBER
	eval $(func_number2caller_dasoertliche $NUMBER)
	echo $CALLER_NAME
	echo $CALLER_DETAILS
	echo "#"
	func_number2caller_goyellow $NUMBER
	eval $(func_number2caller_goyellow $NUMBER)
	echo $CALLER_NAME
	echo $CALLER_DETAILS
	echo "#"
}

func_number2caller_dasoertliche ()	# ARG1 = number
{
	wget -qO - "http://www1.dasoertliche.de/?form_name=search_inv&ph=${1}" |
	 sed -ne "s/^.*onmouseover=\"\"  >\(.*\)<\/a>.*/CALLER_NAME='\1';/p" \
	      -e "s/^[^a-zA-Z0-9]*\([a-zA-Z0-9].*\)<br\/>/CALLER_DETAILS='\1';/p" |
	  sed -e 's/&nbsp;/ /g' -e 's/nbsp;/ /g'
}

func_number2caller_goyellow ()		# ARG1 = number
{
	wget -qO - "http://www.goyellow.de/schnellsuche/?LIP=simpleSearch&MDN=${1}&LOC=" |
	 sed -ne "s/^.*title=\"Detailinformationen.*);\">\(.*\)<\/a>/CALLER_NAME='\1'/p" \
	      -e "s/^<p class=\"address\">\(.*\)<\/p>/CALLER_DETAILS='\1'/p"
}

_sms_send ()			# SENS: wrapper for SMS-sending independent from service
{				#	- collect all relevant data
				#	- write and process queue-file line by line
				#	- call service-specific function
				#	- when something fails, use another service
				#	this should be executed by cron every minute (to process queue-file)
				
	local   FUNC="sms_send"
	local   DEST="$1"				# ARG1: string (name or number)
	local   TEXT="$2"				# ARG2: string (text to send, codepage ISO_8859-1)
	local NOPOST="$3"				# ARG3: string (optional, keyword: nopost)
	local   USER="$( nvram get fff_sms_user )"	#	string
	local   PASS="$( nvram get fff_sms_pass )"	#	string
	local   POST="$( nvram get fff_sms_post )"	#       string (something like: "from klaus [03643/110]" )
	local NUMBER
	
	[ -z "$USER" ] && {
		_log do $FUNC user crit "username not given - aborting"
		return 1
	}
	
	[ -z "$PASS" ] && {
		_log do $FUNC user crit "password not given - aborting"
		return 1
	}
	
	[ -z "$TEXT" ] && {
		_log do $FUNC user crit "text not given - aborting"
		return 1
	}
	
	[ -n "$NOPOST" ] && POST=""
	
	NUMBER="$( func_get_number_from_name_in_phonebook "$DEST" )" || {
		_log do $FUNC user notice "wrong name/number - aborting"
		return 1
	}
	
	[ -n "$POST" ] && TEXT="$TEXT $POST @$( date +%H:%M)uhr"		# append own brand + time

	_log do $FUNC user notice "to '$DEST' = $NUMBER, ${#TEXT} chars: '$TEXT'"
		
	_sms_send_sms77 $USER $PASS $NUMBER $( _sanitizer do "$TEXT" urlvalue ) || {
		
		scheduler -a ". /bin/needs log && _$FUNC '$NUMBER' '$TEXT' no_post"
		return 1
	}
}

_sms_send_sms77 ()
{
	local   FUNC="sms_send_sms77"
	local   USER=$1
	local   PASS=$2
	local NUMBER=$3
	local   TEXT=$4
	local    OUT=""
	local    URL="http://www.sms77.de/gateway/?type=basicplus"	# basicplus hard coded, need abstraction
	local     RC=0
	local      o 

	_log do $FUNC daemon debug "${URL}&u=${USER}&p=${PASS}&to=${NUMBER}&text=${TEXT}"
	
	OUT="$( wget -qO - "${URL}&u=${USER}&p=${PASS}&to=${NUMBER}&text=${TEXT}" )"
	RC=$?

	if [ $RC -ne 0 ] || [ "$OUT" != "100" ]; then

		case $OUT in					# 100,101,306 not implemented
		        201) o="wrong country code" ;;
		        202) o="wrong recipient number" ;;
		    300|900) o="username/pass wrong or unset" ;;
			301) o="recipient unset" ;;
			304) o="type unset" ;;
			305) o="text unset" ;;
			307) o="url unset" ;;
			400) o="type invalid" ;;
			401) o="text too long" ;;
			402) o="reload mistake, try again" ;;
			902) o="API deactivated!" ;;
			903) o="serverip wrong" ;;
			500) o="no credits available" ;;
			
			  *) _log do $FUNC user crit "wget-returncode: '$RC' - sms77-answer: '$OUT' - something went wrong"
			     return 1	# which means - try to send again
			 ;;
		esac
		
		_log do $FUNC user info "wget-returncode: '$RC' - sms77-answer: '$OUT' ($o)"
	fi
}

func_mail_check_pop3_stats () {						# works with busybox-netcat
	local   FUNC="mail_check_pop3_stats"
	local   USER="$( nvram get fff_mail_user )"
	local   PASS="$( nvram get fff_mail_pass )"
	local    OUT=""
	local   LINE
	local NETCAT="nc"
	local SERVER="$( nvram get fff_mail_server_pop3 )"
	local   PORT="$( nvram get fff_mail_server_pop3_port )"
	local     RC=0
	local WINDOW=600						# time in seconds, when pop_before_smtp is valid

	_log do $FUNC user notice "sending data to '$SERVER'"

	OUT="$( echo -e "USER $USER\nPASS $PASS\nSTAT\nQUIT\n" | $NETCAT $SERVER $PORT )"

	RC=$?
	OUT="$( echo "$OUT" | cut -d' ' -f1 | while read LINE; do echo -n "$LINE"; done )"	# remove LF/CR

	if [ $RC -ne 0 ] || [ "$OUT" != "+OK+OK+OK" ]; then				# if all went fine we get 3 x OK
	
		_log do $FUNC user crit "returncode: '$RC' - '$SERVER'-answer: '$OUT' - something went wrong"
	fi
}

func_sendmail ()					# ToDo: we need a simple addressbook for phone,email,shortname,name...
{
	# while read ADDRESS; do {
	# 	func_sendmail "Team-Weimarnetz" weimarnetz@gmx.de "Weimarnetz-Teilnehmer" $ADDRESS mail.txt
	#	sleep 60
	# } done <addresses.txt

	local           FUNC="sendmail"
	local      FROM_REAL="$1"	# ARG1, string (name,  format: title, surname name  )
	local      FROM_MAIL="$2"	# ARG2, string (email, format: recipient@domain.foo )
	local RECIPIENT_REAL="$3"	# ARG3, string (name)
	local RECIPIENT_MAIL="$4"	# ARG4, string (email)
	local       MAILFILE="$5"	# ARG5, string (name of file with body-text and variables)
	local           VAR1="$6"	# ARG6, string (user-definable, for using in mail.txt)
	local           VAR2="$7"	# ARG7, string
	local           VAR3="$8"	# ARG8, string
	
	[ ! -e "$MAILFILE" ] && {
		_log do $FUNC user crit "can't read '$MAILFILE' - aborting (usage: func_$FUNC myname me@world.org yourname you@world.org mailfile"
		return
	}
	
	local        SUBJECT="$( head -n1 $MAILFILE )"
	local            OUT=""
	local           LINE
	local         NETCAT="nc"
	local         SERVER="$( nvram get fff_mail_server_smtp )"
	local           PORT="$( nvram get fff_mail_server_smtp_port )"
	local             RC=0
	local           FQDN="$( nvram get wan_hostname ).local"
	local     ADMIN_REAL="$( nvram get ff_adm_name )"
	local     ADMIN_MAIL="$( nvram get ff_adm_mail )"
	local      NICE_DATE="$( date "+%d.%b'%y-%H:%M" )"									# 06.May'08-18:10
	local      MAIL_DATE="$( date "+%a, " )$( date "+%e " | sed 's/ //' )$( date "+%b %Y %X %z" | sed 's/-0/+0/' )"		# Wed, 7 May 2008 16:04:59 +0200
	local           MAIL="/tmp/outgoing_mail_$NICE_DATE"
	
	func_mail_check_pop3_stats			# pop before smtp must be configured on mailserver
	
	echo  >$MAIL -n "HELO ${FQDN}\r\n"
	echo >>$MAIL -n "MAIL FROM: \"${FROM_REAL}\" <${FROM_MAIL}>\r\n"
	echo >>$MAIL -n "RCPT TO: \"${RECIPIENT_REAL}\" <${RECIPIENT_MAIL}>\r\n"
	# can be multiple RCPT's:
	# echo >>$MAIL -n "RCPT TO: \"${ADMIN_REAL}\" <${ADMIN_MAIL}>\r\n"
	echo >>$MAIL -n "DATA\r\n"
	echo >>$MAIL -n "From: \"${FROM_REAL}\" <${FROM_MAIL}>\r\n"
	echo >>$MAIL -n "To: \"${RECIPIENT_REAL}\" <${RECIPIENT_MAIL}>\r\n"
	# echo >>$MAIL -n "Cc: \"${ADMIN_REAL}\" <${ADMIN_MAIL}>\r\n"
	echo >>$MAIL -n "Subject: ${SUBJECT}\r\n"
	echo >>$MAIL -n "Date: ${MAIL_DATE}\r\n"
	echo >>$MAIL -n "Message-ID: <$( date +%s%d%b%y-%H_%M )@${FQDN}>\r\n"				# 121016909907May08-16_04@buffalo422.local
	echo >>$MAIL -n "MIME-Version: 1.0\r\n"
	echo >>$MAIL -n "Content-Type: text/plain; charset=iso-8859-1\r\n"
	echo >>$MAIL -n "Content-Transfer-Encoding: quoted-printable\r\n"

	# echo >>$MAIL -n "Organization: ${ADMIN_REAL}\r\n"
	# echo >>$MAIL -n "Reply-To: \"${ADMIN_REAL}\" <${ADMIN_MAIL}>\r\n"
	echo >>$MAIL -n "Organization: Weimarnetz e.V.\r\n"
	echo >>$MAIL -n "Reply-To: \"Weimarnetz e.V.\" <wireless-discuss@subsignal.org>\r\n"
	
	echo >>$MAIL -n "X-Mailer: netcat $( $NETCAT --help 2>&1 | grep -i " v" )\r\n"
	echo >>$MAIL -n "X-Operating-System: $( cat /proc/version )\r\n"
	echo >>$MAIL -n "X-Firmware: $( grep ^Kit: /etc/freifunk-release )\r\n"
	echo >>$MAIL -n "\n"
	sed '3,99!d' $MAILFILE | while read LINE; do echo -n "${LINE}\r\n"; done >>$MAIL	# 1st/2nd line is crap
	echo >>$MAIL -n "\r\n.\r\nQUIT\r\n"

	OUT="$( echo -e "$(cat $MAIL)" | $NETCAT $SERVER $PORT )"	# fixme! correct LF/CR with 'while read LINE; do echo -e \r\n...'
				
	RC=$?
	OUT="$( echo "$OUT" | strings | sed -e 's/ //g' -e 's/^\([0-9]*\).*$/\1_/' | while read LINE; do echo -n "$LINE"; done )"	# extract error-codes + remove LF/CR

												# fixme! for each RCPT we must add an "2502_"
	if [ $RC -ne 0 ] || [ "$OUT" != "220_250_2502_2502_354_2502_2212_" ]; then		# error-codes, when all went fine (RCPT=OK=2502)
	
		_log do $FUNC user crit "error for recipient '${RECIPIENT_MAIL}': returncode: '$RC' - '$SERVER'-answer: '$OUT' - debug file '$MAIL'"
	else
		_log do $FUNC user notice "sent mail to '$RECIPIENT_MAIL' went fine"
		rm "$MAIL"
	fi
}
