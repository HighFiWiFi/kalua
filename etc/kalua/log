_log_do ()				# CALL: _log do my_function_name daemon info "mytext"
{
	[ -e /tmp/LOWMEM ] && return	# fixme! maybe everlasting and log to console should work?

	local FATHER_PROCESS="$0"
	local       FUNCTION="$1"	# ARG1, string (name of function, from where call was invoked)
	local       FACILITY="$2"	# ARG2, string (source = kern,user,mail,daemon,syslog,lpr,news,uucp,cron,authpriv,local0-7)
	local           PRIO="$3"	# ARG3, string (emerg,alert,crit,err,warning,notice,info,debug)		// idee: sms
	local        MESSAGE="$4"	# ARG4, string (humanreadable verbose message, all is syslog-alike)
	local        EVERLOG="/www/everlasting_syslog.txt"

	shell_is_interactive ()
	{
		case "$-" in
			*i*)
				return 0
			;;
			*)
				case "$SHELL" in
					"/bin/ash"|"-ash")
						return 0
					;;
					*)
						return 1
					;;
				esac
			;;
		esac
	}
	
	case "$PRIO" in
		debug|emerg|alert|crit)
			_system include
			local MEM="$(    _system ram_free )"
			local UPTIME="$( _system uptime      )"
			local DATE="$(   _system date	     )"

			[ "$PRIO" != "debug" ] && {		# write to logfile in flash, which is not lost after reboot
			
				[ "$( _system flash_free )" -gt 150 ] && {
					echo >>$EVERLOG "$DATE ° [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE"
				}
				
				MESSAGE="$( _sanitizer do "$MESSAGE" strip_newlines )"
				local UNIXTIME="$( _system date unixtime )"
				local ARCHIV_NODE_MESSAGE="$DATE ° [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE"
				echo >>/tmp/ARCHIV_MONITORING "log=$( _sanitizer do "$ARCHIV_NODE_MESSAGE" urlvalue )&time=${UNIXTIME}"
				touch /tmp/SEND_ALIVE_FAILED
			}
		;;
	esac

	shell_is_interactive && {

		[ -z "$MEM" ] && {
			_system include
			local MEM="$(	 _system ram_free )"
			local UPTIME="$( _system uptime      )"
			local DATE="$(   _system date        )"
		}
							# fixme! i can't see that, e.g. _net mac2vendor $MAC	
		FATHER_PROCESS="TERM:${TERM} $0"
		echo "$DATE ° [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE" 1>&2   # to stderr
	}

	if [ "$PRIO" = "debug" ]; then

		[ ! -e /tmp/DEBUG ] && {
			shell_is_interactive || return
		}

		[ -e /tmp/BOOT ] && {
			pidof syslogd >/dev/null || {		# write to special logfile
				echo >>/tmp/messages "$DATE ° [up $(cut -d" " -f1 /proc/uptime)s] ${FACILITY}.${PRIO} fff+ $FATHER_PROCESS ${FUNCTION}() $MESSAGE"
				# _log netmessage "$MESSAGE"	# fixme!
			}
		}
	else
		[ -e /tmp/BOOT ] && {
			pidof syslogd >/dev/null || {		# write to special logfile
				echo >>/tmp/messages "$DATE ° [up $(cut -d" " -f1 /proc/uptime)s] ${FACILITY}.${PRIO} fff+ $FATHER_PROCESS ${FUNCTION}() $MESSAGE"	
				# _log netmessage "$MESSAGE"	# fixme!
			}
		}
	fi

	# fixme! howto print out logging when webserver executes a script?

	logger -t "fff+ $FATHER_PROCESS ${FUNCTION}()" -p "${FACILITY}.${PRIO}" -- "$MESSAGE"
}

_log_netmessage () 		# SENS: sends a human-readable UDP netmessage to all broadcast-destinations
{
	# readable per tcpdump: (each line are 16 bytes)
	# tcpdump -s 500 -nXi $DEVICE udp and port 2049

	local  MESSAGE="$1"	# ARG1: string
	local  BROADCAST
	local  DESTINATIONS="$( ip address show |
	                         sed -n 's/^.* brd \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\).*/255.255.255.255\n\1/p' |
	                          sort | uniq )"

	for BROADCAST in ${DESTINATIONS:=255.255.255.255}; do {
		netmsg $BROADCAST "__$MESSAGE"				# fixme! at early boot, there are no interfaces up...
	} done
}
