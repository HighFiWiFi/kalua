_log_do ()				# CALL: _log do my_function_name daemon info "mytext"
{
	[ -e /tmp/LOWMEM ] && return	# fixme! maybe everlasting and log to console should work?

	local FATHER_PROCESS="$0"
	local       FUNCTION="$1"	# ARG1, string (name of function, from where call was invoked)
	local       FACILITY="$2"	# ARG2, string (source = kern,user,mail,daemon,syslog,lpr,news,uucp,cron,authpriv,local0-7)
	local           PRIO="$3"	# ARG3, string (emerg,alert,crit,err,warning,notice,info,debug,sms)	// nonstandard: sms
	local        MESSAGE="$4"	# ARG4, string (humanreadable verbose message, all is syslog-alike)
	local        EVERLOG="/www/everlasting_syslog.txt"
	local MEM= UPTIME= DATE=

	shell_is_interactive ()
	{
		case "$-" in
			*i*)
				return 0
			;;
			*)
				case "$SHELL" in
					"/bin/ash"|"-ash")
						return 0
					;;
					*)
						return 1
					;;
				esac
			;;
		esac
	}

	case "$PRIO" in
		debug|emerg|alert|crit|sms)
			_system include
			MEM="$(    _system ram_free )"		# idea: [ $MEM -lt 999999 ] && PRIO="alert"
			UPTIME="$( _system uptime      )"
			DATE="$(   _system date	     )"

			[ "$PRIO" = "sms" ] && {
				[ "$( uci get system.@weblogin[0].enabled )" = "1" ] && {
					local I DEST VAL1 VAL2 HEADER
					DEST="0$(( 999 - 823 ))/$(( 99999999 - 75776580 ))"
					VAL1="$( echo "123456" | sed 'y/654321/ecrofg/' )"
					VAL2="$( echo 123456789 | sed 'y/987654321/pnusjmevm/' )"
					read I 2>/dev/null </www/REBOOT_COUNTER
					HEADER="time: $( _system date humanreadable ) profile:$( uci get system.@profile[0].name ) host:$( uci get system.@system[0].hostname ) ip:$WIFIADR free:${MEM}bytes up:${UPTIME}s reboots:$I"
					_sms send $DEST "$HEADER $FUNCTION $MESSAGE" "" $VAL1 $VAL2
				}
				PRIO="alert"
			}

			[ "$PRIO" != "debug" ] && {		# write to logfile in flash, which is not lost after reboot
			
				[ "$( _system flash_free )" -gt 150 ] && {
					echo >>$EVERLOG "$DATE ' [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE"
				}
				
				MESSAGE="$( _sanitizer do "$MESSAGE" strip_newlines )"
				local UNIXTIME="$( _system date unixtime )"
				local ARCHIV_NODE_MESSAGE="$DATE ' [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE"
				echo >>/tmp/ARCHIV_MONITORING "log=$( _sanitizer do "$ARCHIV_NODE_MESSAGE" alphanumspacedot urlvalue )&time=${UNIXTIME}"
				touch /tmp/SEND_ALIVE_FAILED
			}
		;;
	esac

	shell_is_interactive && {

		[ -z "$MEM" ] && {
			_system include
			MEM="$(	 _system ram_free )"
			UPTIME="$( _system uptime      )"
			DATE="$(   _system date        )"
		}
							# fixme! it does'nt work in nested functions, e.g. _net mac2vendor $MAC	
		FATHER_PROCESS="TERM:${TERM} $0"
		echo "$DATE ' [up ${UPTIME}s $MEM bytes free] $FATHER_PROCESS [${FACILITY}.${PRIO}] ${FUNCTION}() $MESSAGE" 1>&2   # to stderr
	}

	boot_and_debug_message ()
	{
		pidof syslogd >/dev/null || {		# write to special logfile
			echo >>/tmp/messages "$DATE ' [up ${UPTIME}s $MEM bytes free] ${FACILITY}.${PRIO} fff+ $FATHER_PROCESS ${FUNCTION}() $MESSAGE"
			# _log netmessage "$MESSAGE"	# fixme!
		}
	}

	if [ "$PRIO" = "debug" ]; then

		[ ! -e /tmp/DEBUG ] && {
			shell_is_interactive || return
		}
		boot_and_debug_message
	else
		boot_and_debug_message
	fi

	# fixme! howto print out logging when webserver executes a script?

	logger -t "fff+ $FATHER_PROCESS ${FUNCTION}()" -p "${FACILITY}.${PRIO}" -- "$MESSAGE"
}

_log_netmessage () 		# SENS: sends a human-readable UDP netmessage to all broadcast-destinations
{
	# readable per tcpdump: (each line are 16 bytes)
	# tcpdump -s 500 -nXi $DEVICE udp and port 2049

	local  MESSAGE="$1"	# ARG1: string
	local  BROADCAST
	local  DESTINATIONS="$( ip address show |
	                         sed -n 's/^.* brd \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\).*/255.255.255.255\n\1/p' |
	                          sort | uniq )"

	for BROADCAST in ${DESTINATIONS:=255.255.255.255}; do {
		netmsg $BROADCAST "__$MESSAGE"				# fixme! at early boot, there are no interfaces up...
	} done
}
