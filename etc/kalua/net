_net_mac2vendor ()
{
	local FUNC="net_mac2vendor"
	local MAC="$1"
	local KEYWORD="$2"
	local URL="http://84.38.67.43/macs"	# intercity-vpn.de
	local MAC_SANITIZED
	local CACHE="/tmp/CACHE_MAC2VENDOR_$MAC"
	
	[ ! -e "$CACHE" ] && {

		if [ ${#MAC} -ne 6 ]; then
			MAC_SANITIZED="$( _sanitizer do "$MAC" mac hex lowercase length:6 )"
			[ -z "$MAC_SANITIZED" ] && {
				_log do $FUNC daemon info "could not sanitize: '$MAC'"
				return 1
			}
		else
			MAC_SANITIZED="$MAC"
		fi

		wget -qO "$CACHE" "$URL/$MAC_SANITIZED"
	}

	if [ "$KEYWORD" = "short" ]; then
		head -n1 $CACHE
	else
		head -n9 $CACHE
	fi
}

_net_ip4_is_private ()
{
	local IP="$1"
	
	echo $IP | grep -q ^"192\.168\." && return 0
	echo $IP | grep -q ^"172\.16\." && return 0
	echo $IP | grep -q ^"10\." && return 0
	echo $IP | grep -q ^"169\.254\." && return 0

	return 1
}

_net_ip2hostname ()
{
	local HOST="$( nslookup $1 | sed -n 's/^Name: *\([A-Za-z0-9\._-]*\)/\1/p' )"                                                                                        
        
        echo -n "${HOST:-?}"
}

_net_ip2dns ()
{
	nslookup $1 | sed -n "s/^Name:[^a-zA-Z0-9]*\(.*\)/\1/p"
}

_net_ip2mac ()		# ofcourse this works only for local IP's, but: maybe we want to "guess" using /etc/ethers...?
{
	ip neigh show to $1 | sed -n "s/^.* lladdr \(..:..:..:..:..:..\) .*/\1/p;q"
}

_net_dns2ip ()
{
	nslookup $1 | sed -n '5s/^Address:[^0-9]*\([0-9\.]*\)/\1/p'
}

_net_dev2mac ()
{
	ip -o link show $1 | sed -n 's/^.*ether \(..:..:..:..:..:..\) .*/\1/p;q'
}

_net_devtype2symbol ()
{
	case $1 in
		tunnel) echo -n '=' ;;
	 	  wifi) echo -n '~' ;;
		     *) echo -n "-" ;;
	esac
}

_net_dev_type ()		# OUT1: string, "wifi/tunnel/wire"
{
	local DEV="$1"
	local OPTION="$2"	# short
	local OUT
	
	if   _net dev_is_wifi $DEV ; then
		OUT="wifi"
	elif _net dev_is_tuntap $DEV ; then
		OUT="tunnel"
	else
		OUT="wire"
	fi
	
	[ "$OPTION" = "short" ] && {
		OUT="$( _net devtype2symbol )"
	}
	
	echo -n "$OUT"
}

_net_ip2metric ()
{
	ip route list $1 | sed -n 's/^.*metric \([0-9]*\).*/\1/p'
}

_net_dev_is_wifi ()
{
	grep -q "^.*$1:" /proc/net/wireless && return 0
	return 1
}

_net_dev_is_tuntap ()
{
	local KEYWORD="$( echo $1 | sed -n 's/^\([a-z]*\)[0-9]*/\1/p' )"
	
	[ "$KEYWORD" = "tun" ] && return 0
	[ "$KEYWORD" = "tap" ] && return 0
	return 1
}

_net_ip2dev ()
{
	ip -oneline route get $1 | sed -n 's/^.* dev \([a-zA-Z0-9@\.]*\)[^a-z]*src .*/\1/p'
}

_net_iplocal2dev ()		# does it really make sense to have this func?
{
	ip -oneline address show | sed -ne "/ inet $1\//{s/^[0-9]*: \([a-zA-Z0-9@\.]*\).*/\1/p;q}"
	
	# does not work for local IP's:
	# ip -o route get $1 | cut -d' ' -f3
}

_net_local_inet_offer ()		# SENS: check if default-route is local
{					# OUT1: string, false|wan|lan|pppoe
	local MODE="false"		# RC: true = inetoffer, false = no inetoffer
	local FUNC="net_local_inet_offer"
	local PHYDEV=0
	local METRIC=0
	local D=0
	local N=0

	[ ! -e /tmp/NETPARAM ] && {			# early_boot_estimation is for _profile()

		local  WAN_GATEWAY="$( nvram get wan_gateway )"
		[ -n "$WAN_GATEWAY" ] && {
			
			if [ "$WAN_GATEWAY" = "0.0.0.0" ]; then
				_nvram set wan_gateway 
				_nvram set commit "config-mistake, unsetting wan-gateway which was '$WAN_GATEWAY'"
			else
				[ "$( nvram get wan_proto )" = "pppoe" ] && {
					_log do $FUNC daemon info "early_boot_estimation: pppoe"
					echo "pppoe"
					return 0			# fixme!
				}
			
				_log do $FUNC daemon info "early_boot_estimation: wan"
				echo "wan"
				return 0
			fi
		}
	
		[ -n "$( nvram get lan_gateway )" ] && {
			_log do $FUNC daemon info "early_boot_estimation: lan"
			echo "lan"
			return 0
		}

		/etc/init.d/S52vpnc_fff+ check && {
			_log do $FUNC daemon info "early_boot_estimation: tun"
			echo "tun"
			return 0
		}

		# fixme! wan-dhcp?

		_log do $FUNC daemon info "early_boot_estimation: false"
		echo "false"
		return 1
	}

	local  LAN_GATEWAY="$( nvram get lan_gateway )"
	if [ -n "$LAN_GATEWAY" ] && [ -z "$( ip route list exact 0/0 via $LAN_GATEWAY )" ]; then

		[ "$LAN_GATEWAY" != "0.0.0.0" ] && {
			_log do $FUNC daemon info "alien_gateway '$LAN_GATEWAY': lan"
			echo "lan"
			return 0		# gets applied during '/etc/local.fw-fff+ masq'
		}
	fi

	# only look for the first default-route
	# some examples:
	#
	# default via 192.168.1.1 dev vlan1		-> wan-offer|wan_gateway
	# default via 191.255.255.1 dev venet0		-> root-server
	# default via 217.0.116.253 dev ppp0		-> pppoe
	# default dev tun0  scope link			-> vpnc
	# default via 10.63.52.36 dev br0 		-> lan-offer|lan-gateway
	
	eval $( ip route list exact 0/0 | head -n1 |
		while read N N D N PHYDEV METRIC N; do {	# we must eval it, otherwise		// fixme! look for 'table all'?
			echo PHYDEV=$PHYDEV			# the vars from subprocess are
			echo METRIC=$METRIC			# not known
			echo N=$N
			echo D=$D				# fixme! better use 'eval $( ip route list exact 0/0 | sed 'xyz' )'
		} done
	)

	if [ -z "$METRIC" ]; then				# found no metric = local inet-offer

		_log do $FUNC daemon debug "PHYDEV: '$PHYDEV' METRIC: '$METRIC' N: '$N' D: '$D'"

		if [ -z "${PHYDEV}${METRIC}${N}" ]; then	# ip route list exact 0/0 -> "default via eth0" or similar

			[ "$LAN_GATEWAY" = "0.0.0.0" ] && {	# fixme! move to early-boot-estimation
				
				_nvram set lan_gateway 
				_nvram set commit "config-mistake, unsetting lan-gateway which was '$LAN_GATEWAY'"
				
				ip route delete default via $D
			}
		else
			if   [ "$PHYDEV" = "$WANDEV" ]; then
				MODE="wan"
			elif [ "$PHYDEV" = "$LANDEV" ]; then
				MODE="lan"
			else
				MODE="pppoe"	# && WANDEV=ppp0          # fixme! this is not exact!
			fi
			
			[ "$PHYDEV" = "link" ] && {
				if   echo $D | grep -q "^tun[0-9]*" ; then
					MODE=tun
				elif echo $D | grep -q "^tap[0-9]*" ; then
					MODE=tap
				else
					MODE="$D"				# e.g. tun0 / vpnc
				fi
			}
			
			_log do $FUNC daemon info "found local default-gateway over device '$PHYDEV' = '$MODE'"
		fi
	else
		if [ $N -eq 0 ]; then
			_log do $FUNC daemon info "no local default-gateway, no default-gateway, no internet 8-("
		else
			_log do $FUNC daemon info "no local default-gateway found, only $N hops away 8-)"
		fi
	fi

	echo $MODE

	[ "$MODE" = "false" ] && return 1	
	return 0
}

_net_inet_seems_stable ()			# fixme! also check path to gateway (add wireless costs/hops)
{						# fixme! apply these checks regulary
	local FILE="/tmp/GATEWAY_CHECK_RECENT"	# fixme! test dns also?
	local FUNC="inet_seems_stable"
	
	_olsr uptime is_short || {
		[ -z "$( ip route list exact 0/0 table main )" ] && {
			_log do $FUNC daemon alert "unstable inet, no default route in main-table"
			return 1
		}
	}

	[ -e "$FILE" ] && {
		. $FILE 2>/dev/null				# fixme! use local vars
		[ "$COST_INT" 2>/dev/null -gt 8000 ] && {
			_log do $FUNC daemon alert "unstable inet, cost_int: '$COST_INT'"
			return 1
		}
	}
	
	return 0
}

_net_mac2ip ()		# SENS: get IP from different sources		# ARP-cache   (macs are lowercase)
{									# DHCP-leases (macs are lowercase)
	local MAC="$( _sanitizer do "$1" lowercase )"			# /etc/ethers (macs are lowercase)
	local IP							# not used: /proc/net/arp (macs are uppercase)

	IP="$( ip neigh show | sed -n "s/^\(.*\) dev .* lladdr ${MAC} nud.*/\1/p" )"

	[ -z "$IP" ] && {
		IP="$( sed -e "/$MAC/!d" -ne 's/^.* ..:..:..:..:..:.. \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .*/\1/p' /var/run/dhcp.leases )"

		[ -z "$IP" ] && {
			local HOSTNAME="$( sed -n "s/^$MAC \(.*\)/\1/p" /etc/ethers )"
			[ -n "$HOSTNAME" ] && {
				IP="$( sed -n "/$HOSTNAME/s/^\([0-9\.]*\) ${HOSTNAME}.*/\1/p" /etc/local.hosts )"
			}
		}
	}

	echo -n $IP
}

_net_mac2hostname ()
{
	local MAC="$1"                                                                                                                                                
	local NAME="$( grep -i $MAC /etc/ethers | sed -n 's/^..:..:..:..:..:.. \(.*\)-.*-.*\..*$/\1/p' )"	# cutting off e.g. "-lan1-n364.domain"
	echo ${NAME:=anonym}                                                                                                                                          
}

_net_mac2dev ()
{
	ip neigh | sed -n "/$1/{s/^.* dev \(.*\) lladdr .*/\1/p;q}"
}

_net_mac2media ()
{
	local     MAC="$1"					# ARG1: (string) mac-address
	local   SHORT="$2"					# ARG2: (string) keyword "short" (optional)
	local     OUT=0						# OUT1: (string) wifi,wire OR ~,-

	local DEV="$( _net mac2dev $MAC )"
	
	  if [ "$DEV" = "$WIFIDEV" ]; then
	  	OUT=wifi
	elif nvram get fff_ethers_wifi | grep -qi $MAC ; then
		OUT=wifi
	elif grep -q ^"$( _sanitizer do "$( _net mac2ip $MAC )" escape_dots );" /tmp/CLIENTS_WIFI 2>/dev/null ; then
		OUT=wifi
	else
		OUT=wire		# fixme! this can also be guessed!
	fi

	[ -n "$SHORT" ] && OUT="$( _net devtype2symbol $DEV )"

	echo -n "$OUT"
}

_net_arp_permanent ()					# ARG1:ip ARG2:mac ARG3:wifi or wire
{
	local FUNC="net_arp_permanent"
        local IP="$1"
        local MAC="$( _sanitizer do "$2" lowercase )"
        local FORCE="$3"						# fixme! use also IP to guess interface
        
        _log do $FUNC daemon info "IP: '$IP' MAC: '$MAC' FORCE: '$FORCE'"
        
	local LINE="$( ip neigh show to $IP 2>/dev/null )"
	
	echo "$LINE" | grep -q "nud permanent" && {
		_log do $FUNC daemon info "already permanent - do nothing"
		return
	}

	local DEV="$( _net mac2dev $MAC )"
	local MODE="add"
	
	[ -n "$LINE" ] && {
		_log do $FUNC daemon info "already found - MODE: 'change'"
		MODE="change"
	}

 	if [ -z "$DEV" ]; then
		_log do $FUNC daemon info "not in neigh-list, probing"
 		  
 		  if [ "$FORCE" = "wifi" ]; then
 			
 			_log do $FUNC daemon info "enforced wifi"
 			DEV=$WIFIDEV
 		
 		elif [ "$( _net mac2media $MAC )" = "wire" ]; then
 		
 			_log do $FUNC daemon info "detected wire"
 			DEV=$LANDEV
 		else
 			_log do $FUNC daemon info "fallback to wifi"
 			DEV=$WIFIDEV
 		fi
 	else
 		_log do $FUNC daemon info "DEV from ip_neigh: '$DEV'"
 	fi
 
	_log do $FUNC daemon info "ip neigh $MODE $IP dev $DEV lladdr $MAC nud permanent"
	ip neigh $MODE $IP dev $PHYSDEV lladdr $MAC nud permanent 2>/dev/null
}

_net_cidr2mask ()		# OUT1: string
{
	local o=0
	
	case $1 in
		31) o=255.255.255.254 ;;
		30) o=255.255.255.252 ;;
		29) o=255.255.255.248 ;;
		28) o=255.255.255.240 ;;
		27) o=255.255.255.224 ;;
		26) o=255.255.255.192 ;;
		25) o=255.255.255.128 ;;
		24) o=255.255.255.0 ;;
		23) o=255.255.254.0 ;;
		22) o=255.255.252.0 ;;
		21) o=255.255.248.0 ;;
		20) o=255.255.240.0 ;;
		19) o=255.255.224.0 ;;
		18) o=255.255.192.0 ;;
		17) o=255.255.128.0 ;;
		16) o=255.255.0.0 ;;
		15) o=255.254.0.0 ;;
		14) o=255.252.0.0 ;;
		13) o=255.248.0.0 ;;
		12) o=255.240.0.0 ;;
		11) o=255.224.0.0 ;;
		10) o=255.192.0.0 ;;
		 9) o=255.128.0.0 ;;
		 8) o=255.0.0.0 ;;
		 7) o=254.0.0.0 ;;
		 6) o=252.0.0.0 ;;
		 5) o=248.0.0.0 ;;
		 4) o=240.0.0.0 ;;
		 3) o=224.0.0.0 ;;
		 2) o=192.0.0.0 ;;
		 1) o=128.0.0.0 ;;
		 *) o=255.255.255.255 ;;
	esac
	
	echo -n $o
}
