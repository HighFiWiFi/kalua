_software_make_free_space ()
{
	local FUNC="ipkg_make_free_space"
	local SPACE_WISH="$1"
	local FREE=0
	local IPK

	for IPK in $( _software show_installed_backwards ); do {
	
		FREE="$( _system flash_free )"
		_log do $FUNC daemon debug "now $FREE kb"
	
		[ $FREE -gt $SPACE_WISH ] && {
			_log do $FUNC daemon debug "ready"
			break
		}
	
		_software is_essential $IPK || {			# prevents chicken egg-problem
			_log do $FUNC daemon alert "removing '$IPK'"
			_software package_remove $IPK
		}
	} done
}

_software_is_essential ()	# fixme! how to determine, if package is part of a meta-package? maybe this
{				#	 doesn't matter, removing meta-packages doesn't effect child-packages
	local PACKAGE="$1"
	
	case $PACKAGE in
		freifunk-pppoecd-*) return 0 ;;		# PPPoE
		      kmod-madwifi) return 0 ;;		# atheros
		             iwlib) return 0 ;;		# atheros
		    wireless-tools) return 0 ;;		# atheros
		     madwifi-tools) return 0 ;;		# atheros
				ip) return 0 ;;		# base
				wl) return 0 ;;		# base
			  wificonf) return 0 ;;		# base
			    kernel) return 0 ;;		# base
			base-files) return 0 ;;		# base
		 freifunk-webadmin) return 0 ;;		# base
		   freifunk-upload) return 0 ;;		# base
		  freifunk-mtdkill) return 0 ;;		# base
		    freifunk-rdate) return 0 ;;		# base
		    freifunk-olsrd) return 0 ;;		# base
			  dropbear) return 0 ;;		# base
		       busybox-awk) return 0 ;;		# base
			    wl-adv) return 0 ;;		# base/emergency_wifi_situations
		                 *) return 1 ;;
	esac
}

_software_show_installed_backwards ()	# OUT1: list
{
	ipkg status |
	 sed -n 's/^Package: \(.*\)/\1/p' |
	  sed '1!G;h;$!d'
}

_software_repos_list_files ()	# OUT1: list
{
	cat /usr/lib/ipkg/lists/* 2>/dev/null || {
		echo
		return 1
	}
}

_software_repos_update ()
{
	local FILE_LAST_FETCH="/tmp/ipkg_last_repository_update"
	local UNIXTIME_UPDATE=0
	local UNIXTIME_NOW="$( date +%s )"
	
	  if [ "$( _software repos_list_files | wc -l )" -lt 100 ]; then
	  
	  	UNIXTIME_UPDATE=0

	elif [ -e $FILE_LAST_FETCH ]; then
	  
		UNIXTIME_UPDATE="$( cat $FILE_LAST_FETCH )"
	else
		UNIXTIME_UPDATE=0
	fi
	
	[ $(( ${UNIXTIME_NOW:-0} - ${UNIXTIME_UPDATE:-0} )) -gt 1800 ] && {
		ipkg update
		echo $UNIXTIME_NOW >$FILE_LAST_FETCH
	}
}

_software_package_install ()
{
	_software repos_update
	ipkg -force-defaults install "$1"
}

_software_package_remove ()
{
	local FUNC="ipkg_remove"
	local PACKAGE="$1"
	
	_log do $FUNC daemon debug "'$PACKAGE'"
	ipkg remove $PACKAGE
	
	[ ! -e /sbin/reboot ] && ln -s /rom/sbin/reboot /sbin/reboot	# loginutils
	[ -z "$( date 2>/dev/null )" ] && ln -s busybox /bin/date	# busybox-coreutils
}

_software_package_is_installed ()
{
	ipkg status "$1" | grep -q "Status: install ok installed" && return 0
	
	return 1
}

_software_package_is_not_installed ()
{
	ipkg status "$1" | grep -q "Status: install ok installed" || return 0

	return 1
}

_software_packages_install ()
{
	local PACKAGE_NAME="$1"
	
	_software package_install	$PACKAGE_NAME			# fixme! better names for package_install <-> packages_install
	_software package_is_installed	$PACKAGE_NAME || return 1

	return 0
}

_software_package_upgrade ()	# fixme! /usr/sbin/cron.upgrade_packages
{
	local PACKAGE_NAME="$1"
	local PACKAGE_VERSION_HERE=0
	local PACKAGE_VERSION_REPO=0
	
	echo
}

_software_package_version ()
{
	local PACKAGE_NAME="$1"
	local VERSION="$( ipkg status "$PACKAGE_NAME" | sed -n 's/^Version: \(.*\)/\1/p' | tail -n1 )"

	[ -n "$VERSION" ] && {
		echo $VERSION
		return
	}

	return 1
}

_software_package_newer_version ()	# compare the values and return the newer one
{
	local VERSION_A="$1"
	local VERSION_B="$2"

	  if [ "$( _software version_normalize $VERSION_A )" -gt "$( _software version_normalize $VERSION_B )" ]; then
	
		echo -n "$VERSION_A"
	
	elif [ "$( _software version_normalize $VERSION_B )" -gt "$( _software version_normalize $VERSION_A )" ]; then

		echo -n "$VERSION_B"
	fi
}

_software_version_normalize ()
{
	local VERSION="$1"
	local X Y Z N

	# bash can't calculate with floats, so we normalize to 100.000.000, e.g.:
	#
	# v  X.  Y.  Z
	# v  1.222.333 -> 001222333 (2 dots)
	# v111.222.333 -> 111222333 (2 dots)
	# v  4.222     -> 004222000 (1 dot)
	# v  5         ->   5000000 (0 dots)

	local DOTS="$( echo -n $VERSION | sed 's/[^\.]//g' )"
	
	case "${#DOTS}" in
		0)
			X="$VERSION"
		;;
		1)
			X=${VERSION%[.]*}
			Y=${VERSION#*.}
		;;
		2)
			N=${VERSION%[.]*}
			X=${N%[.]*}
			
			N=${VERSION#*.}
			Y=${N%[.]*}
			Z=${N#*.}
		;;
	esac

	for N in "$X" "$Y" "$Z"; do {
	
		case ${#N} in
			0)
				echo -n "000"
			;;
			1)
				echo -n "00$N"
			;;
			2)
				echo -n "0$N"
			;;
			*)
				echo -n "${N:=000}"
			;;
		esac
	} done
}
