fkt_sleep_random_seconds_but_max ()
{
	local FUNC="sleep_random_seconds_but_max"
	local WAIT="$( _math random_integer 0 $1 )"

	_log do $FUNC daemon debug "sleeping $WAIT sec"

	sleep $WAIT
}

fkt_check_if_lowflash_device () {	# SENS: checks if this device has less then 4mb flash-memory
	local BORDER="4096"		# OUT1: string, "true" if < 4096 kb
	local  FLASH="0"
	local DAEMON="fkt_check_if_lowflash_device"
	local    OUT="false"

	FLASH=$( _system flash_size )
	
	fkt_log "$DAEMON" "$OUT (Flash-Size detected: $FLASH Kilobytes)" 1
	
	test "$FLASH" -lt "$BORDER" && OUT="true"

	echo $OUT
}

fkt_build_etc_local_hosts () {				# SENS: modulary builds /etc/local.hosts
	local FUNC="build_etc_local_hosts"
	local DAEMON="fkt_build_etc_local_hosts"
	local FILE="/etc/local.hosts"
	local SUB_PATH="/tmp/"
	local SUB_DROP="${SUB_PATH}hosts.drop"
	local SUB_VIRT="${SUB_PATH}hosts.virtual"
	local SUB_WIFI="${SUB_PATH}hosts.wifi"
	local SUB_LAN="${SUB_PATH}hosts.lan"
	local DOMAIN="$(nvram get wan_domain)"
	local LINE=""

	. /tmp/NETPARAM

	case $1 in
		join)
			fkt_log "$DAEMON" "Joining \"$SUB_LAN\", \"$SUB_WIFI\", \"$SUB_VIRT\", \"$SUB_DROP\" to \"$FILE\""
			cat 2>/dev/null $SUB_LAN $SUB_WIFI $SUB_VIRT $SUB_DROP >$FILE
			rm  2>/dev/null $SUB_LAN $SUB_WIFI $SUB_VIRT $SUB_DROP
		;;
		wifi)
			fkt_log "$DAEMON" "Building wifi-entrys"
			echo  >$SUB_WIFI "# entrys for wifi-subnet"

			DEFAULT="wardriver"
			NODE="$(nvram get fff_node_number)"
			DOMAIN="$(nvram get wan_domain)"
			CLIENT=0
			MODE="$1"
			
			while read LINE; do
				let CLIENT+=1
				IFS=";"
				set $LINE
				
				OUT="$(grep "\-${MODE}${CLIENT}\-" /etc/ethers)" # exists in /etc/ethers?
				
				if [ -z "$OUT" ]; then				# anonymous without hard /etc/ethers entry
					echo "$1 ${DEFAULT}-${MODE}${CLIENT}-n$NODE.$DOMAIN ${DEFAULT}-${MODE}${CLIENT}-n$NODE"
				else						# is in /etc/ethers
					echo "$1 $(echo "$OUT" | cut -d" " -f2) $(echo "$OUT" | cut -d" " -f2 | cut -d"." -f1)" 	
				fi
				
				unset IFS
			done <"$CLIENTS_WIFI" >>$SUB_WIFI
			
			echo >>$SUB_WIFI
		;;
		lan)
			fkt_log "$DAEMON" "Building lan/wan-entrys"
			echo  >$SUB_LAN "# entrys for lan-subnet"
			
			[ -n "$WANADR" ] && {
				echo >>$SUB_LAN "# WAN (start)"
				echo >>$SUB_LAN "$WANADR $(nvram get wan_hostname).$DOMAIN $(nvram get wan_hostname)"
				echo >>$SUB_LAN "# WAN (end)"
			}

			DEFAULT="anonymous"
			NODE="$(nvram get fff_node_number)"
			DOMAIN="$(nvram get wan_domain)"
			CLIENT=0
			MODE="$1"
			
			while read LINE; do
				let CLIENT+=1
				IFS=";"
				set $LINE
				
				OUT="$(grep "\-${MODE}${CLIENT}\-" /etc/ethers)"	# exists in /etc/ethers?

				if [ -z "$OUT" ]; then					# anonymous without hard /etc/ethers entry
					echo "$1 ${DEFAULT}-${MODE}${CLIENT}-n$NODE.$DOMAIN ${DEFAULT}-${MODE}${CLIENT}-n$NODE"
				else							# is in /etc/ethers
					echo "$1 $(echo "$OUT" | cut -d" " -f2) $(echo "$OUT" | cut -d" " -f2 | cut -d"." -f1)"
				fi
				
				unset IFS
			done <"$CLIENTS_LAN" >>$SUB_LAN
			
			echo >>$SUB_LAN 	# just a blank line
		;;
		virtual)
			fkt_log "$DAEMON" "Building virtual-entrys" 
			echo  >$SUB_VIRT "# for neccesary lookups and safe reaching of device"
			echo >>$SUB_VIRT "255.255.255.255 anyhost.$DOMAIN anyhost"
			echo >>$SUB_VIRT "104.0.0.0 oldstyle_freifunk_net.$DOMAIN oldstyle_freifunk_net"
			echo >>$SUB_VIRT "127.0.0.1 localhost.$DOMAIN localhost"
			echo >>$SUB_VIRT "$LANNET local_lannet.$DOMAIN local_lannet"
			
			test ! -z "$WANADR" && echo >>$SUB_VIRT "$WANNET local_wannet.$DOMAIN local_wannet"
			
			echo >>$SUB_VIRT "$WIFINET local_wifinet.$DOMAIN local_wifinet"
			echo >>$SUB_VIRT
			echo >>$SUB_VIRT "$LANADR      kiste.$DOMAIN kiste"
			echo >>$SUB_VIRT "$LANADR        box.$DOMAIN box"
			echo >>$SUB_VIRT "$LANADR     router.$DOMAIN router"
			echo >>$SUB_VIRT "$LANADR   internet.$DOMAIN internet"
			echo >>$SUB_VIRT "$LANADR      mutti.$DOMAIN mutti" 
			echo >>$SUB_VIRT "$LANADR    linksys.$DOMAIN linksys"
			echo >>$SUB_VIRT "$LANADR    siemens.$DOMAIN siemens"
			echo >>$SUB_VIRT "$LANADR weimarnetz.$DOMAIN weimarnetz"
			echo >>$SUB_VIRT "$LANADR       dell.$DOMAIN dell"
			echo >>$SUB_VIRT "$WIFIADR     hotel.$DOMAIN hotel"
			echo >>$SUB_VIRT "$WIFIADR     login.$DOMAIN login"
			
			VPN_SERVER="$( nvram get fff_server_vpn_ip4 )"
			
			echo >>$SUB_VIRT
			echo >>$SUB_VIRT "$VPN_SERVER rootserver.$DOMAIN rootserver"
			echo >>$SUB_VIRT "$VPN_SERVER vpnserver.$DOMAIN vpnserver"
			echo >>$SUB_VIRT "$VPN_SERVER vpn.$DOMAIN vpn"
			# echo >>$SUB_VIRT "$VPN_SERVER weimarnetz.de"
			# echo >>$SUB_VIRT "$VPN_SERVER news.weimarnetz.de"
			
			echo >>$SUB_VIRT
		;;
		drop)
			echo  >$SUB_DROP "# for dropping known advertisement servers"
			echo >>$SUB_DROP "# (1.1.0.0/20 gets REJECTed, range is enough for ~4096 hosts)"
			
			local LIST="/etc/hosts.drop"						# see fff-adblock-list.ipk
		
			[ -e $LIST ] && {
				_log do $FUNC daemon debug "building drop-list"
			
				local X=0
				local Y=0
				local COUNT=0
				
				while read LINE; do {
				
					Y=$(( $Y + 1 ))
					[ $Y -gt 254 ] && {
						Y=1
						X=$(( $X + 1 ))
						COUNT=$(( $COUNT + 255 ))
					}
					
					echo "1.1.$X.$Y $LINE"
				
				} done <$LIST >>$SUB_DROP
				
				_log do $FUNC daemon debug "bilding drop-list ready ($(( $COUNT + $Y )) hosts)"
				return 0
			}
			_log do $FUNC daemon debug "no drop-list - do nothing"
		;;
	esac
}

fkt_build_settings_menu () {				# SENS: switching between "simple", "expert" and "full" settings-menu
	local DAEMON="fkt_build_settings_menu"		# ARG1: string, "simple", "expert", "full" or "" (empty)
	local MODE="$1"	
	local DEST="/www/cgi-bin"
	local ID="15"
	local ID_EXPERT="16"
	local ID_USER="17"
	local FILE="config_fff+"
	local OPT_EXPERT="gui=expert"
	local OPT_USER="gui=user"
	local TITLE="Schnelleinstellung"
	local TITLE_EXPERT="Experteneinstellung"
	local TITLE_USER="Benutzerverwaltung"
	local MENU="$(nvram get fff_menu)"

	test -n "$READONLY" && return
	test -n "$FAILSAFE" && return
	
	fkt_log "$DAEMON" "nvram is \"$MENU\", wish is \"$MODE\"" 1
	test ! -z "$MODE" && MENU=$MODE
	fkt_log "$DAEMON" "Trying to establish mode \"$MENU\"" 1

	if [ -n "$FAILSAFE" ] || [ "$(fkt_check_readonly)" = "true" ]; then
		fkt_log "$DAEMON" "No action in failsafe/readonly mode possible!"
		return
	fi

	cd $DEST

	if [ ! -e "$ID-$FILE" ]; then
		fkt_log "$DAEMON" "Inserting settings-menu entry"
		echo >$ID-$FILE "<TR ID=\"idx-$ID\"><TD><DIV CLASS=\"plugin\"><A CLASS=\"plugin\" HREF=\"$FILE\">$TITLE</A></DIV></TD></TR>"
	else
		fkt_log "$DAEMON" "Settings-menu entry already exists"
	fi

	if [ "$MENU" = "simple" ] || [ -z "$MENU" ]; then
		fkt_log "$DAEMON" "Checking if simple menu is up to date"

		test -e "$ID_EXPERT-$FILE" && mv "$ID_EXPERT-$FILE" "ghosted_$ID_EXPERT-$FILE"
		test -e "$ID_USER-$FILE"   && mv "$ID_USER-$FILE"   "ghosted_$ID_USER-$FILE"
	
		local LIST="$(ls -1 [^a-z]*)"
		for OBJ in $LIST; do
			if [ "$OBJ" != "$ID-$FILE" ]; then
				fkt_log "$DAEMON" "Moving $DEST/$OBJ to $DEST/ghosted_$OBJ"
				mv "$OBJ" "ghosted_$OBJ"
			fi
		done
	fi
	
	if [ "$MENU" = "expert" ]; then
		fkt_log "$DAEMON" "Checking if expert menu is up to date"

		local LIST="$(ls -1 [^a-z]*)"
		for OBJ in $LIST; do
			if [ "$OBJ" != "$ID-$FILE" ]; then
				fkt_log "$DAEMON" "Moving $DEST/$OBJ to $DEST/ghosted_$OBJ"
				mv "$OBJ" "ghosted_$OBJ"
			fi
		done
	fi
	
	if [ "$MENU" = "expert" ] || [ "$MENU" = "full" ]; then
		if [ ! -e "$ID_EXPERT-$FILE" ]; then
			fkt_log "$DAEMON" "Inserting expert-settings-menu entry"
			echo >$ID_EXPERT-$FILE "<TR ID=\"idx-$ID\"><TD><DIV CLASS=\"plugin\"><A CLASS=\"plugin\" HREF=\"$FILE?$OPT_EXPERT\">$TITLE_EXPERT</A></DIV></TD></TR>"
		else
			fkt_log "$DAEMON" "Expert-settings-menu entry already exists"
		fi	
		
		if [ ! -e "$ID_USER-$FILE" ]; then
			fkt_log "$DAEMON" "Inserting user-settings-menu entry"
			echo >$ID_USER-$FILE "<TR ID=\"idx-$ID\"><TD><DIV CLASS=\"plugin\"><A CLASS=\"plugin\" HREF=\"$FILE?$OPT_USER\">$TITLE_USER</A></DIV></TD></TR>"
		else
			fkt_log "$DAEMON" "User-settings-menu entry already exists"
		fi

	if [ "$MENU" = "full" ]; then
		fkt_log "$DAEMON" "Checking if full menu is up to date"
		
		local LIST="$(ls -1 ghosted_* 2>/dev/null)"
		for OBJ in $LIST; do
			local OBJ_NEW="$(echo $OBJ | sed "s/ghosted_//g")"
			fkt_log "$DAEMON" "Moving $DEST/$OBJ to $DEST/$OBJ_NEW"
			mv "$OBJ" "$OBJ_NEW"
		done
	fi
	
	[ -e "$ID_EXPERT-$FILE" ] && rm "$ID_EXPERT-$FILE"	# fixme!
}

fkt_check_readonly () {			# SENS: check if data-partition is mounted read-only (failsafe or firmware-update-mode)
					# OUT1: string (bool, false/true)
	local OUT=false
	local DAEMON="fkt_check_readonly"

	mount | while read line
		do set $line
		if [ "$5" = "mini_fo" ] && [ "$6" = "(ro)" ]; then
			fkt_log "$DAEMON" "Data-partition mounted read-only!"
			OUT=true
			break
		fi
	done
	
	echo $OUT
}

fkt_build_client_list () {			# SENS: print IP-list of (potential) clients
	local STARTIP="$1"			# ARG1: string, interface-IP (first useable address of network)
	local   ENDIP="$2"			# ARG2: string, interface-broadcast-address
	local     PRE="$3"			# ARG3: string, interface-netmask in CIDR-notation (e.g. /24)
	local     NET="$4"			# ARG4: string, interface info ("wan") - just for logging
	local  DAEMON="fkt_build_client_list"	# OUT1: list of IP-addresses

	fkt_log "$DAEMON" "writing client list for $STARTIP/$PRE (\"$NET\")" 1

	OKT1="$(echo $STARTIP | cut -d. -f1)"
	OKT2="$(echo $STARTIP | cut -d. -f2)"
	OKT3="$(echo $STARTIP | cut -d. -f3)"	  
	OKT4_START="$(echo $STARTIP | cut -d. -f4)"
	OKT4_END="$(  echo $ENDIP   | cut -d. -f4)"

	# we only need real clients, not the network, not the interface and not the broadcast-address
	let OKT4_START+=2
	   
	if [ "$PRE" -ge 24 ] && [ "$PRE" -le 30 ]; then		# this is not correct, just an workaround!
		
		[ "$PRE" = "30" ] && OKT4_START=$(( $OKT4_START - 1 ))

		while [ $OKT4_START -lt $OKT4_END ]; do {
			echo "$OKT1.$OKT2.$OKT3.$OKT4_START;"
			OKT4_START=$(( $OKT4_START + 1 ))
		} done
	else
		fkt_log "$DAEMON" "error, CIDR-netmask <24 or >30 not implemented yet!"
		
		sed -n "s/^${NET}ADR=\(.*\)/\1/p" /tmp/NETPARAM			# fixme! uiuiui!
		echo "# (printing at least the IP itself, maybe it helps)"
		echo "# error, CIDR-netmask = $PRE, which is <24 or >30 - not implemented yet!"
	fi
}

func_lookup_skype_servers ()
{
	local SERVER NUMBER
	
	for SERVER in dir http ; do {
		for NUMBER in 1 2 3 4 5 6 7 8 ; do {

			echo -n "${SERVER}${NUMBER}.sd.skype.net: "
			_net ip2dns "${SERVER}${NUMBER}.sd.skype.net"
		} done		
}

func_strange_l7_experiments_from_bastian ()		# fixme!
{
	local DEST="/tmp/l7fertig"
	local TEMP="/tmp/l7"
	local LINK NAME SIZE ATTR

	local L7URL="http://l7-filter.sourceforge.net"

	test -d $DEST || mkdir $DEST
	test -d $TEMP || mkdir $TEMP

	cd $DEST
	rm -fR *

	cd $TEMP
	rm -fR *

	LIST="$( wget -O - "$L7URL/protocols" | sed -n 's/^.*href=\"\(layer7-protocols\/.*\/.*\.pat\)\".*/\1/p' )"

	local SIZE_OLD="0"
	local SIZE_NEW="0"

	for LINK in $LIST; do {
		wget -q "$L7URL/$LINK"

		NAME="$( grep -v "^#" *.pat | grep -v "^$" | head -n1 )"
		SIZE="$( ls -l *.pat | while read RIGHTS UID GROUP USER LENGTH REST; do echo $LENGTH;done )"
		ATTR="$( sed -n 's/^# [pP]attern attributes: \(.*\)/\1/p' *.pat )"

		SIZE_OLD=$(( $SIZE_OLD + $SIZE ))

		echo "Working on protocol: \"$NAME\" ($SIZE bytes) - Attributes: \"$ATTR\""
	
		grep -v "^#" *.pat | grep -v "^$" >$DEST/$NAME.pat
	#	cat   *.pat >$DEST/$NAME.pat
	
		SIZE="$( ls -l $DEST/$NAME.pat | while read RIGHTS UID GROUP USER LENGTH REST; do echo $LENGTH;done )"
	
		SIZE_NEW=$(( $SIZE_NEW + $SIZE ))
	
		rm -f *.pat
	} done

	echo "original summarized size: $SIZE_OLD"
	echo "arranged summarized size: $SIZE_NEW (removed comments)"
}
