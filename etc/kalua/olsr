_olsr_daemon ()
{
	local ACTION="$1"
	local REASON="${2:-no_reason_given}"
	local LOGPRIO="alert"
	
	[ "$REASON" = "plausi_check_failed" ] && LOGPRIO=info		# already logging in plausi_check	// workaround
	
	case "$ACTION" in
		start|stop|restart)
			_log do "daemon" daemon $LOGPRIO "$ACTION: $REASON"
			/etc/init.d/S53olsrd $ACTION
		;;
	esac
}

_olsr_neigh_list_macs ()
{
	echo "fixme!"	# webconfig needs this!
}

_olsr_version ()
{
	local VERSION

	case "$( _file hash /usr/sbin/olsrd )" in
		0e2e2a7075ab294e1f784bf1191e099a) VERSION="pre-0.6.0_2010-04-10_ff1.6.38" ;;
		0f5db811586d06a2eddd84e7d83f14e4) VERSION="pre-0.5.6-r7_2009-10-27_ff1.6.37" ;;
		64a7b006218164827df8c43e4a5574d4) VERSION="pre-0.5.6-r4_2009-01-02_ff1.6.36" ;;
		033811480fbd2cf9801a10f0112c5987) VERSION="pre-0.5.7-tip 2008-12-28 ff1.x.x" ;;
		*)
			while read VERSION; do echo -n "$VERSION "; done </etc/olsrd-release
			VERSION="unknown build: $VERSION"
		;;
	esac	
	
	echo "$VERSION"
}

_olsr_uptime ()		# in seconds
{
	local KEYWORD="$1"		# string: "is_short" or <empty>
	local FUNC="olsr_uptime"
	local UNIXTIME_START="$( cat /tmp/olsr_restart_time 2>/dev/null )"
	local UNIXTIME_NOW="$( _system date unixtime )"				# fixme! work with uptime, which is also monotonic

	local DIFF="$(( $UNIXTIME_NOW - ${UNIXTIME_START:=0} ))"
	
	[ ${DIFF:=0} -gt 600000 ] && {	# 7 days
		_log do $FUNC daemon info "is pretty high: '$DIFF' seconds - time probs, rewrite to 0"
		echo $UNIXTIME_NOW >/tmp/olsr_restart_time
		DIFF=0
	}

	if [ "$KEYWORD" = "is_short" ]; then

		[ $DIFF -lt 300 ] && return 0
		return 1
	else	
		echo -n $DIFF
	fi
}

_olsr_gateways_get ()		# OUT: list with each HNA4-0.0.0.0/0-announcing IP line by line
{
	local FILE="$1"
	
	sed -e '/./{H;$!d;}' -e 'x;/Table: HNA/!d;' "$FILE" |
	 sed -e '/0.0.0.0/!d' -e '/\./!d' -e 's/[^0-9.]/ /g' |
	  cut -d" " -f3
}

_olsr_neigh_random_get ()
{
	local FUNC="olsr_neigh_random_get"
	local FILE="$1"

	local COST
	local COUNT=0
	local RANDOM
	
	_olsr neighs_evalable "$FILE"
	
	while read LINE; do {
		eval $LINE
	} done <"$FILE"

	[ -n "$REMOTE" ] && {
		RANDOM="$( _math random_integer 1 $COUNT )"

		eval $( sed -n "${RANDOM}p" "$FILE" )

		echo "$REMOTE"
		rm "$FILE"
		return 0
	}

	rm "$FILE"

	_log do $FUNC daemon debug "no neighbour, no random neighour"
	return 1
}

_olsr_neigh_random_pair_from_mesh_evalable ()
{
	local FILE="/tmp/olsr_plain"
	
	local LINES="$( sed -e '/./{H;$!d;}' -e "x;/^Table: Topology/!d;" $FILE | sed -n '$=' )"
	local RANDOM="$( _math random_integer 4 $LINES )"

	sed -e '/./{H;$!d;}' -e "x;/^Table: Topology/!d;" $FILE |
	 sed -n "${RANDOM}p" |
	  sed -n 's/^\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\).*/\LOCAL=\1\nREMOTE=\2\nLQ=\3\nNLQ=\4\nCOST=\5/p'
}

_olsr_node_evalable ()
{
	local NODE="$1"
	local FILE="/tmp/olsr_plain"
	
	sed -e '/./{H;$!d;}' -e "x;/^Table: Routes/!d;" $FILE |
	 grep ^"${NODE}/32" |
	  sed -n 's/^[0-9\.]*\/32[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9]*\)[^0-9]*\([0-9\.]*\).*/GATEWAY=\1\nMETRIC=\2\nCOST=\3/p'
}

_olsr_neigh_check_for_nonwifi ()
{
	local FUNC="olsr_check_if_any_nonwifi_neigh"
	local FILE="$1"
	
	_olsr neighs_evalable "$FILE"
	
	while read LINE; do {
		eval $LINE
		
		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ -n "$DEVTYPE" ] && {
			[ "$DEVTYPE" != "wifi" ] && {
				_log do $FUNC daemon debug "found nonwifi neigh: '$REMOTE'"
				return 0
			}
		}

	} done <"$FILE" && rm "$FILE"

	_log do $FUNC daemon debug "found only wifi neighbours"
	return 1
}

_olsr_neigh_check_for_wifi ()
{
	local FUNC="olsr_check_for_wifi_neigh"
	local FILE="$1"
	
	_olsr neighs_evalable "$FILE"
	
	while read LINE; do {
		eval $LINE
		
		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ "$DEVTYPE" = "wifi" ] && {
			_log do $FUNC daemon debug "found wifi neigh: '$REMOTE'"
			return 0
		}
	
	} done <"$FILE" && rm "$FILE"

	_log do $FUNC daemon debug "found only non-wifi neighbours"
	return 1
}

_olsr_neigh_nlq ()
{
	local FUNC="olsr_get_nlq"
	local FILE="$1"
	local THIS_NEIGH="$2"
	local KEYWORD="$3"	# speedtest, fixme!
	local NLQ
	
	_olsr neighs_evalable "$FILE"
	
	while read LINE; do {
		eval $LINE

		if [ "$REMOTE" = "$THIS_NEIGH" ]; then
			break
		else
			NLQ=
			LQ=
			COST=
		fi
	
	} done <"$FILE" && rm "$FILE"

	[ -z "$NLQ" ] && return 1
	
	_sanitizer include
	
	NLQ="$(  _sanitizer do "$NLQ"  numeric )"
	LQ="$(   _sanitizer do "$LQ"   numeric )"
	COST="$( _sanitizer do "$COST" numeric )"
	
	if [ -z "$KEYWORD" ]; then
		echo "${NLQ:-0}"
	else
		echo "NLQ=${NLQ:-0};LQ=${LQ:-0};COST=${COST:-0};"
	fi
}

_olsr_neigh_nlq_best_wifi ()
{
	local FUNC="olsr_best_wifi_nlq"
	local FILE="$1"
	local NLQ_MAX=

	_olsr neighs_evalable "$FILE"
	
	while read LINE; do {
		eval $LINE

		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ "$DEVTYPE" = "wifi" ] && {
			NLQ="$( echo ${NLQ:=0.000} | sed -ne 's/\.//' -e 's/^[0]*\([0-9]*\)/\1/p' )"		# 0.056 -> 56

			[ ${NLQ_MAX:=0} -lt ${NLQ:=0} ] && {
				NLQ_MAX="$NLQ"					# theoretical best value is 1.000 -> '1000'
				echo $REMOTE >/tmp/WIFI_OPTIMIZE_NEIGH		# for RRD-tool
			}
		}	
		
	} done <"$FILE" && rm "$FILE"

	[ -z "$NLQ_MAX" ] && return 1

	echo $NLQ_MAX
}

_olsr_neigh_check_for_good_non_tunnel ()
{
	local FUNC="olsr_check_for_good_non_tunnel_neigh"
	local FILE="$1"
	local BORDER="10"	# maximum suitable COST
	
	_olsr neighs_evalable "$FILE"
	
	while read LINE; do {
		eval $LINE
		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ -n "$DEVTYPE" ] && {
			[ "$DEVTYPE" != "tunnel" ] && {
				[ -n "$COST" ] && {
					[ ${COST%[\.]*} -lt 10 ] && {
						_log do $FUNC daemon debug "found suitable neigh: '$LINE'"
						return 0
					}
				}
			}
		}
	
	} done <"$FILE" && rm "$FILE"
	
	_log do $FUNC daemon debug "found nothing suitable"
	return 1 
}

_olsr_neighs ()
{
	local FUNC="olsr neighs"
	local TEMP="/tmp/olsr_output_$$.txt"
	local PLUGIN="olsrd_txtinfo"
	local CONF="/etc/olsrd.conf"
	local URL="http://127.0.0.1:2006/${1:-neighbours}"	# ARG1 can be 'full' and defaults to 'neighbours'
	
	grep -q "^LoadPlugin.*$PLUGIN\.so\." $CONF && {	
		
		wget -qO "$TEMP" "$URL" 2>/dev/null || {		# fixme! fetch routing-table also
									#        and use it for _net ip2metric()
			rm "$TEMP"

			[ "$( _system uptime min )" -lt 5 ] && {
				sleep 60				# lets settle down
			
				wget -qO "$TEMP" "$URL" 2>/dev/null && {
					echo -n "$TEMP"
					return 0
				}
			}
			
			rm "$TEMP"
			
			if pidof olsrd >/dev/null ; then
				_log do $FUNC daemon crit "failed to fetch neighbour-table, but OLSRd seems to run?!"
			else
				_log do $FUNC daemon crit "failed to fetch neighbour-table, because OLSRd is'nt running"
			fi
		
			return 1
		}
	
		echo -n "$TEMP"
		return 0
	}
	
	_log do $FUNC daemon info "OLSRd is not configured to load plugin '$PLUGIN'" 
	return 1
}

_olsr_check_plausi ()				# test 1/5: is each non-infinite neighbour in routing-table?
{						# test 2/5: each local/remote-pair has only one entry?
	local FUNC="olsr_plausi_check"		# test 3/5: are minimum-cost neighbours linklocal?
	local LINE				# test 4/5: each node in mesh has only 1 route?
	local LASTLINE				# test 5/5: are wired neighbours LQ/NLQ nearly synchronous?
	local FILE="$1"				# test 0/5: olsr-plaintext plugin works?

						# idea: '10.63.176.193 ~~0~~ 10.63.62.1     LQ/NLQ/COST: 0.000 / 0.000 / ~      MAC+DNS: ??:??:??:??:??:?? 'unknown'
						# idea:

	_olsr uptime is_short && {
		_log do $FUNC daemon info "no check - olsr_uptime seems pretty low"
		return 0
	}

	[ -z "$FILE" ] && {
		_log do $FUNC daemon crit "olsr-plaintext plugin has no output!"
		return 1
	}			# fixme! count lines of file?
	
	_log do $FUNC daemon debug "ok! (olsr-plaintext plugin outputs something)"

	[ -z "$( ip route list exact 0/0 )" ] && {
		_log do $FUNC daemon crit "no default route - olsr error?"	# we have seen AP-routers, which do not send out olsr-packets over lan
		return 1
	}

	local COUNT=0
	local LOCAL
	local REMOTE
	local LQ
	local NLQ
	local COST
	local METRIC
	local DEVTYPE
	local LINES1
	local LINES2
	
	_olsr neighs_evalable $FILE

	while read LINE; do {
		eval $LINE
		[ -n "$COST" ] && {
			[ "$COST" = "INFINITE" ] || {					# fixme! workaround for wrong neighs_evalable() abstraction
				[ -z "$( ip route list exact $REMOTE )" ] && {
					_log do $FUNC daemon crit "is each non-infinite neighbour in routing-table? '$REMOTE' (COST:'$COST') is not!"
					rm "$FILE"
					return 1
				}
			}
		}
	} done <"$FILE"

	_log do $FUNC daemon debug "ok! (is each non-infinite neighbour in routing-table?)"

	# are wired neighbours LQ/NLQ nearly synchronous?
	
	while read LINE; do {
		eval $LINE
		
		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		
		[ "$DEVTYPE" = "wire" ] && {
		
			LQ="$(  echo $LQ  | sed -ne 's/\.//' -e 's/^[0]*\([0-9]*\)/\1/p' )"
			NLQ="$( echo $NLQ | sed -ne 's/\.//' -e 's/^[0]*\([0-9]*\)/\1/p' )"
		
			case "${LQ:=0}-${NLQ:=0}" in
				"1000-"|"0000-"|"1000-0000"|"0000-1000")
					_log do $FUNC daemon crit "are wired neighbours LQ/NLQ nearly synchronous? no! REMOTE/LQ/NLQ = '$REMOTE'/'$LQ'/'$NLQ'"
					return 1
				;;
			esac
			
			[ $LQ -lt 100 ] && {			# fixme! check user-defined lqmult
				[ $NLQ -gt 900 ] && {
					sleep 10		# waiting for getting stable
	
					[ $NLQ -gt 900 -a $LQ -lt 100 ] && {
						_log do $FUNC daemon crit "are wired neighbours LQ/NLQ nearly synchronous? no! REMOTE/LQ/NLQ = '$REMOTE'/'$LQ'/'$NLQ'"
						return 1
					}
				}
			}
			
			[ $NLQ -lt 100 ] && {			# fixme! check user-defined lqmult
				[ $LQ -gt 900 ] && {
					sleep 10		# waiting for getting stable
	
					[ $LQ -gt 900 -a $NLQ -lt 100 ] && {
						_log do $FUNC daemon crit "are wired neighbours LQ/NLQ nearly synchronous? no! REMOTE/LQ/NLQ = '$REMOTE'/'$LQ'/'$NLQ'"
						return 1
					}
				}
			}
		}
	} done <"$FILE"
	
	_log do $FUNC daemon debug "ok! (are wired neighbours LQ/NLQ nearly synchronous?)"
	
	# each node in mesh has only 1 route?	// fixme! be more correct: is only an error,if in same routing table... (but we check "main")
						#  fixme! maybe give some time and double check?
						#  fixme! maybe it's not a big problem if only metric changes, but not gateway? (2 entrys with metric diff)

	local FILE_RT="/tmp/routing_table_main_$$"
	ip route show table main | sed -n 's/^\([0-9]\)\([0-9\/\.]*\).*/\1\2/p' | sort >$FILE_RT	# only "10.63.153.65/26"
	LINES1="$( cat $FILE_RT | wc -l )"
	LINES2="$( cat $FILE_RT | uniq | wc -l )"

	[ "$LINES1" != "$LINES2" ] && {	
		while read LINE; do {
	  		[ "$LINE" = "$LASTLINE" ] && {
				_log do $FUNC daemon crit "each node in mesh has only 1 route? no!: ($( ip route list exact $LINE ))"
				rm $FILE_RT
		  		return 1
	  		}
	  		LASTLINE="$LINE"
		
		} done <$FILE_RT
	}

	rm $FILE_RT
	_log do $FUNC daemon debug "ok! (each node in mesh has only 1 route? [checked $LINES1 routes])"

	while read LINE; do {
		eval $LINE
		[ "$COST" = "1.000" ] && {
			METRIC="$( ip route list $REMOTE | sed -n 's/^.*metric \([0-9]*\).*/\1/p' )"
		
			[ "$METRIC" != "1" ] && {
				_log do $FUNC daemon crit "are minimum-cost neighbours linklocal? '$REMOTE' is not!"
				rm "$FILE"
				return 1
			}
		}
	} done <"$FILE"

	[ -n "$METRIC" ] && _log do $FUNC daemon debug "ok! (are minimum-cost neighbours linklocal?)"

	LINES1="$( cat $FILE | wc -l )"
	LINES2="$( sed -n 's/^\(LOCAL=[0-9\.]*;REMOTE=[0-9\.]*\);.*/\1/p' $FILE | sort | uniq | wc -l )"

	[ "$LINES1" != "$LINES2" ] && {
		_log do $FUNC daemon crit "each local/remote-pair has only one entry? no!"
		
		while read LINE; do {
			_log do $FUNC daemon crit "$LINE"
		} done <$FILE
		
		rm "$FILE"
		return 1
	}

	_log do $FUNC daemon debug "ok! (each local/remote-pair has only one entry?)"

	rm "$FILE"
	return 0
}

_olsr_neighs_evalable ()	# ARG1 = plaintext-file		// COST can be 'INFINITE' and is truncated because of regexp [0-9] to ''
{
	local FILE="$1"		# LOCAL=10.63.3.33;REMOTE=10.63.26.161;LQ=1.000;NLQ=1.000;COST=1.000;COUNT=$(( $COUNT + 1 ))

	if _olsr version | fgrep -q 2009-10-27 ; then		# newstyle vs. old-style textinfo-plugin output

		sed -i -n 's/^\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)[^0-9]\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)/LOCAL=\1;REMOTE=\2;LQ=\3;NLQ=\4;COST=\5;COUNT=\$(( \$COUNT + 1 ))/p' "$FILE"
	else
		sed -i -n '/0\.00/s/^\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*0\.00[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)/LOCAL=\1;REMOTE=\2;LQ=\3;NLQ=\4;COST=\5;COUNT=\$\(\( \$COUNT \+ 1 \)\)/p' "$FILE"
	fi
}

_olsr_neighs_extended_evalable ()
{
	local FILE="$1"
	local VERBOSE="$2"

	local COUNT=0
	local LOCAL
	local REMOTE
	local LQ
	local NLQ
	local COST

	_olsr neighs_evalable $FILE	

	while read LINE; do {
		eval $LINE

		[ -n "$VERBOSE" ] && {
		
			METRIC="$( _net ip2metric $REMOTE )"
			DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		
			echo "LOCAL=$LOCAL;REMOTE=$REMOTE;LQ=$LQ;NLQ=$NLQ;COST=$COST;DEVTYPE=$DEVTYPE;METRIC=$METRIC"
			continue
		}
		
		echo "LOCAL=$LOCAL;REMOTE=$REMOTE;LQ=$LQ;NLQ=$NLQ;COST=$COST;COUNT=$COUNT"
				
	} done <"$FILE" && rm "$FILE"
}

_olsr_neighs_meshrdf_evalable ()
{
	local FILE="$1"
	local VERBOSE="$2"
	
	local COUNT=0
	local LOCAL
	local REMOTE
	local LQ
	local NLQ
	local COST

	local DEVTYPE
	local METRIC
	local METHOD="COST"	# linkcost / etx / batadv / ...

	_olsr neighs_evalable $FILE

	while read LINE; do {
		eval $LINE
		
		DEVTYPE="$(   _net devtype2symbol $( _net dev_type $( _net iplocal2dev $LOCAL ) ) )"
		METRIC="$(    _net ip2metric $REMOTE )"
		REMOTE_ID="$( _ipsystem do $REMOTE )"
				
		echo -n "${DEVTYPE}${REMOTE_ID}:${LOCAL}:${REMOTE}:${METHOD}:${LQ}:${NLQ}:${COST}:${METRIC}"

		# e.g. ~ 422 : 10.63.42.1 : 10.63.167.65 : COST : 2.123 : 1.234 : 1.678 : 1
		# fixme! add _speedtest_stats()	
		# 1+3+4+4+1+4+4+4+1 = 26 bytes / neigh
		
	} done <"$FILE" && rm "$FILE"
}

_olsr_neighs_humanreadable ()	# fixme! ToDo: latitude/longitude/distance + speed
{
	local FILE="$1"
	local GATEWAY_IP="$( ip route list exact 0/0 | sed -n 's/^.* via \([0-9\.]*\) .*/\1/p;q' )"	# fixme! more abstraction, works
													# only for mesh-gateways
	local DNS METRIC LIST LINE DEVTYPE SPACER1 SPACER2 SPACER4 MAX1 MAX2 LQMULTI
	local COUNT=0 LOCAL REMOTE LQ NLQ COST
	
	_olsr neighs_evalable $FILE
	
	LIST="$( sed -n 's/^LOCAL=\([0-9\.]*\).*/\1/p' "$FILE" )"		# all local IP's
	MAX1="$( _sanitizer do "$LIST" list_get_longest_string )"
	LIST="$( sed -n 's/^.*;REMOTE=\([0-9\.]*\).*/\1/p' "$FILE" )"		# all remote IP's
	MAX2="$( _sanitizer do "$LIST" list_get_longest_string )"

	[ $(echo $LIST | wc -w) -gt 9 ] && SPACER3=" "  	# numbering layout

	while read LINE; do {
	  	
	  	eval $LINE
	
		[ "$COST" = "INFINITE" ] && COST=
		
		DEVTYPE="$( _net devtype2symbol $( _net dev_type $(_net iplocal2dev $LOCAL ) ) )"
		DEVTYPE="${DEVTYPE}${DEVTYPE}"		# looks better
		
		MAC="$( ip neigh show to $REMOTE | sed -n "s/^.* lladdr \(..:..:..:..:..:..\) .*/\1/p;q" )"	# break after first match!
		SPACER1="$( _sanitizer do "$MAX1 $LOCAL"  add_length_diff_with_spaces )"			# ip's should always have
		SPACER2="$( _sanitizer do "$MAX2 $REMOTE" add_length_diff_with_spaces )"			# the same length
		DNS="$( _net ip2dns $REMOTE )"
		METRIC="$( _net ip2metric $REMOTE )"
		[ $COUNT -gt 9 ] && unset SPACER3					# 9 -> ' 9'; 10 = 10

		LQMULTI="$( sed -n "/LinkQualityMult[^0-9]*${REMOTE}/{s/^.*LinkQualityMult[^0-9]*${REMOTE}[^0-9]*\([0-9\.]*\).*/[LQ x\1]/p;q}" /etc/olsrd.conf )"
		
		SPACER4="  "
		[ "$REMOTE" = "$GATEWAY_IP" ] && SPACER4=">>"
		echo "${SPACER3}${COUNT}:${SPACER4}${LOCAL}${SPACER1} ${DEVTYPE}${METRIC:=0}${DEVTYPE} ${REMOTE}${SPACER2}  LQ/NLQ/COST: ${LQ} / ${NLQ} / ${COST:=~    }  MAC+DNS: ${MAC:=??:??:??:??:??:??} '${DNS:=unknown}' ${LQMULTI}"
	
	} done <"$FILE" && rm "$FILE"
	
	local OLSR_INGORE="$( nvram get ff_ign )"
	
	[ -n "$OLSR_INGORE" ] && echo "ignored stations: $OLSR_INGORE"
}
