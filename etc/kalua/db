_db_purge ()
{
	local FUNC="db_purge"
	local OBJ

	for OBJ in "/tmp/DB" "/www/cgi-bin/db_backup.tgz"; do {
		_log do $FUNC daemon info "[OK] removing '$OBJ'"
		rm -fR "$OBJ"
	} done
}

_db_backup ()		# fixme! automatically call this after <prio> changes
{
	local FUNC="db_backup"
	local FILE="/www/cgi-bin/db_backup.tgz"

	if tar czf "$FILE" /tmp/DB ; then
		_log do $FUNC daemon info "[OK] wrote $( _file size "$FILE" ) bytes to $FILE"
	else
		_log do $FUNC daemon alert "[ERR] while working on $FILE"
	fi
}

_db_restore ()		# is called during boot: see /etc/init.d/S70prepare_fff+
{
	local FUNC="db_restore"
	local FILE="/www/cgi-bin/db_backup.tgz"

	if [ -e "$FILE" ]; then
	
		_log do $FUNC daemon info "removing dir /tmp/DB, unarc of '$FILE'"
		rm -fR /tmp/DB

		if tar -C / -xzf "$FILE" ; then
			_log do $FUNC daemon info "[ok]"
		else
			_lgo do $FUNC daemon alert "[err]"
		fi
	else
		_log do $FUNC daemon info "[err] '$FILE' not found"
	fi
}

_db_user ()			# poormens_db: each line has: ID=<integer>;A="";B="";C="";D="";...;   	# autocreated is ID = linenumber = index
{
	local FUNC="db_user"

	local TABLE="$1"
	local ACTION="$2"
	local ID="$3"		# is set to 'autoid' when action is 'add'
	local OPTION="$4"

	local FIXME="$5$6$7$8$9${10}${11}${12}${13}${14}"
	local OBJ ELEMENTS REWRITE_VARS SHORT_VAR N LIST VALUE FILL

	case "$TABLE" in
		profile) ELEMENTS="NAME COMMENT AUTOGENERATE TIME_MODEL MAX_TIME MAX_TRAFFIC MAX_SPEED_UP MAX_SPEED_DOWN LANDING_URL COST CURRENCY" ;;
		login)   ELEMENTS="PROFILE_ID COMMENT USERNAME PASSWORD DEVICE_QUANTITY INSTALLED" ;;
		device)  ELEMENTS="USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION" ;;
		*)
			echo "Usage: _$FUNC <table> <action>"
			echo "       _$FUNC profile|login|device show [<id>|last|\"elementA elementB ... elementN\"]"
			echo "       _$FUNC profile|login|device list [last <num>|reverse] | add autoid ... | del <id>|update <id> ..."
			echo "       _$FUNC profile|login|device query hash2id <hash> | string2id <string>"
			return 1
		;;
	esac

	local DIR="/tmp/DB/USER/$TABLE"
	mkdir -p "$DIR"

	case "$ACTION" in
		query)
			case "$ID" in
				hash2id)
					[ -e "$DIR/meta_index" ] || return 1
					local HASH="$OPTION"
					sed -n "/$HASH/{=;q}" "$DIR/meta_index"
				;;
				string2id)
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"
					sed -n "/$STRING/{=;q}" "$DIR/rows"
				;;
			esac
		;;
		index_gen)
			local INDEX="$DIR/meta_index"
			local LOGIN_ID

			_stopwatch start $ACTION
			for LOGIN_ID in $( _db user login list $ID $OPTION ); do {		# fixme! can be: "last" + "32"
				eval $( _db user login show $LOGIN_ID "USERNAME PASSWORD" )
				echo -n "$USERNAME$PASSWORD" | md5sum | cut -d' ' -f1		# hash
			} done >$INDEX
			_stopwatch stop $ACTION

			_log do $FUNC daemon info "$ACTION: wrote '$INDEX'"
			_db backup
		;;
		list)
			[ -e "$DIR/rows" ] || return 1
		
			case "$ID" in
				last)
					sed -n '/A=/=' "$DIR/rows" | tail -n ${OPTION:-1}
				;;
				reverse)
					sed -n '/A=/=' "$DIR/rows" | sed '1!G;h;$!d'
				;;
				*)
					sed -n '/A=/=' "$DIR/rows"
				;;
			esac
		;;
		show)						# fixme! idea: always write userwish/$OPTION in output, e.g. USERNAME=;PASSWORD=;
			[ -e "$DIR/rows" ] || return 1

			[ "$ID" = "last" ] && {
				ID="$( sed -n '$=' "$DIR/rows" )"
			}

			table_element_is_part_of_user_wish_or_wanted ()
			{
				case "$OPTION" in
					      "") return 0 ;;
					*"$OBJ"*) return 0 ;;
					       *) return 1 ;;
				esac
			}

			for OBJ in $ELEMENTS; do {

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*)
						SHORT_VAR="A"
						
						table_element_is_part_of_user_wish_or_wanted && {
							OBJ="ID=${ID};${OBJ}"
							REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
						}

						FILL=";"
						continue
					;;
				esac

				table_element_is_part_of_user_wish_or_wanted && {
					REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
				}

				FILL=";"				
			} done

			sed -n "${ID}{${REWRITE_VARS}p;q}" "$DIR/rows"		# fixme! return ERROR on nonexisting line
		;;
		del)
			sed -i "${ID}s/^.*/#/" "$DIR/rows"
		;;
		add|update)				# fixme! if "add" is used, ID=<integer> is not in line?
			case "$ACTION" in
				add) 	N=3 ;;		# args are without ID (is autogenerated)
				update) N=4 ;;
			esac
			
			SHORT_VAR=
			for OBJ in $ELEMENTS; do {
				eval "VALUE=\"\${$N}\""

				case "${VALUE}${TABLE}_${OBJ}" in				# fixme! this a hack? (this ask's for an empty "$VALUE"!)
					login_USERNAME)  VALUE="$( _random_username do )" ;;
					login_PASSWORD)  VALUE="$( _math random_integer 1 99999 fillup )" ;;
					login_INSTALLED) VALUE="$( _system date unixtime )" ;;
				esac

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*) SHORT_VAR="A" ;;
				esac
				
				LIST="${LIST}$SHORT_VAR='$VALUE';"
				N=$(( $N + 1 ))
			} done

			case "$ACTION" in
				add)
					echo "$LIST" >>"$DIR/rows"
				;;
				update)
					local TAB="	"		# sed-field-separator
					sed -i "${ID}s${TAB}^.*${TAB}ID=$ID;$LIST${TAB}" "$DIR/rows"
				;;
			esac
		;;
	esac
}

_db_ticketcheck ()								# going through list of profiles (user defined or all)
{										#
	local FUNC="db_ticketcheck"						# going reverse through list of last new devices
	local PROFILE_ID_WISH="${1:-$( _db user profile list )}"		# which profile has the login, which have used this device?
	local DEVICE_ID_LIST_REVERSE="${2:-$( _db user device list reverse )}"	# if profile = wished, than check:
	local DEVICE_ID_LIST="$( _db user device list )"			#
										# go through list of all login's, after the used one
	local ALIEN_PROFILE_ID ALIEN_ID USER_ID_LAST ID ID2 USER_ID_STACK	# count, which have whished profile X and are unused
	local AUTOGENERATE_BORDER=15
	local UNUSED_TICKETS FOUND_DEVICE

	profiles_are_matching_and_login_is_unused ()		# needs global ID_CHECK + ALIEN_PROFILE_ID + DEVICE_ID_LIST
	{
		eval $( _db user login show $ID_CHECK "PROFILE_ID" )

		if [ "$PROFILE_ID" = "$ALIEN_PROFILE_ID" ]; then

			for ID2 in $DEVICE_ID_LIST; do {
				eval $( _db user device show $ID2 "USER_ID" )
				[ "$ID_CHECK" = "$USER_ID" ] && {
					return 1
				}
			} done
			return 0
		else
			return 1
		fi
	}

	_stopwatch start $FUNC

	for ALIEN_PROFILE_ID in $PROFILE_ID_WISH; do {

		eval "$( _db user profile show $ALIEN_PROFILE_ID "AUTOGENERATE NAME" )"

		if [ "$AUTOGENERATE" = "1" ]; then
			_log do $FUNC daemon debug "checking for unused tickets with profile $ALIEN_PROFILE_ID ($NAME)"
		else
			_log do $FUNC daemon debug "ignoring profile $ALIEN_PROFILE_ID ($NAME) - autogenerate is off"
			continue
		fi

		FOUND_DEVICE=
		for ALIEN_ID in $DEVICE_ID_LIST_REVERSE; do {

			eval "$( _db user device show $ALIEN_ID "USER_ID"  )"
			eval "$( _db user login show $USER_ID "PROFILE_ID" )"

			[ "$PROFILE_ID" = "$ALIEN_PROFILE_ID" ] && {		# matches user/loop_wish?

				FOUND_DEVICE=1
				UNUSED_TICKETS=0
				LOGIN_LAST="$( _db user login list last )"
				DIFF="$(( $LOGIN_LAST - $USER_ID ))"

				for ID_CHECK in $( _db user login list last $DIFF ); do {
					profiles_are_matching_and_login_is_unused && {
						UNUSED_TICKETS=$(( $UNUSED_TICKETS + 1 ))
					}
				} done

				if [ $UNUSED_TICKETS -lt $AUTOGENERATE_BORDER ]; then
					_log do $FUNC daemon alert "[ERR] only $UNUSED_TICKETS unused tickets/logins for profile $ALIEN_PROFILE_ID ($NAME) in database (after login $(( $LOGIN_LAST - $DIFF )))"
					_db autocreate_tickets_and_send_mail "$ALIEN_PROFILE_ID"
				else
					_log do $FUNC daemon info "[OK] $UNUSED_TICKETS (enough) unused tickets/logins for profile $ALIEN_PROFILE_ID ($NAME) in database (after login $(( $LOGIN_LAST - $DIFF )))"
				fi

				break
			}
		} done

		[ -z "$FOUND_DEVICE" ] && _log do $FUNC daemon info "[ERR] did not found any device, which uses profile $ALIEN_PROFILE_ID ($NAME)"	
	} done

	_stopwatch stop $FUNC quiet
}

_db_autocreate_tickets_and_send_mail ()
{
	local PROFILE_ID="$1"				# or list if login-ID's
	local USECASE="${2:-autogenerate_tickets}"	# <autogenerate_tickets|existing_tickets>

	local FUNC="db_autocreate_tickets_and_send_mail"
	local TICKET_QUANTITY=32
	local COUNTER="$TICKET_QUANTITY"
	local NAME LOGIN LIST_ID

	case "$USECASE" in
		existing_tickets)
	
			LIST_ID="$PROFILE_ID"
			for LOGIN in $LIST_ID; do {
				eval $( _db user login show $LOGIN "PROFILE_ID" )
				eval $( _db user profile show $PROFILE_ID "NAME" )
				break
			} done
		;;
		autogenerate_tickets)
	
			eval $( _db user profile show $PROFILE_ID "NAME" )

			_stopwatch start Generating_${TICKET_QUANTITY}_Tickets
		
			while [ $COUNTER -ne 0 ]; do {
				COUNTER="$(( $COUNTER - 1 ))"
				_db user login add "$PROFILE_ID" "" "" "" "1" "$UNIXTIME"
			} done

			_stopwatch stop Generating_${TICKET_QUANTITY}_Tickets quiet

			_db user login index_gen

			LIST_ID="$( _db user login list last $TICKET_QUANTITY )"	
		;;
	esac

	local PRE="/tmp/tickets_autocreated_$$"
	local FILE_MAIL="$PRE.mail.txt"

	local LOCATION_NAME="$( _weblogin metadata_locationname )"
	local FROM_REAL="WLAN-System $LOCATION_NAME $( uci get mail.@smtp[0].name )"
	local FROM_MAIL="$( uci get mail.@smtp[0].mail )"
	local RECIPIENT_REAL="Administration $LOCATION_NAME"
	local RECIPIENT_MAIL="bittorf@bluebottle.com"

	local FILE_OVERVIEW="/tmp/$( _pdf filename overview "$TICKET_QUANTITY" "$NAME" )"
	local FILE_LABELS="/tmp/$(   _pdf filename labels   "$TICKET_QUANTITY" "$NAME" )"
	local FILE_CSV="$PRE.csv"
	local FILE ID
	local UNIXTIME="$( _system date unixtime )"

	_pdf output_a4digest "$LIST_ID" >$FILE_OVERVIEW
	_pdf output_a4marker "$LIST_ID" >$FILE_LABELS

	_weblogin ticket_mail_text "$NAME" >$FILE_MAIL
	echo "WLAN-Tickets (Anzahl: $TICKET_QUANTITY) in einer Uebersicht"	>$FILE_OVERVIEW.desc
	echo "WLAN-Tickets (Anzahl: $TICKET_QUANTITY) fuer Standard-Etiketten"	>$FILE_LABELS.desc

	_mail send "$FROM_REAL" "$FROM_MAIL" "$RECIPIENT_REAL" "$RECIPIENT_MAIL" "$FILE_MAIL" "" "" "" "$FILE_OVERVIEW $FILE_LABELS" || {
		_log do $FUNC daemon alert "[ERR] we have to resend the mail"	
	}

	for FILE in $FILE_MAIL $FILE_OVERVIEW $FILE_OVERVIEW.desc $FILE_LABELS $FILE_LABELS.desc $FILE_CSV; do {
		[ -e "$FILE" ] && rm "$FILE"
	} done
}
