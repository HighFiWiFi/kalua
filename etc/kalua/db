_db_migrate ()
{
	local FUNC="db_migrate"
	local FILE="/www/cgi-bin/userdata.txt"
	local FILE_LOGIN="/www/users_logged_in"
	local FILE_LOGIN_TEMP="/tmp/users_logged_in.temp"
	local TEMP="/tmp/$FUNC.temp"
	local UNIXTIME="$( _system date unixtime )"
	local QUANTITY=1
	local HASH NO PROFILE_ID COMMENT USERNAME PASSWORD
	local ID USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION
	local LINE ENTRIES
	local NO=0

	_db purge

	_stopwatch start $FUNC

	cp $FILE_LOGIN $FILE_LOGIN_TEMP

	while read LINE; do {

		set $LINE		# 54f2ce58c6c011379be0d343607d7584 42 3 manila 15981

		HASH="$1"
		NO="$2"
		PROFILE_ID="$3"
		USERNAME="$4"
		PASSWORD="$5"		
		COMMENT=

		LINE="$( fgrep $HASH $FILE_LOGIN_TEMP | head -n1 )"
		if [ -n "$LINE" ]; then
			LINE="$( echo $LINE | cut -d'-' -f1 | cut -b2-99 )"
			LINE="$( _system date 2unixtime "$LINE" )"
			TIME="$(( $LINE - 600 ))"			# 10 minutes before first login
		else
			TIME="$UNIXTIME"
		fi

		case $PROFILE_ID in
#			99) PROFILE_ID="2" ;;		# henschel
#		     30min) PROFILE_ID="1" ;;
#		  60min|1h) PROFILE_ID="2" ;;
#			2h) PROFILE_ID="3" ;;
#		       24h) PROFILE_ID="1" ;;
#		       48h) PROFILE_ID="5" ;;
#		       72h) PROFILE_ID="6" ;;
#		       24h) PROFILE_ID="1" ;;
#		     1week) PROFILE_ID="2" ;;
#		    1month) PROFILE_ID="3" ;;

			 *) PROFILE_ID="1" ;;
		esac

		logger -s "login add $PROFILE_ID $COMMENT $USERNAME $PASSWORD $QUANTITY $TIME"
		_db user login add "$PROFILE_ID" "$COMMENT" "$USERNAME" "$PASSWORD" "$QUANTITY" "$TIME"

		# 'Tue Nov 30 10:49:18 CET 2010' - IP:'192.168.1.1' - DNS:'hotel' = HASH:'a812a8fc4e3bbb99e28cc916396fc460' - MAC:'00:26:c7:31:dc:bb' - SIGNAL:'-87' - KEYWORD:'' | ok | a812a8fc4e3bbb99e28cc916396fc460 65 3 taugenichts password
		fgrep "$HASH" $FILE_LOGIN_TEMP >$TEMP

		while read LINE; do {

			USER_ID="$( _db user login list last )"		# fixme! should be named LOGIN_ID
			MAC="$( _sanitizer do "$LINE" mac )"
			DEVTYPE="0"					# 0 = wifi | 1 = lan?
			LANG="de"

			[ -z "$MAC" ] && continue

			FIRSTSEEN="$( fgrep $MAC $TEMP | head -n1 | cut -d'-' -f1 | cut -b2-99 )"
			LASTSEEN="$(  fgrep $MAC $TEMP | tail -n1 | cut -d'-' -f1 | cut -b2-99 )"

			FIRSTSEEN="$( _system date 2unixtime "$FIRSTSEEN" )"
			LASTSEEN="$(  _system date 2unixtime "$LASTSEEN" )"

			USED_TRAFFIC=0
			USED_TIME=0
			USED_TRAFFIC_TODAY=0
			USED_TIME_TODAY=0
			ISOLATION=0

			[ -n "$( _db user device query string2id "$MAC" )" ] && continue	# fixme! check for same mac with different account/logindata?

			logger -s "device add $USER_ID $MAC $DEVTYPE $LANG $FIRSTSEEN $LASTSEEN $USED_TRAFFIC $USED_TIME $USED_TRAFFIC_TODAY $USED_TIME_TODAY $ISOLATION"
			_db user device add "$USER_ID" "$MAC" "$DEVTYPE" "$LANG" "$FIRSTSEEN" "$LASTSEEN" "$USED_TRAFFIC" "$USED_TIME" "$USED_TRAFFIC_TODAY" "$USED_TIME_TODAY" "$ISOLATION"

		} done <$TEMP
		rm $TEMP

	} done <$FILE
	rm $FILE_LOGIN_TEMP

	_stopwatch stop $FUNC

	_db user login index_gen
}

_db_purge ()
{
	local FUNC="db_purge"
	local OBJ

	for OBJ in "/tmp/DB" "/www/cgi-bin/db_backup.tgz"; do {
		_log do $FUNC daemon info "[OK] removing '$OBJ'"
		rm -fR "$OBJ"
	} done
}

_db_backup ()		# fixme! automatically call this after <prio> changes
{
	local FUNC="db_backup"
	local FILE="/www/cgi-bin/db_backup.tgz"

	if tar czf "$FILE" /tmp/DB ; then
		_log do $FUNC daemon info "[OK] wrote $( _file size "$FILE" ) bytes to $FILE"
	else
		_log do $FUNC daemon alert "[ERR] while working on $FILE"
	fi
}

_db_restore ()		# is called during boot: see /etc/init.d/S70prepare_fff+
{
	local FUNC="db_restore"
	local FILE="/www/cgi-bin/db_backup.tgz"

	if [ -e "$FILE" ]; then
	
		_log do $FUNC daemon info "removing dir /tmp/DB, unarc of '$FILE'"
		rm -fR /tmp/DB

		if tar -C / -xzf "$FILE" ; then
			_log do $FUNC daemon info "[ok]"
		else
			_lgo do $FUNC daemon alert "[err]"
		fi
	else
		_log do $FUNC daemon info "[err] '$FILE' not found"
	fi
}

_db_user ()			# poormens_db: each line has: ID=<integer>;A="";B="";C="";D="";...;   	# autocreated is ID = linenumber = index
{
	local FUNC="db_user"

	local TABLE="$1"
	local ACTION="$2"
	local ID="$3"		# is set to 'autoid' when action is 'add'
	local OPTION="$4"

	local FIXME="$5$6$7$8$9${10}${11}${12}${13}${14}"
	local OBJ ELEMENTS REWRITE_VARS SHORT_VAR N LIST VALUE FILL

	case "$TABLE" in
		profile) ELEMENTS="NAME COMMENT AUTOGENERATE TIME_MODEL MAX_TIME MAX_TRAFFIC MAX_SPEED_UP MAX_SPEED_DOWN LANDING_URL COST CURRENCY" ;;
		login)   ELEMENTS="PROFILE_ID COMMENT USERNAME PASSWORD DEVICE_QUANTITY INSTALLED" ;;
		device)  ELEMENTS="USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION" ;;
		*)
			echo "Usage: _$FUNC <table> <action>"
			echo "       _$FUNC profile|login|device list [last <num>|reverse] | show [last|<id>] | add autoid ...|del <id>|update <id> ..."
			echo "       _$FUNC profile|login|device query hash2id | string2id <string>"
			return 1
		;;
	esac

#	_log do $FUNC daemon info "table: $TABLE action: $ACTION elements: 3:$3 4:$4 5:$5 6:$6 7:$7 8:$8 9:$9 0:${10} 1:${11} 2:${12} 3:${13} 4:${14}"

	local DIR="/tmp/DB/USER/$TABLE"
	mkdir -p "$DIR"

	case "$ACTION" in
		query)
			case "$ID" in
				hash2id)
					[ -e "$DIR/meta_index" ] || return 1
					local HASH="$OPTION"
					sed -n "/$HASH/{=;q}" "$DIR/meta_index"
				;;
				string2id)
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"
					sed -n "/$STRING/{=;q}" "$DIR/rows"
				;;
			esac				
		;;
		index_gen)
			local INDEX="$DIR/meta_index"
			local LOGIN_ID

			_stopwatch start $ACTION
			for LOGIN_ID in $( _db user login list $3 $4 ); do {				# fixme! can be: "last" + "32"
				eval $( _db user login show $LOGIN_ID "USERNAME PASSWORD" )
				echo -n "$USERNAME$PASSWORD" | md5sum | cut -d' ' -f1		# hash
			} done >$INDEX
			_stopwatch stop $ACTION

			_log do $FUNC daemon info "$ACTION: wrote '$INDEX'"
			_db backup
		;;
		list)
			[ -e "$DIR/rows" ] || return 1
		
			case "$ID" in
				last)
					sed -n '/A=/=' "$DIR/rows" | tail -n ${OPTION:-1}
				;;
				reverse)
					sed -n '/A=/=' "$DIR/rows" | sed '1!G;h;$!d'
				;;
				*)
					sed -n '/A=/=' "$DIR/rows"
				;;
			esac
		;;
		show)
			# [ -n "$4" ] && ELEMENTS="$4"		# fixme! e.g. only output "NAME COMMENT" does not work
			[ -e "$DIR/rows" ] || return 1

			[ "$ID" = "last" ] && {
				ID="$( sed -n '$=' "$DIR/rows" )"
			}
		
			for OBJ in $ELEMENTS; do {

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*) SHORT_VAR="A"; OBJ="ID=${ID};${OBJ}" ;;
				esac

				REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
				FILL=";"
			} done

			sed -n "${ID}{${REWRITE_VARS}p;q}" "$DIR/rows"		# fixme! return ERROR on nonexisting line
		;;
		del)
			sed -i "${ID}s/^.*/#/" "$DIR/rows"
		;;
		add|update)				# fixme! if add is used, ID=<integer> is not in line?
			case "$ACTION" in
				add) 	N=3 ;;		# args are without ID (is autogenerated)
				update) N=4 ;;
			esac
			
			SHORT_VAR=
			for OBJ in $ELEMENTS; do {
				eval "VALUE=\"\${$N}\""

				case "${VALUE}${TABLE}_${OBJ}" in				# fixme! this a hack? (empty "$VALUE"!)
					login_USERNAME)  VALUE="$( _random_username do )" ;;
					login_PASSWORD)  VALUE="$( _math random_integer 1 99999 fillup )" ;;
					login_INSTALLED) VALUE="$( _system date unixtime )" ;;
				esac

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*) SHORT_VAR="A" ;;
				esac
				
				LIST="${LIST}$SHORT_VAR='$VALUE';"
				N=$(( $N + 1 ))
			} done

			case "$ACTION" in
				add)
					echo "$LIST" >>"$DIR/rows"
				;;
				update)
					sed -i "${ID}s#^.*#ID=$ID;$LIST#" "$DIR/rows"
				;;
			esac
		;;
		id2name)
			sed -n "${ID}s/.*;A='\(.*\)';B=.*/\1/p" "$DIR/rows"	# fixme! hardcoded NAME position (is needed for PROFILE only)
		;;
		name2id)
			sed -n "/;A='${ID}';/=" "$DIR/rows"			# fixme! hardcoded position (dito)
		;;
		*)
			echo "Usage: ..."
		;;
	esac
}

_db_ticketcheck ()
{
	return		# fixme!

	local FUNC="db_ticketcheck"
	local PROFILE_ID_WISH="${1:-$( _db user profile list )}"
	local DEVICE_ID_LIST="${2:-$( _db user device list reverse )}"

	local ALIEN_PROFILE_ID ALIEN_ID USER_ID_LAST I ID ID2 USER_ID_STACK

	# going through list of profiles (user defined or all)
	# going reverse through list of last new devices
	# which profile they have used? if profile = wished, than check:
	# go through list of all login's, after the used one
	# count, which have whished profile and are unused

	_stopwatch start $FUNC

	profiles_are_matching_and_login_is_unused ()
	{
		eval $( _db user login show $ID )

		if [ "$PROFILE_ID" = "$ALIEN_PROFILE_ID" ]; then
echo "profile match: $PROFILE_ID"
			for ID2 in $( _db user device list ); do {
echo "checking device $ID2"
				eval $( _db user device show $ID2 )	# USER_ID
				[ "$ID" = "$USER_ID" ] || {
echo "used! user_id: $ID"
echo
					return 1
				}
			} done
echo "OK - not used"
		else
			return 1
		fi

	}

	for ALIEN_PROFILE_ID in $PROFILE_ID_WISH; do {
echo "checking profile $ALIEN_PROFILE_ID / all: $PROFILE_ID_WISH"
		_log do $FUNC daemon debug "checking for unused tickets with profile $ALIEN_PROFILE_ID"

		for ALIEN_ID in $DEVICE_ID_LIST; do {
echo "checking device $ALIEN_ID, profile-loop $ALIEN_PROFILE_ID"
			eval "$( _db user device show $ALIEN_ID )"
			eval "$( _db user login show $USER_ID )"
			USER_ID_STACK="$USER_ID"
			eval "$( _db user profile show $ALIEN_PROFILE_ID )"

			[ "$PROFILE_ID" = "$ALIEN_PROFILE_ID" ] && {		# matches user_wish
echo "found device $ALIEN_ID with profile $PROFILE_ID"
				I=0
				LOGIN_LAST="$( _db user login list last )"
				DIFF="$(( $LAST - $USER_ID ))"
echo "for ID in ...login last $DIFF"
				for ID in $( _db user login list last $DIFF ); do {
echo "looping logins, ID: $ID"
					profiles_are_matching_and_login_is_unused && {
						I=$(( $I + 1 ))
					}
				} done

				_log do $FUNC daemon info "only $I unused tickets/logins for profile $ALIEN_PROFILE_ID ($NAME) in database (after login $USER_ID_STACK)"
				echo $I
				break
			}
		} done
	} done

	_stopwatch stop $FUNC
}
