_db_purge ()
{
	local FUNC="db_purge"
	local OBJ

	for OBJ in "/tmp/DB" "/www/cgi-bin/db_backup.tgz"; do {
		_log do $FUNC daemon info "[OK] removing '$OBJ'"
		rm -fR "$OBJ"
	} done
}

_db_backup ()		# fixme! automatically call this after <prio> changes
{
	local FUNC="db_backup"
	local FILE="/www/cgi-bin/db_backup.tgz"

	if tar czf "$FILE" /tmp/DB ; then
		_log do $FUNC daemon info "[OK] wrote $( _file size "$FILE" ) bytes to $FILE"
	else
		_log do $FUNC daemon alert "[ERR] while working on $FILE"
	fi
}

_db_restore ()		# is called during boot: see /etc/init.d/S70prepare_fff+
{
	local FUNC="db_restore"
	local FILE="/www/cgi-bin/db_backup.tgz"

	if [ -e "$FILE" ]; then
	
		_log do $FUNC daemon info "removing dir /tmp/DB, unarc of '$FILE'"
		rm -fR /tmp/DB

		if tar -C / -xzf "$FILE" ; then
			_log do $FUNC daemon info "[ok]"
		else
			_lgo do $FUNC daemon alert "[err]"
		fi
	else
		_log do $FUNC daemon info "[err] '$FILE' not found"
	fi
}

_db_user ()			# poormens_db: each line has: ID=<integer>;A="";B="";C="";D="";...;   	# autocreated is ID = linenumber = index
{
	local FUNC="db_user"

	local TABLE="$1"
	local ACTION="$2"
	local ID="$3"		# is set to 'autoid' when action is 'add'
	local OPTION="$4"

	local FIXME="$5$6$7$8$9${10}${11}${12}${13}${14}"
	local OBJ ELEMENTS REWRITE_VARS SHORT_VAR N LIST VALUE FILL

	case "$TABLE" in
		profile) ELEMENTS="NAME COMMENT AUTOGENERATE TIME_MODEL MAX_TIME MAX_TRAFFIC MAX_SPEED_UP MAX_SPEED_DOWN LANDING_URL COST CURRENCY" ;;
		login)   ELEMENTS="PROFILE_ID COMMENT USERNAME PASSWORD DEVICE_QUANTITY INSTALLED" ;;
		device)  ELEMENTS="USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION" ;;
		*)
			echo "Usage: _$FUNC <table> <action>"
			echo "       _$FUNC profile|login|device show [<id>|last|\"elementA elementB ... elementN\"]"
			echo "       _$FUNC profile|login|device list [last <num>|reverse] | add autoid ... | del <id>|update <id> ..."
			echo "       _$FUNC profile|login|device query hash2id <hash> | string2id <string>"
			return 1
		;;
	esac

	local DIR="/tmp/DB/USER/$TABLE"
	mkdir -p "$DIR"

	case "$ACTION" in
		query)
			case "$ID" in
				hash2id)
					[ -e "$DIR/meta_index" ] || return 1
					local HASH="$OPTION"
					sed -n "/$HASH/{=;q}" "$DIR/meta_index"
				;;
				string2id)
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"
					sed -n "/$STRING/{=;q}" "$DIR/rows"
				;;
			esac
		;;
		index_gen)
			local INDEX="$DIR/meta_index"
			local LOGIN_ID

			_stopwatch start $ACTION
			for LOGIN_ID in $( _db user login list $ID $OPTION ); do {				# fixme! can be: "last" + "32"
				eval $( _db user login show $LOGIN_ID "USERNAME PASSWORD" )
				echo -n "$USERNAME$PASSWORD" | md5sum | cut -d' ' -f1		# hash
			} done >$INDEX
			_stopwatch stop $ACTION

			_log do $FUNC daemon info "$ACTION: wrote '$INDEX'"
			_db backup
		;;
		list)
			[ -e "$DIR/rows" ] || return 1
		
			case "$ID" in
				last)
					sed -n '/A=/=' "$DIR/rows" | tail -n ${OPTION:-1}
				;;
				reverse)
					sed -n '/A=/=' "$DIR/rows" | sed '1!G;h;$!d'
				;;
				*)
					sed -n '/A=/=' "$DIR/rows"
				;;
			esac
		;;
		show)
			[ -e "$DIR/rows" ] || return 1

			[ "$ID" = "last" ] && {
				ID="$( sed -n '$=' "$DIR/rows" )"
			}

			table_element_is_part_of_user_wish_or_wanted ()
			{
				case "$OPTION" in
					      "") return 0 ;;
					*"$OBJ"*) return 0 ;;
					       *) return 1 ;;
				esac
			}

			for OBJ in $ELEMENTS; do {

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*)
						SHORT_VAR="A"
						
						table_element_is_part_of_user_wish_or_wanted && {
							OBJ="ID=${ID};${OBJ}"
							REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
						}

						FILL=";"
						continue
					;;
				esac

				table_element_is_part_of_user_wish_or_wanted && {
					REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
				}

				FILL=";"				
			} done

			sed -n "${ID}{${REWRITE_VARS}p;q}" "$DIR/rows"		# fixme! return ERROR on nonexisting line
		;;
		del)
			sed -i "${ID}s/^.*/#/" "$DIR/rows"
		;;
		add|update)				# fixme! if "add" is used, ID=<integer> is not in line?
			case "$ACTION" in
				add) 	N=3 ;;		# args are without ID (is autogenerated)
				update) N=4 ;;
			esac
			
			SHORT_VAR=
			for OBJ in $ELEMENTS; do {
				eval "VALUE=\"\${$N}\""

				case "${VALUE}${TABLE}_${OBJ}" in				# fixme! this a hack? (this ask's for an empty "$VALUE"!)
					login_USERNAME)  VALUE="$( _random_username do )" ;;
					login_PASSWORD)  VALUE="$( _math random_integer 1 99999 fillup )" ;;
					login_INSTALLED) VALUE="$( _system date unixtime )" ;;
				esac

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*) SHORT_VAR="A" ;;
				esac
				
				LIST="${LIST}$SHORT_VAR='$VALUE';"
				N=$(( $N + 1 ))
			} done

			case "$ACTION" in
				add)
					echo "$LIST" >>"$DIR/rows"
				;;
				update)
					sed -i "${ID}s#^.*#ID=$ID;$LIST#" "$DIR/rows"
				;;
			esac
		;;
	esac
}

_db_ticketcheck ()								# going through list of profiles (user defined or all)
{										#
	local FUNC="db_ticketcheck"						# going reverse through list of last new devices
	local PROFILE_ID_WISH="${1:-$( _db user profile list )}"		# which profile has the login, which have used this device?
	local DEVICE_ID_LIST_REVERSE="${2:-$( _db user device list reverse )}"	# if profile = wished, than check:
	local DEVICE_ID_LIST="$( _db user device list )"			#
										# go through list of all login's, after the used one
	local ALIEN_PROFILE_ID ALIEN_ID USER_ID_LAST I ID ID2 USER_ID_STACK	# count, which have whished profile X and are unused
	local AUTOGENERATE_BORDER=15

	profiles_are_matching_and_login_is_unused ()		# needs global ID_CHECK + ALIEN_PROFILE_ID + DEVICE_ID_LIST
	{
		eval $( _db user login show $ID_CHECK )				# get PROFILE_ID

		[ "$PROFILE_ID" = "$ALIEN_PROFILE_ID" ] && {

			for ID2 in $DEVICE_ID_LIST; do {
				eval $( _db user device show $ID2 )		# get USER_ID
				[ "$ID_CHECK" = "$USER_ID" ] && return 1
			} done
		}
	}

	_stopwatch start $FUNC

	for ALIEN_PROFILE_ID in $PROFILE_ID_WISH; do {

		eval "$( _db user profile show $ALIEN_PROFILE_ID )"		# get AUTOGENERATE + NAME

		if [ "$AUTOGENERATE" = "1" ]; then
			_log do $FUNC daemon debug "checking for unused tickets with profile $ALIEN_PROFILE_ID $NAME"
		else
			_log do $FUNC daemon debug "ignoring profile $ALIEN_PROFILE_ID $NAME - autogenerate is off"
			continue
		fi

		for ALIEN_ID in $DEVICE_ID_LIST_REVERSE; do {

			eval "$( _db user device show $ALIEN_ID )"		# get USER_ID which has used this device
			eval "$( _db user login show $USER_ID )"		# get PROFILE_ID for this login
#			USER_ID_STACK="$USER_ID"
#			eval "$( _db user profile show $ALIEN_PROFILE_ID )"	# get ???

			[ "$PROFILE_ID" = "$ALIEN_PROFILE_ID" ] && {		# matches user/loop_wish?

				I=0
				LOGIN_LAST="$( _db user login list last )"
				DIFF="$(( $LOGIN_LAST - $USER_ID ))"
echo "now for ID_CHECK in $( _db user login list last $DIFF )"
				for ID_CHECK in $( _db user login list last $DIFF ); do {
					profiles_are_matching_and_login_is_unused && I=$(( $I + 1 ))
				} done

				if [ $I -lt $AUTOGENERATE_BORDER ]; then
					_log do $FUNC daemon alert "[ERR] only $I unused tickets/logins for profile $ALIEN_PROFILE_ID ($NAME) in database (after login $USER_ID)"
				else
					_log do $FUNC daemon info "[OK] $I (enough) unused tickets/logins for profile $ALIEN_PROFILE_ID ($NAME) in database (after login $USER_ID)"
				fi

				break
			}
		} done
	} done

	_stopwatch stop $FUNC
}
