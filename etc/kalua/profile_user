func_profile_map_name ()	# OUT1: string			# fixme! respect city/region
{								# fixme! safe individual profile, not common profile
	case $1 in
		backbone_mesh_band_g)	echo "weimarnetz_backbone_mesh" ;;
		standard_mesh_band_g)	echo "weimarnetz_standard_mesh" ;;
		standard_ap_band_g)	echo "weimarnetz_standard_ap" ;;
		standard_client_band_g) echo "weimarnetz_standard_client" ;;
		standard_mesh_band_a)	echo "weimarnetz_standard_mesh_5ghz" ;;
		
		*) 			echo "unknown ('$1')"
					return 1
		;;
	esac
}

func_profile_set_weimarnetz_standard_mesh ()
{
	[ "$1" = "info" ] && {
		echo "Standardeinstellungen fuer Weimar mit dem Weimarer IP-System."
		echo "Auf LAN und WLAN werden per DHCP Adressen vergeben."
		echo "Auf LAN, WAN und WLAN wird OLSR gesprochen."
		echo "Alle Weimarer Firmware-Erweiterungen sind aktiviert."
		echo "Das Funknetzwerk arbeitet im performanten 802.11g-Modus (longslot) auf Kanal 5,"
		echo "nutzt den Mesh-(AdHoc)-Modus mit fixer BSSID, 256-Byte-WLAN-Packetfragmentierung"
		echo "und einer niedrigen Beacon-Aussendung von 1/Sekunde. Broadcast-Pakete"
		echo "(z.b. OLSR) werden fest mit einer 802.11b-Rate von 1.0 Megabit im 802.11b-Modus gesendet."
		echo "Der ACK-Bestaetigungsmechanismus hat die Standard-Einstellung."
		return
	}
	
	eval "$(func_ipsystem_ffweimar $1)"

	func_profile_set_system         "DEFAULTS=true" "HOSTNAME=node${NODE_NUMBER}mesh" "TZ=$( _timezone DE )"
	func_profile_set_system         "DNS=$( _dnsservers berlin )" "REPOS=$( _reposet ffweimar )" "SERVERS=$( _servers ffweimar )"
	func_profile_set_wan	        "IP=$WAN_IP"
	func_profile_set_lan         	"IP=$LAN_IP"  "DHCP=$DHCP_LAN"
	func_profile_set_wifi      	"IP=$WIFI_IP" "DHCP=$DHCP_WIFI"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=1000000" "FRAG=256" "BEACON=100" "GMODE=2"
	func_profile_set_wifi_phy       "MODE=adhoc" "ESSID=weimarnetz" "BSSID=02:ca:ff:ee:ba:be" "CHANNEL=5"
	func_profile_set_olsr           "DEFAULTS=true"
	func_profile_set_fff_extensions "DEFAULTS=true" "NODE_NUMBER=$NODE_NUMBER"
	func_profile_set_packetfilter   "NAT=off" "FIREWALL=off"
}

func_profile_set_ejbw_mesh ()		# fixme! block_wifi_access? / LAN_DHCP=0 / static_route / gateway = ipcop / update=0 
{
	[ "$1" = "info" ] && return
	
	func_profile_set_weimarnetz_standard_mesh_5ghz $1

	func_profile_set_wifi_phy	"MODE=adhoc" "ESSID=ejbw" "BSSID=02:ca:ff:ee:b0:42" "CHANNEL=42" "DISTANCE=300"
}

func_profile_set_elephant_mesh ()
{
	[ "$1" = "info" ] && return

	eval "$(func_ipsystem_ffweimar $1)"
	
	func_profile_set_system         "DEFAULTS=true" "HOSTNAME=node${NODE_NUMBER}mesh" "TZ=$( _timezone DE )" "WEBLOGIN=true" "VDS=true"
	func_profile_set_system         "DNS=$( _dnsservers berlin )" "REPOS=$( _reposet elephant )" "SERVERS=$( _servers elephant )"
	func_profile_set_wan            "IP=$WAN_IP"
	func_profile_set_lan            "IP=$LAN_IP"  "DHCP=$DHCP_LAN"
	func_profile_set_wifi           "IP=$WIFI_IP" "DHCP=$DHCP_WIFI"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=6000000" "FRAG=256" "BEACON=10000" "GMODE=2"
	func_profile_set_wifi_phy       "MODE=adhoc" "ESSID=bb" "BSSID=02:ca:ff:ee:b0:13" "CHANNEL=13" "TXPOWER=40"
	func_profile_set_olsr           "DEFAULTS=true"
	func_profile_set_fff_extensions "DEFAULTS=true" "NODE_NUMBER=$NODE_NUMBER"
	func_profile_set_packetfilter   "NAT=off" "FIREWALL=off"
}

func_profile_set_galerie_mesh ()
{
	[ "$1" = "info" ] && return	

	func_profile_set_elephant_mesh $1

	func_profile_set_system		"REPOS=$( _reposet galerie )" "SERVERS=$( _servers galerie )"
	func_profile_set_wifi_phy	"MODE=adhoc" "BSSID=02:ca:ff:ee:ba:be" "MRATE=5500000"
}

func_profile_set_ffsundi_mesh ()
{
	[ "$1" = "info" ] && {
		echo "Standardeinstellungen fuer Sundi mit dem Sundi-IP-System."
		echo "Auf LAN und WLAN werden per DHCP Adressen vergeben."
		echo "Auf LAN, WAN und WLAN wird OLSR gesprochen."
		echo "Alle Weimarer Firmware-Erweiterungen sind aktiviert."
		echo "Das Funknetzwerk arbeitet im performanten 802.11g-(AdHoc)-Modus."
		return
	}
	
	eval "$(func_ipsystem_ffsundi $1)"
	
	func_profile_set_system         "DEFAULTS=true" "HOSTNAME=node${NODE_NUMBER}mesh" "TZ=$( _timezone DE )" "IPSYSTEM=ffsundi"
	func_profile_set_system         "DNS=$( _dnsservers ffsundi )" "REPOS=$( _reposet ffsundi )" "SERVERS=$( _servers ffsundi )"
	func_profile_set_wan            "IP=$WAN_IP"
	func_profile_set_lan            "IP=$LAN_IP"  "DHCP=$DHCP_LAN"
	func_profile_set_wifi           "IP=$WIFI_IP" "DHCP=$DHCP_WIFI"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=6000000" "GMODE=4"
	func_profile_set_wifi_phy       "MODE=adhoc" "ESSID=sundi.freifunk.net" "BSSID=02:ca:ff:ee:ba:be" "CHANNEL=8"
	func_profile_set_wifi_phy       "BEACON=100" "RTS=off"
	func_profile_set_olsr           "DEFAULTS=true"
	func_profile_set_fff_extensions "DEFAULTS=true" "NODE_NUMBER=$NODE_NUMBER"
	func_profile_set_packetfilter   "NAT=off" "FIREWALL=off"
}

func_profile_set_elephant_ap ()
{
	[ "$1" = "info" ] && return

	func_profile_set_elephant_mesh $1
	
	func_profile_set_system         "HOSTNAME=node${NODE_NUMBER}ap"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=auto" "GMODE=1" "MODE=ap" "ESSID=Hotel-Elephant" "CHANNEL=1"
}

func_profile_set_galerie_ap ()
{
	func_profile_set_elephant_ap $1
	
	[ "$1" = "info" ] && return
	
	func_profile_set_system		"REPOS=$(func_reposet_galerie)" "SERVERS=$(func_servers_galerie)"
	func_profile_set_wifi_phy	"ESSID=www.leipziger-hof.de"
}

func_profile_set_weimarnetz_backbone_mesh ()
{
	[ "$1" = "info" ] && {
		echo "Entspricht dem Profil 'weimarnetz_standard_mesh', arbeitet aber auf"
		echo "Kanal 13 und mit anderer BSSID."
		return
	}
	
	func_profile_set_weimarnetz_standard_mesh "$1"
	
	func_profile_set_wifi_phy	"MODE=adhoc" "ESSID=weimarnetz_backbone_2GHz" "BSSID=02:ca:ca:00:ba:be" "CHANNEL=13"
}

func_profile_set_weimarnetz_standard_ap ()
{
	[ "$1" = "info" ] && {
		echo "Standardeinstellungen fuer Weimar mit dem Weimarer IP-System."
		echo "Auf LAN und WLAN werden per DHCP Adressen vergeben."
		echo "Auf LAN, WAN und WLAN wird OLSR gesprochen."
		echo "Alle Weimarer Firmware-Erweiterungen sind aktiviert."
		echo "Das Funknetzwerk arbeitet im hochkompatiblen-802.11b/g-Master/AP-Modus,"
		echo "ist also nur sinnvoll, wenn mindestens ein zweiter Router per Kabelkopplung"
		echo "angeschlossen wird, der im Mesh-(AdHoc)-Modus arbeitet."
		return
	}			# howto disable wifi-olsr?

	func_profile_set_weimarnetz_standard_mesh $1
	
	func_profile_set_system		"HOSTNAME=node${NODE_NUMBER}ap"
	func_profile_set_wifi_phy	"DEFAULTS=true" "MRATE=auto" "MODE=ap" "ESSID=weimarnetz" "CHANNEL=1"
}

func_profile_set_weimarnetz_standard_client ()
{
	[ "$1" = "info" ] && {
		echo "Noch nicht vollstaendig implementiert - nur fuer Testzwecke von Experten zu benutzen"
		echo "Momentan das Profil darauf abgestimmt, mit einem AP per WIFI-OLSR gekoppelt zu werden."
		# fixme! echo "client-klauschwein, muss wifi-dhcp machen?, essid+evtl.channel merken!"
		return
	}
	
	func_profile_set_weimarnetz_standard_ap $1
	
	func_profile_set_system		"HOSTNAME=node${NODE_NUMBER}client"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=1000000" "MODE=client"
}

func_profile_set_weimarnetz_standard_mesh_5ghz ()
{
	[ "$1" = "info" ] && {
		echo "Standardeinstellungen fuer Weimar mit dem Weimarer IP-System."
		echo "Auf LAN und WLAN werden per DHCP Adressen vergeben."
		echo "Auf LAN, WAN und WLAN wird OLSR gesprochen."
		echo "Alle Weimarer Firmware-Erweiterungen sind aktiviert."
		echo "Das Funknetzwerk arbeitet im performanten 802.11a-(AdHoc)-Modus."
		echo "Wird eine Atheros-Karte verwendet, werden die madwifi-Treiber im 5 GHz-Outdoor-Modus benutzt."
		return
	}

	func_profile_set_weimarnetz_standard_mesh $1
	
	func_profile_set_system         "HOSTNAME=node${NODE_NUMBER}mesh5ghz"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=6000000" "DISTANCE=5000"
	func_profile_set_wifi_phy       "MODE=adhoc" "ESSID=weimarnetz" "BSSID=02:ff:ff:ca:00:42" "CHANNEL=42" "BEACON=1000" "RTS=off"
}

func_profile_set_versilia_mesh ()
{
	[ "$1" = "info" ] && return
	
	func_profile_set_weimarnetz_standard_mesh $1

	func_profile_set_system		"REPOS=$( _reposet versilia )" "SERVERS=$( _servers versilia )" "WEBLOGIN=true"
	func_profile_set_wifi_phy	"ESSID=Ristorante_Versilia" "CHANNEL=13"
}

func_profile_set_versilia_ap ()
{
	[ "$1" = "info" ] && return
	
	func_profile_set_versilia_mesh $1

	func_profile_set_wifi_phy	"DEFAULTS=true" "MRATE=auto" "GMODE=1" "MODE=ap" "CHANNEL=1"
}

func_profile_set_versilia_client ()
{
	[ "$1" = "info" ] && return
	
	func_profile_set_versilia_ap $1

	func_profile_set_wifi_phy	"MODE=client"
}

_dnsservers ()
{
	local SERVERSET="$1"
	
	case $SERVERSET in
		 berlin) echo -n "81.169.139.12;212.91.230.58;208.67.222.222" ;;
		ffsundi) echo -n "192.168.254.2;81.169.139.12;212.91.230.58" ;;
	esac
}

_timezone ()
{
	case $1 in
		DE) echo -n "CET-1CEST-2,M3.5.0/2,M10.5.0/3" ;;
	esac
}

_servers_bittorfwireless ()	# 84.38.67.43 = intercity-vpn.de
{
	local NETWORK="$1"
	
	echo -n "intercity-vpn.de/firmware;intercity-vpn.de/networks/${NETWORK};weimarnetz.de;87.118.106.19;fe80::216:3eff:fe4f:7f20"
}

_servers ()
{
	local NETWORK="$1"
	
	case $NETWORK in
		versilia) _servers_bittorfwireless $NETWORK ;;
		elephant) _servers_bittorfwireless $NETWORK ;;
		 galerie) _servers_bittorfwireless $NETWORK ;;
		ffweimar) _servers_bittorfwireless $NETWORK ;;
		 ffsundi) _servers_bittorfwireless $NETWORK ;;
	esac
}

_reposet_bittorfwireless ()
{
	local NETWORK="$1"
	
	echo -n "$( _reposet essential );src ${NETWORK} http://intercity-vpn.de/networks/${NETWORK}/packages"	
}

_reposet ()
{
	local NETWORK="$1"
	
	case $NETWORK in
		versilia) _reposet_bittorfwireless $NETWORK ;;
		elephant) _reposet_bittorfwireless $NETWORK ;;
		 galerie) _reposet_bittorfwireless $NETWORK ;;
		ffweimar) _reposet_bittorfwireless $NETWORK ;;
		 ffsundi) _reposet_bittorfwireless $NETWORK ;;
		 
	       essential) echo -n "src essential http://intercity-vpn.de/firmware/broadcom/packages/2.4.30/essential" ;;
	esac
}

func_conf ()		# e.g. func_conf boot_watchdog && start_bootwatchdog (OUT=bool)
{			# e.g. func_conf show_all -> list (value short_desc long_desc)

	local P=1

	[ "$1" = "show_all" ] && {
		while func_conf $P info; do {
			P=$(( $P + 1 ))
		} done
		return 0
	}
	
	local VAR="fff_extensions"
	local VALUE="$( nvram get $VAR )"
	local I="no description available"
	local S="short_description"
	
	case $1 in
		      speedtest|1)  P=1  ; S="speedtest"       ; I="Alle 40 Minuten wird von einem zufaelligem Nachbarn 10 fuer Sekunden ein Testdownload gemacht. Diese Werte dienen als Berechnungsgrundlage fuer ein Bandbreitenabhaengiges Routing." ;;
		 	adblock|2)  P=2  ; S="adblock"         ; I="Ueber eine systemweite DNS-Liste ('/etc/local.hosts') werden bekannte Werbebanner geschluckt (zurueckgewiesen). Weniger Datenverkehr und schnelleres surfen im Web." ;;
		 firmwareupdate|3)  P=3  ; S="firmwareupdate"  ; I="Automatisches Firmwareupdate, je nach Einstellung." ;;
		lazy_wired_olsr|4)  P=4  ; S="lazy_wired_olsr" ; I="Auf allen Netzwerkschnittstellen, auf denen kein OLSR-Partner zu hoeren ist, wird OLSR abgeschaltet. Alle 15 Stunden wird neu ueberprueft." ;;
		  boot_watchdog|5)  P=5  ; S="boot_watchdog"   ; I="Sollte 10 Minuten nach dem Boot-Vorgang kein OLSR laufen, werden alle Partitionen neu formatiert und nochmal gestartet." ;;
		     layer7_qos|6)  P=6  ; S="layer7_qos"      ; I="Die gaengigsten Protokolle (HTTP,FTP,...) werden auf Layer7-Basis erkannt, markiert und entsprecht der Wichtigkeit priorisiert." ;;
		    no_wifi_nat|7)  P=7  ; S="no_wifi_nat"     ; I="Das maskieren der WLAN-Klienten wird deaktivert. Dazu muss der WLAN-Bereich per OLSR-HNA4 angekuendigt werden." ;;
		     splashpage|8)  P=8  ; S="splashpage"      ; I="Alle Benutzer sehen, wenn sie das interne Netzwerk verlassen eine Infoseite, die " ;;
		   smart_ethers|9)  P=9  ; S="smart_ethers"    ; I="Es koennen MAC-Adressen eingegeben werden, die " ;;
		   boot_telnetd|10) P=10 ; S="boot_telnetd"    ; I="Waehrend der ersten 10 Minuten des Startvorgangs ist zusaetzlich zum SSH-Login auch ein telnet-Login ohne Passwort moeglich." ;;
		    auto_config|11) P=11 ; S="auto_config"     ; I="Beim Bootvorgang werden automatisch alle Einstellungen vorgenommen, es sei denn, dies wurde schonmal getan." ;;
	         olsr_whitelist|12) P=12 ; S="olsr_whitelist"  ; I="Nur von zentral in einer 'whitelist' eingetragenen Netzknoten (MAC/IP-Kombination) werden OLSR-Pakete akzeptiert. Damit gibt es weniger Konfigurationsfehler. Diese Liste wird alle 10 Stunden optimiert." ;;
		  auto_software|13) P=13 ; S="auto_software"   ; I="Abhaengig von Speicherplatz und gewuenschter Funktionalitaet werden automatisch nach dem flashen brauchbare Software-Pakete nachinstalliert." ;;
		      nud_neigh|14) P=14 ; S="nud_neigh"       ; I="Alle OLSR-Nachbarn werden permanent in die Kernel-NUD-Liste eingetragen." ;;
		      nud_local|15) P=15 ; S="nud_local"       ; I="Lokal bekannte Benutzer werden permanent in die Kernel-NUD-Liste eingetragen." ;;
		       mesh_rdf|16) P=16 ; S="mesh_rdf"        ; I="Alle 15 Minuten werden Statusinformationen dieses Netzknotens local gespeichert und in zufaelligen Abstaenden zu einem zentralen Server gesendet" ;;
                     accounting|17) P=17 ; S="accounting"      ; I="Es kann eine Liste aller Benutzer abgefragt werden, die auf diesem Netzknoten irgendwie Datenverkehr verursacht haben." ;;
	                 ic_vpn|18) P=18 ; S="ic_vpn"          ; I="Ist ein lokaler Internetzugang vorhanden, wird automatisch am Intercity-VPN teilgenommen. Dabei werden Funkwolken ueber VPN gekoppelt." ;;
                  system_checks|19) P=19 ; S="system_checks"   ; I="Alle 15 Minuten werden die wichtigen Dienste auf korrekte Funktionalitaet geprueft und neugestartet, wenn noetig." ;;
                      check_mac|20) P=20 ; S="check_mac"       ; I="Alle MAC-Adressen dieses Geraets werden beim Start geprueft. Sollte eine ungueltige festgestellt werden, wird dies korrigiert." ;;
				 *) P=0
		;;
	esac

	VAR="$(echo -n $VALUE | cut -b$P)"

	[ "$2" = "info" ] && {
		[ $P -eq 0 ] && return 1
		echo "local VALUE='$VAR';local DESC_SHORT='$S'; local DESC_LONG='$I'"
		return 0
	}

	[ 2>/dev/null "$VAR" -gt 0 ] && return 0
	return 1
}
