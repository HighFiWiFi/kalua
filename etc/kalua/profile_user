FUNC_PROFILE_USER=1

# func_profile_map_name
# func_profile_set_weimarnetz_standard_mesh
# func_profile_set_ejbw_mesh
# func_profile_set_elephant_mesh
# func_profile_set_galerie_mesh
# func_profile_set_ffsundi_mesh
# func_profile_set_elephant_ap
# func_profile_set_galerie_ap
# func_profile_set_weimarnetz_backbone_mesh
# func_profile_set_weimarnetz_standard_ap
# func_profile_set_weimarnetz_standard_client
# func_profile_set_weimarnetz_standard_mesh_5ghz
# func_profile_set_versilia_mesh
# func_profile_set_versilia_ap
# func_profile_set_versilia_client
# _dnsservers
# _timezone
# _servers_bittorfwireless
# _servers
# _reposet_bittorfwireless
# _reposet
# func_ipsystem
# func_ipsystem_ffsundi
# func_ipsystem_ffweimar
# func_conf

func_profile_map_name ()	# OUT1: string			# fixme! respect city/region
{								# fixme! safe individual profile, not common profile
	case $1 in
		backbone_mesh_band_g)	echo "weimarnetz_backbone_mesh" ;;
		standard_mesh_band_g)	echo "weimarnetz_standard_mesh" ;;
		standard_ap_band_g)	echo "weimarnetz_standard_ap" ;;
		standard_client_band_g) echo "weimarnetz_standard_client" ;;
		standard_mesh_band_a)	echo "weimarnetz_standard_mesh_5ghz" ;;
		
		*) 			echo "unknown ('$1')"
					return 1
		;;
	esac
}

func_profile_set_weimarnetz_standard_mesh ()
{
	[ "$1" = "info" ] && {
		echo "Standardeinstellungen fuer Weimar mit dem Weimarer IP-System."
		echo "Auf LAN und WLAN werden per DHCP Adressen vergeben."
		echo "Auf LAN, WAN und WLAN wird OLSR gesprochen."
		echo "Alle Weimarer Firmware-Erweiterungen sind aktiviert."
		echo "Das Funknetzwerk arbeitet im performanten 802.11g-Modus (longslot) auf Kanal 5,"
		echo "nutzt den Mesh-(AdHoc)-Modus mit fixer BSSID, 256-Byte-WLAN-Packetfragmentierung"
		echo "und einer niedrigen Beacon-Aussendung von 1/Sekunde. Broadcast-Pakete"
		echo "(z.b. OLSR) werden fest mit einer 802.11b-Rate von 1.0 Megabit im 802.11b-Modus gesendet."
		echo "Der ACK-Bestaetigungsmechanismus hat die Standard-Einstellung."
		return
	}
	
	eval "$(func_ipsystem_ffweimar $1)"

	func_profile_set_system         "DEFAULTS=true" "HOSTNAME=node${NODE_NUMBER}mesh" "TZ=$( _timezone DE )"
	func_profile_set_system         "DNS=$( _dnsservers berlin )" "REPOS=$( _reposet ffweimar )" "SERVERS=$( _servers ffweimar )"
	func_profile_set_wan	        "IP=$WAN_IP"
	func_profile_set_lan         	"IP=$LAN_IP"  "DHCP=$DHCP_LAN"
	func_profile_set_wifi      	"IP=$WIFI_IP" "DHCP=$DHCP_WIFI"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=1000000" "FRAG=256" "BEACON=100" "GMODE=2"
	func_profile_set_wifi_phy       "MODE=adhoc" "ESSID=weimarnetz" "BSSID=02:ca:ff:ee:ba:be" "CHANNEL=5"
	func_profile_set_olsr           "DEFAULTS=true"
	func_profile_set_fff_extensions "DEFAULTS=true" "NODE_NUMBER=$NODE_NUMBER"
	func_profile_set_packetfilter   "NAT=off" "FIREWALL=off"
}

func_profile_set_ejbw_mesh ()		# fixme! block_wifi_access? / LAN_DHCP=0 / static_route / gateway = ipcop / update=0 
{
	[ "$1" = "info" ] && return
	
	func_profile_set_weimarnetz_standard_mesh_5ghz $1

	func_profile_set_wifi_phy	"MODE=adhoc" "ESSID=ejbw" "BSSID=02:ca:ff:ee:b0:42" "CHANNEL=42" "DISTANCE=300"
}

func_profile_set_elephant_mesh ()
{
	[ "$1" = "info" ] && return

	eval "$(func_ipsystem_ffweimar $1)"
	
	func_profile_set_system         "DEFAULTS=true" "HOSTNAME=node${NODE_NUMBER}mesh" "TZ=$( _timezone DE )" "WEBLOGIN=true" "VDS=true"
	func_profile_set_system         "DNS=$( _dnsservers berlin )" "REPOS=$( _reposet elephant )" "SERVERS=$( _servers elephant )"
	func_profile_set_wan            "IP=$WAN_IP"
	func_profile_set_lan            "IP=$LAN_IP"  "DHCP=$DHCP_LAN"
	func_profile_set_wifi           "IP=$WIFI_IP" "DHCP=$DHCP_WIFI"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=6000000" "FRAG=256" "BEACON=10000" "GMODE=2"
	func_profile_set_wifi_phy       "MODE=adhoc" "ESSID=bb" "BSSID=02:ca:ff:ee:b0:13" "CHANNEL=13" "TXPOWER=40"
	func_profile_set_olsr           "DEFAULTS=true"
	func_profile_set_fff_extensions "DEFAULTS=true" "NODE_NUMBER=$NODE_NUMBER"
	func_profile_set_packetfilter   "NAT=off" "FIREWALL=off"
}

func_profile_set_galerie_mesh ()
{
	[ "$1" = "info" ] && return	

	func_profile_set_elephant_mesh $1

	func_profile_set_system		"REPOS=$( _reposet galerie )" "SERVERS=$( _servers galerie )"
	func_profile_set_wifi_phy	"MODE=adhoc" "BSSID=02:ca:ff:ee:ba:be" "MRATE=5500000"
}

func_profile_set_ffsundi_mesh ()
{
	[ "$1" = "info" ] && {
		echo "Standardeinstellungen fuer Sundi mit dem Sundi-IP-System."
		echo "Auf LAN und WLAN werden per DHCP Adressen vergeben."
		echo "Auf LAN, WAN und WLAN wird OLSR gesprochen."
		echo "Alle Weimarer Firmware-Erweiterungen sind aktiviert."
		echo "Das Funknetzwerk arbeitet im performanten 802.11g-(AdHoc)-Modus."
		return
	}
	
	eval "$(func_ipsystem_ffsundi $1)"
	
	func_profile_set_system         "DEFAULTS=true" "HOSTNAME=node${NODE_NUMBER}mesh" "TZ=$( _timezone DE )" "IPSYSTEM=ffsundi"
	func_profile_set_system         "DNS=$( _dnsservers ffsundi )" "REPOS=$( _reposet ffsundi )" "SERVERS=$( _servers ffsundi )"
	func_profile_set_wan            "IP=$WAN_IP"
	func_profile_set_lan            "IP=$LAN_IP"  "DHCP=$DHCP_LAN"
	func_profile_set_wifi           "IP=$WIFI_IP" "DHCP=$DHCP_WIFI"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=6000000" "GMODE=4"
	func_profile_set_wifi_phy       "MODE=adhoc" "ESSID=sundi.freifunk.net" "BSSID=02:ca:ff:ee:ba:be" "CHANNEL=8"
	func_profile_set_wifi_phy       "BEACON=100" "RTS=off"
	func_profile_set_olsr           "DEFAULTS=true"
	func_profile_set_fff_extensions "DEFAULTS=true" "NODE_NUMBER=$NODE_NUMBER"
	func_profile_set_packetfilter   "NAT=off" "FIREWALL=off"
}

func_profile_set_elephant_ap ()
{
	[ "$1" = "info" ] && return

	func_profile_set_elephant_mesh $1
	
	func_profile_set_system         "HOSTNAME=node${NODE_NUMBER}ap"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=auto" "GMODE=1" "MODE=ap" "ESSID=Hotel-Elephant" "CHANNEL=1"
}

func_profile_set_galerie_ap ()
{
	func_profile_set_elephant_ap $1
	
	[ "$1" = "info" ] && return
	
	func_profile_set_system		"REPOS=$(func_reposet_galerie)" "SERVERS=$(func_servers_galerie)"
	func_profile_set_wifi_phy	"ESSID=www.leipziger-hof.de"
}

func_profile_set_weimarnetz_backbone_mesh ()
{
	[ "$1" = "info" ] && {
		echo "Entspricht dem Profil 'weimarnetz_standard_mesh', arbeitet aber auf"
		echo "Kanal 13 und mit anderer BSSID."
		return
	}
	
	func_profile_set_weimarnetz_standard_mesh "$1"
	
	func_profile_set_wifi_phy	"MODE=adhoc" "ESSID=weimarnetz_backbone_2GHz" "BSSID=02:ca:ca:00:ba:be" "CHANNEL=13"
}

func_profile_set_weimarnetz_standard_ap ()
{
	[ "$1" = "info" ] && {
		echo "Standardeinstellungen fuer Weimar mit dem Weimarer IP-System."
		echo "Auf LAN und WLAN werden per DHCP Adressen vergeben."
		echo "Auf LAN, WAN und WLAN wird OLSR gesprochen."
		echo "Alle Weimarer Firmware-Erweiterungen sind aktiviert."
		echo "Das Funknetzwerk arbeitet im hochkompatiblen-802.11b/g-Master/AP-Modus,"
		echo "ist also nur sinnvoll, wenn mindestens ein zweiter Router per Kabelkopplung"
		echo "angeschlossen wird, der im Mesh-(AdHoc)-Modus arbeitet."
		return
	}			# howto disable wifi-olsr?

	func_profile_set_weimarnetz_standard_mesh $1
	
	func_profile_set_system		"HOSTNAME=node${NODE_NUMBER}ap"
	func_profile_set_wifi_phy	"DEFAULTS=true" "MRATE=auto" "MODE=ap" "ESSID=weimarnetz" "CHANNEL=1"
}

func_profile_set_weimarnetz_standard_client ()
{
	[ "$1" = "info" ] && {
		echo "Noch nicht vollstaendig implementiert - nur fuer Testzwecke von Experten zu benutzen"
		echo "Momentan das Profil darauf abgestimmt, mit einem AP per WIFI-OLSR gekoppelt zu werden."
		# fixme! echo "client-klauschwein, muss wifi-dhcp machen?, essid+evtl.channel merken!"
		return
	}
	
	func_profile_set_weimarnetz_standard_ap $1
	
	func_profile_set_system		"HOSTNAME=node${NODE_NUMBER}client"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=1000000" "MODE=client"
}

func_profile_set_weimarnetz_standard_mesh_5ghz ()
{
	[ "$1" = "info" ] && {
		echo "Standardeinstellungen fuer Weimar mit dem Weimarer IP-System."
		echo "Auf LAN und WLAN werden per DHCP Adressen vergeben."
		echo "Auf LAN, WAN und WLAN wird OLSR gesprochen."
		echo "Alle Weimarer Firmware-Erweiterungen sind aktiviert."
		echo "Das Funknetzwerk arbeitet im performanten 802.11a-(AdHoc)-Modus."
		echo "Wird eine Atheros-Karte verwendet, werden die madwifi-Treiber im 5 GHz-Outdoor-Modus benutzt."
		return
	}

	func_profile_set_weimarnetz_standard_mesh $1
	
	func_profile_set_system         "HOSTNAME=node${NODE_NUMBER}mesh5ghz"
	func_profile_set_wifi_phy       "DEFAULTS=true" "MRATE=6000000" "DISTANCE=5000"
	func_profile_set_wifi_phy       "MODE=adhoc" "ESSID=weimarnetz" "BSSID=02:ff:ff:ca:00:42" "CHANNEL=42" "BEACON=1000" "RTS=off"
}

func_profile_set_versilia_mesh ()
{
	[ "$1" = "info" ] && return
	
	func_profile_set_weimarnetz_standard_mesh $1

	func_profile_set_system		"REPOS=$( _reposet versilia )" "SERVERS=$( _servers versilia )" "WEBLOGIN=true"
	func_profile_set_wifi_phy	"ESSID=Ristorante_Versilia" "CHANNEL=13"
}

func_profile_set_versilia_ap ()
{
	[ "$1" = "info" ] && return
	
	func_profile_set_versilia_mesh $1

	func_profile_set_wifi_phy	"DEFAULTS=true" "MRATE=auto" "GMODE=1" "MODE=ap" "CHANNEL=1"
}

func_profile_set_versilia_client ()
{
	[ "$1" = "info" ] && return
	
	func_profile_set_versilia_ap $1

	func_profile_set_wifi_phy	"MODE=client"
}

_dnsservers ()
{
	local SERVERSET="$1"
	
	case $SERVERSET in
		 berlin) echo -n "81.169.139.12;212.91.230.58;208.67.222.222" ;;
		ffsundi) echo -n "192.168.254.2;81.169.139.12;212.91.230.58" ;;
	esac
}

_timezone ()
{
	case $1 in
		DE) echo -n "CET-1CEST-2,M3.5.0/2,M10.5.0/3" ;;
	esac
}

_servers_bittorfwireless ()	# 84.38.67.43 = intercity-vpn.de
{
	local NETWORK="$1"
	
	echo -n "intercity-vpn.de/firmware;intercity-vpn.de/networks/${NETWORK};weimarnetz.de;87.118.106.19;fe80::216:3eff:fe4f:7f20"
}

_servers ()
{
	local NETWORK="$1"
	
	case $NETWORK in
		versilia) _servers_bittorfwireless $NETWORK ;;
		elephant) _servers_bittorfwireless $NETWORK ;;
		 galerie) _servers_bittorfwireless $NETWORK ;;
		ffweimar) _servers_bittorfwireless $NETWORK ;;
		 ffsundi) _servers_bittorfwireless $NETWORK ;;
	esac
}

_reposet_bittorfwireless ()
{
	local NETWORK="$1"
	
	echo -n "$( _reposet essential );src ${NETWORK} http://intercity-vpn.de/networks/${NETWORK}/packages"	
}

_reposet ()
{
	local NETWORK="$1"
	
	case $NETWORK in
		versilia) _reposet_bittorfwireless $NETWORK ;;
		elephant) _reposet_bittorfwireless $NETWORK ;;
		 galerie) _reposet_bittorfwireless $NETWORK ;;
		ffweimar) _reposet_bittorfwireless $NETWORK ;;
		 ffsundi) _reposet_bittorfwireless $NETWORK ;;
		 
	       essential) echo -n "src essential http://intercity-vpn.de/firmware/broadcom/packages/2.4.30/essential" ;;
	esac
}

func_ipsystem ()
{
	local SYSTEM="$( nvram get fff_ipsystem )"

	func_ipsystem_${SYSTEM:-ffweimar} "$1"
}

func_ipsystem_ffsundi ()		# ARG1: - empty       -> has_nodenumber? -> output for my nodenumber
{					#  	- "random" or empty && no_nodenumber?  -> output for random nodenumber
	local NODE_NUMBER="$1"		#       - IP-address  -> output nodenumber
	local CITY="10"			#	- node-number -> output for this nodenumber, return 1 if not in range
	local NW="10"
	local RANGE_START="2"
	local RANGE_END="254"
	local RANGE_FIRST_RANDOM="220"

	  if [ -z "$NODE_NUMBER" ]; then
		NODE_NUMBER="$( nvram get fff_node_number )"
		[ -z "$NODE_NUMBER" ] && NODE_NUMBER=$( func_get_random_value $RANGE_FIRST_RANDOM $RANGE_END )
	elif [ "$NODE_NUMBER" = "random" ]; then
		NODE_NUMBER=$( func_get_random_value $RANGE_FIRST_RANDOM $RANGE_END )
	elif [ "$( echo $NODE_NUMBER | sed 's/[^\.]//g' )" = '...' ]; then	# is IPv4

		eval $(echo $NODE_NUMBER|sed -n 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/local OCT1=\1\nlocal OCT2=\2\nlocal OCT3=\3\nlocal OCT4=\4/p')

		[ $OCT1 -eq $NW ] && [ $OCT2 -eq $CITY ] && {
			  if [ $OCT3 -eq 10 ]; then                echo $OCT4		# input = wifi-ip4
			elif [ $OCT4 -ge 0 -a $OCT4 -le 63 ]; then echo $OCT3		# input = lan-ip4
			fi  
			return 0
		}
		return 1
	fi
	
	if [ 2>/dev/null "$NODE_NUMBER" -ge $RANGE_START -a "$NODE_NUMBER" -le $RANGE_END ]; then
			
		local S=0			# subnetstart 	e.g. network.city.100.${S}
		local N=$NODE_NUMBER		# nodenumber_id	e.g. network.city.${N}.0
		local RANDOM=false
		
		if [ "$NODE_NUMBER" -ge $RANGE_FIRST_RANDOM ]; then
			RANDOM=true
		fi
	else
		return 1
	fi

	cat<<EOF
NODE_NUMBER=$NODE_NUMBER
NODE_NUMBER_RANDOM=$RANDOM
OLSR_HNA=$NW.$CITY.$N.$S/25

LAN_ADR=$NW.$CITY.$N.$(( S + 1 ))
LAN_IP=$NW.$CITY.$N.$(( S + 1 ))/26
LAN_IP_1ST=$NW.$CITY.$N.$(( S + 2 ))/26
LAN_PRE=26
LAN_DHCP_PRE=26
LAN_DHCP_NUM=40
LAN_DHCP_LEASETIME=12h

WAN_ADR=$NW.$CITY.$N.$(( S + 61 ))
WAN_PRE=30
WAN_IP=$NW.$CITY.$N.$(( S + 61 ))/30

WIFI_ADR=$NW.$CITY.10.$NODE_NUMBER
WIFI_IP=$NW.$CITY.10.$NODE_NUMBER/8
WIFI_IP_1ST=$NW.$CITY.$NODE_NUMBER.97
WIFI_PRE=8
WIFI_DHCP_PRE=28
WIFI_DHCP_NUM=14
WIFI_DHCP_LEASETIME=2h

DHCP_LAN="$NW.$CITY.$NODE_NUMBER.$(( S + 2 ))/26,40,12h"
DHCP_WIFI="$NW.$CITY.$NODE_NUMBER.97/28,14,2h"
# ---
FFF_CITY=$CITY
FFF_NET=$NW
FFF_NODE=$NODE_NUMBER
FFF_HNA=$NW.$CITY.$N.$S/25
LANADR=$NW.$CITY.$N.$(( S + 1 ))
LAN1ST=$NW.$CITY.$N.$(( S + 2 ))
LANMSK=255.255.255.192
LANBRC=$NW.$CITY.$N.$(( S + 63 ))
LANNET=$NW.$CITY.$N.$S
LANPRE=26
LANDHCPSTART=$(( S + 2 ))
LANDHCPNUM=40
WIFIADR=$NW.$CITY.10.$NODE_NUMBER
WIFI1ST=$NW.$CITY.$NODE_NUMBER.97
WIFIMSK=255.255.255.240
WIFIBRC=$NW.$CITY.$N.111
WIFINET=$NW.$CITY.$N.96
WIFIPRE=28
WANADR=$NW.$CITY.$N.61
WAN1ST=$NW.$CITY.$N.62
WANMSK=255.255.255.252
WANBRC=$NW.$CITY.$N.63
WANNET=$NW.$CITY.$N.60
WANPRE=30
WIFIDHCPSTART=$NW.$CITY.$N.98
WIFIDHCPNUM=14
WIFIVPNSERVERADR=$NW.$CITY.$N.110
WIFIVPNCLIENTADR=$NW.$CITY.$N.109
WIFIVPNNET=$NW.$CITY.$N.108
WIFIVPNBRC=$NW.$CITY.$N.111
WIFIVPNPRE=30
ROAMING_IP4=172.31.$CITY.$NW
ROAMING_PRE=24
EOF
}

func_ipsystem_ffweimar ()		# ARG1: - empty       -> has_nodenumber? -> output for my nodenumber
{					#  	- "random" or empty && no_nodenumber?  -> output for random nodenumber
	local NODE_NUMBER="$1"		#       - IP-address  -> output nodenumber
	local CITY="63"			#	- node-number -> output for this nodenumber, return 1 if not in range
	local NW="10"
	local RANGE_START="2"
	local RANGE_END="1020"
	local RANGE_FIRST_RANDOM="970"

	  if [ -z "$NODE_NUMBER" ]; then
		NODE_NUMBER="$( nvram get fff_node_number )"
		[ -z "$NODE_NUMBER" ] && NODE_NUMBER=$( func_get_random_value $RANGE_FIRST_RANDOM $RANGE_END )
	elif [ "$NODE_NUMBER" = "random" ]; then
		NODE_NUMBER=$( func_get_random_value $RANGE_FIRST_RANDOM $RANGE_END )
	elif [ "$( echo $NODE_NUMBER | sed 's/[^\.]//g' )" = '...' ]; then	# is IPv4
		
		eval $(echo $NODE_NUMBER|sed -n 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/local OCT1=\1\nlocal OCT2=\2\nlocal OCT3=\3\nlocal OCT4=\4/p')

		[ $OCT1 -eq $NW ] && [ $OCT2 -eq $CITY ] && {
		     	  if [ $OCT4 -gt 191 ]; then echo $(( $OCT3 + 765 ))
			elif [ $OCT4 -gt 127 ]; then echo $(( $OCT3 + 510 ))
			elif [ $OCT4 -gt  63 ]; then echo $(( $OCT3 + 255 ))
			else 			     echo     $OCT3; fi
			return 0
		}
		return 1
		
	fi
	
	if [ 2>/dev/null "$NODE_NUMBER" -ge $RANGE_START -a "$NODE_NUMBER" -le $RANGE_END ]; then
			
		local S=0			# subnetstart 	e.g. network.city.100.${S}
		local N=$NODE_NUMBER		# nodenumber_id	e.g. network.city.${N}.0
		local RANDOM=false
		
		  if [ "$NODE_NUMBER" -ge $RANGE_FIRST_RANDOM ]; then
			N=$(( $NODE_NUMBER - 765 ))
			S=192
			RANDOM=true
		elif [ "$NODE_NUMBER" -gt 765 ]; then
			N=$(( $NODE_NUMBER - 765 ))
			S=192
		elif [ "$NODE_NUMBER" -gt 510 ]; then
			N=$(( $NODE_NUMBER - 510 ))
			S=128
		elif [ "$NODE_NUMBER" -gt 255 ]; then
			N=$(( $NODE_NUMBER - 255 ))
			S=64
		fi
	else
		return 1
	fi

	cat<<EOF
NODE_NUMBER=$NODE_NUMBER
NODE_NUMBER_RANDOM=$RANDOM
OLSR_HNA=$NW.$CITY.$N.$S/26

LAN_ADR=$NW.$CITY.$N.$(( S + 33 ))
LAN_IP=$NW.$CITY.$N.$(( S + 33 ))/27
LAN_IP_1ST=$NW.$CITY.$N.$(( S + 34 ))/27
LAN_PRE=27
LAN_DHCP_PRE=27
LAN_DHCP_NUM=29
LAN_DHCP_LEASETIME=12h

WAN_ADR=$NW.$CITY.$N.$(( S + 25 ))
WAN_PRE=30
WAN_IP=$NW.$CITY.$N.$(( S + 25 ))/30

WIFI_ADR=$NW.$CITY.$N.$(( S + 1 ))
WIFI_IP=$NW.$CITY.$N.$(( S + 1 ))/8
WIFI_IP_1ST=$NW.$CITY.$N.$(( S + 2 ))
WIFI_PRE=8
WIFI_DHCP_PRE=28
WIFI_DHCP_NUM=13
WIFI_DHCP_LEASETIME=2h

DHCP_LAN="$NW.$CITY.$N.$(( S + 34 ))/27,29,12h"
DHCP_WIFI="$NW.$CITY.$N.$(( S + 2 ))/28,13,2h"
# ---
FFF_CITY=$CITY
FFF_NET=$NW
FFF_NODE=$NODE_NUMBER
FFF_HNA=$NW.$CITY.$N.$S/26
LANADR=$NW.$CITY.$N.$(( S + 33 ))
LAN1ST=$NW.$CITY.$N.$(( S + 34 ))
LANMSK=255.255.255.224
LANBRC=$NW.$CITY.$N.$(( S + 63 ))
LANNET=$NW.$CITY.$N.$(( S + 32 ))
LANPRE=27
LANDHCPSTART=$(( S + 34 ))
LANDHCPNUM=29
WIFIADR=$NW.$CITY.$N.$(( S + 1 ))
WIFI1ST=$NW.$CITY.$N.$(( S + 2 ))
WIFIMSK=255.255.255.224
WIFIBRC=$NW.$CITY.$N.$(( S + 31 ))
WIFINET=$NW.$CITY.$N.$S
WIFIPRE=27
WANADR=$NW.$CITY.$N.$(( S + 25 ))
WAN1ST=$NW.$CITY.$N.$(( S + 26 ))
WANMSK=255.255.255.252
WANBRC=$NW.$CITY.$N.$(( S + 27 ))
WANNET=$NW.$CITY.$N.$(( S + 24 ))
WANPRE=30
WIFIDHCPSTART=$NW.$CITY.$N.$(( S + 2 ))
WIFIDHCPNUM=13
WIFIVPNSERVERADR=$NW.$CITY.$N.$(( S + 30 ))
WIFIVPNCLIENTADR=$NW.$CITY.$N.$(( S + 29 ))
WIFIVPNNET=$NW.$CITY.$N.$(( S + 28 ))
WIFIVPNBRC=$NW.$CITY.$N.$(( S + 31 ))
WIFIVPNPRE=30
ROAMING_IP4=172.31.$CITY.$NW
ROAMING_PRE=24
EOF
}

func_conf ()		# e.g. func_conf boot_watchdog && start_bootwatchdog (OUT=bool)
{			# e.g. func_conf show_all -> list (value short_desc long_desc)

	local P=1

	[ "$1" = "show_all" ] && {
		while func_conf $P info; do {
			P=$(( $P + 1 ))
		} done
		return 0
	}
	
	local VAR="fff_extensions"
	local VALUE="$( nvram get $VAR )"
	local I="no description available"
	local S="short_description"
	
	case $1 in
		      speedtest|1)  P=1  ; S="speedtest"       ; I="Alle 40 Minuten wird von einem zufaelligem Nachbarn 10 fuer Sekunden ein Testdownload gemacht. Diese Werte dienen als Berechnungsgrundlage fuer ein Bandbreitenabhaengiges Routing." ;;
		 	adblock|2)  P=2  ; S="adblock"         ; I="Ueber eine systemweite DNS-Liste ('/etc/local.hosts') werden bekannte Werbebanner geschluckt (zurueckgewiesen). Weniger Datenverkehr und schnelleres surfen im Web." ;;
		 firmwareupdate|3)  P=3  ; S="firmwareupdate"  ; I="Automatisches Firmwareupdate, je nach Einstellung." ;;
		lazy_wired_olsr|4)  P=4  ; S="lazy_wired_olsr" ; I="Auf allen Netzwerkschnittstellen, auf denen kein OLSR-Partner zu hoeren ist, wird OLSR abgeschaltet. Alle 15 Stunden wird neu ueberprueft." ;;
		  boot_watchdog|5)  P=5  ; S="boot_watchdog"   ; I="Sollte 10 Minuten nach dem Boot-Vorgang kein OLSR laufen, werden alle Partitionen neu formatiert und nochmal gestartet." ;;
		     layer7_qos|6)  P=6  ; S="layer7_qos"      ; I="Die gaengigsten Protokolle (HTTP,FTP,...) werden auf Layer7-Basis erkannt, markiert und entsprecht der Wichtigkeit priorisiert." ;;
		    no_wifi_nat|7)  P=7  ; S="no_wifi_nat"     ; I="Das maskieren der WLAN-Klienten wird deaktivert. Dazu muss der WLAN-Bereich per OLSR-HNA4 angekuendigt werden." ;;
		     splashpage|8)  P=8  ; S="splashpage"      ; I="Alle Benutzer sehen, wenn sie das interne Netzwerk verlassen eine Infoseite, die " ;;
		   smart_ethers|9)  P=9  ; S="smart_ethers"    ; I="Es koennen MAC-Adressen eingegeben werden, die " ;;
		   boot_telnetd|10) P=10 ; S="boot_telnetd"    ; I="Waehrend der ersten 10 Minuten des Startvorgangs ist zusaetzlich zum SSH-Login auch ein telnet-Login ohne Passwort moeglich." ;;
		    auto_config|11) P=11 ; S="auto_config"     ; I="Beim Bootvorgang werden automatisch alle Einstellungen vorgenommen, es sei denn, dies wurde schonmal getan." ;;
	         olsr_whitelist|12) P=12 ; S="olsr_whitelist"  ; I="Nur von zentral in einer 'whitelist' eingetragenen Netzknoten (MAC/IP-Kombination) werden OLSR-Pakete akzeptiert. Damit gibt es weniger Konfigurationsfehler. Diese Liste wird alle 10 Stunden optimiert." ;;
		  auto_software|13) P=13 ; S="auto_software"   ; I="Abhaengig von Speicherplatz und gewuenschter Funktionalitaet werden automatisch nach dem flashen brauchbare Software-Pakete nachinstalliert." ;;
		      nud_neigh|14) P=14 ; S="nud_neigh"       ; I="Alle OLSR-Nachbarn werden permanent in die Kernel-NUD-Liste eingetragen." ;;
		      nud_local|15) P=15 ; S="nud_local"       ; I="Lokal bekannte Benutzer werden permanent in die Kernel-NUD-Liste eingetragen." ;;
		       mesh_rdf|16) P=16 ; S="mesh_rdf"        ; I="Alle 15 Minuten werden Statusinformationen dieses Netzknotens local gespeichert und in zufaelligen Abstaenden zu einem zentralen Server gesendet" ;;
                     accounting|17) P=17 ; S="accounting"      ; I="Es kann eine Liste aller Benutzer abgefragt werden, die auf diesem Netzknoten irgendwie Datenverkehr verursacht haben." ;;
	                 ic_vpn|18) P=18 ; S="ic_vpn"          ; I="Ist ein lokaler Internetzugang vorhanden, wird automatisch am Intercity-VPN teilgenommen. Dabei werden Funkwolken ueber VPN gekoppelt." ;;
                  system_checks|19) P=19 ; S="system_checks"   ; I="Alle 15 Minuten werden die wichtigen Dienste auf korrekte Funktionalitaet geprueft und neugestartet, wenn noetig." ;;
                      check_mac|20) P=20 ; S="check_mac"       ; I="Alle MAC-Adressen dieses Geraets werden beim Start geprueft. Sollte eine ungueltige festgestellt werden, wird dies korrigiert." ;;
				 *) P=0
		;;
	esac

	VAR="$(echo -n $VALUE | cut -b$P)"

	[ "$2" = "info" ] && {
		[ $P -eq 0 ] && return 1
		echo "local VALUE='$VAR';local DESC_SHORT='$S'; local DESC_LONG='$I'"
		return 0
	}

	[ 2>/dev/null "$VAR" -gt 0 ] && return 0
	return 1
}
