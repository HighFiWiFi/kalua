# ToDo:
# option einbauen, um einen task zu einer bestimmten Uhrzeit in der Zukunft ausfuehren zu lassen,
# z.b. +werbefilter-liste_update in 24h

_scheduler_vars ()
{
	FILE_SCHEDULER_TMP="/tmp/scheduler_queue_tmp_"		# scheduler_add() appends an counter to filename
	FILE_SCHEDULER="/tmp/scheduler_queue"			# HINT: it is also possible to (scp-)upload a file
	FILE_SCHEDULER_COPY="/tmp/scheduler_queue_copy"		#       called ${FILE_SCHEDULER_TMP}xyz for automatic
}								#       execution on many devices...

_scheduler_queue_purge ()
{
	_log do purge_queues daemon info "removing"
	_scheduler vars
	rm $FILE_SCHEDULER_TMP* $FILE_SCHEDULER $FILE_SCHEDULER_COPY 2>/dev/null
}

_scheduler_queue_list ()
{
	_scheduler vars
	
	local FUNC="scheduler_list_queue"

	_log do $FUNC daemon debug "working"

	echo "# actual,running queue:"
	cat $FILE_SCHEDULER_COPY 2>/dev/null || echo -en "# empty!\n\n"
	
	echo -en "\n# waiting queue:\n"
	cat ${FILE_SCHEDULER_TMP}* 2>/dev/null || echo -en "# empty!\n\n"
}

_scheduler_print_usage ()
{
	local FUNC="scheduler_print_usage"
	
	_log do $FUNC daemon info "working"

	cat <<EOF
 
Sens:	 Adds program calls to a queue and executes all
	 these calls step by step. This prevents high
	 cpu-load and/or memory-consumption, but is not
	 executed at an exact timestamp.
 
Usage:	 $0 -option1 -option2 -optionN
 
Options: -a "TASK"   adds an TASK to queue, where TASK can be keyword
	 -A "TASK"   immediately runs TASK, does not respect cpu-load
	 -r          runs the queue, step by step
	 -s "SEC"    sleeps for SEC seconds
	 -l          lists running and waitung queue
	 -p	     purge all queues
	 -o	     special: checks for incoming olsr-packets and
		     restarts daemon with new conf if neccessary
 
Example: $0 -s3 -a do_this -a do_that -r -a do_another_thing -r
 
	 This invokes a sleep for 3 seconds,
	 adds "do_this" to queue, then adds "do_that" to queue, then
	 runs the queue, then adds an user-defined program call to
	 queue, then runs the queue. Keywords must be defined in
	 _scheduler(). Ofcourse you should only use the queue, if
	 exact executing-time of your program does'nt really matter.
 
	 $0 -A "program1 arg1" -a "program2 arg1 arg2" -l
 
	 This immediately start "program1" with "arg1", than adds an
	 user-defined programm call with args and then lists all queues.
 
EOF
}

_scheduler_task2command ()
{
	local FUNC="scheduler_task2command"
	local TASK="$1"
	local COMMAND
	
	case "$TASK" in
			   rrdhelper)	pidof rrdcollect >/dev/null || return 1
			   		COMMAND=". /tmp/loader; _wifi rrdhelper $WIFIDEV" ;;
	    splash4nonautounsplashed)   COMMAND=". /tmp/loader; _pfilter user_splash_add_for_nonautounsplashed" ;;
		    optimize_txpower)	COMMAND="/usr/sbin/cron.optimize_wifi_txpower" ;;
			  monitoring)	COMMAND="/usr/sbin/cron.monitoring" ;;
		    upgrade_packages)	_scheduler check_if_every_Nth_minute 360 upgrade_packages || return 1
		    			COMMAND="/usr/sbin/cron.upgrade_packages" ;;
	       watch_hanging_command)	COMMAND="/etc/init.d/S69watch_olsrd_fff+ watch_hanging_command" ;;
		    software_install)   COMMAND="/etc/init.d/S71auto_software_update_fff+ call" ;;
	            build_accounting)   COMMAND="wget -qO /tmp/accounting.tmp 'http://127.0.0.1/cgi-bin-tool_fff+?OPT=accounting&GUI=1'; mv /tmp/accounting.tmp /tmp/accounting.html" ;;
		  recheck_wired_olsr)	COMMAND="/etc/init.d/S99an_olsr_dev_check_fff+ recheck" ;;
	  whitelist_update_every_15h)   _scheduler_check_if_every_Nth_minute 891 whitelist_update || return 1
	  				COMMAND="/etc/local.fw-fff+ olsr_whitelist_update" ;;
	  whitelist_rebuild_every_3h)   _scheduler_check_if_every_Nth_minute 173 whitelist_rebuild || return 1
	  				COMMAND="/etc/local.fw-fff+ olsr_whitelist_optimize" ;;
	       speedtest_every_40min)   _scheduler_check_if_every_Nth_minute 40 speedtest || return 1
	       				COMMAND="/www/cgi-bin-speed r" ;;
		        restart_olsr) 	COMMAND=". /tmp/loader; _olsr daemon restart olsrd_restart_scheduler_controlled" ;;
		         1min_checks) 	COMMAND="/usr/sbin/cron.minutely" ;;
		        15min_checks)  	COMMAND="/etc/init.d/S69watch_olsrd_fff+" ;;
		     	 restart_vpn)	COMMAND="/etc/init.d/S52vpn_fff+ restart" ;;
		           1h_checks)	COMMAND="/usr/sbin/cron.hourly"; >/tmp/SEND_ALIVE_FAILED ;;
		          24h_checks)	COMMAND="/usr/sbin/cron.daily; /etc/init.d/S51crond_fff+ restart" ;;
	       	      fwupdate_check) 	COMMAND="/etc/init.d/S01firmware_update_fff+ check" ;;
		       gateway_check)	COMMAND="/usr/sbin/cron.check_inet_gw_fff+" ;;	
		user_traff_broadcast)	COMMAND="/etc/local.fw-fff+ showuser_traff quiet spread randomwait" ;;
		    user_traff_reset)	COMMAND="/etc/local.fw-fff+ reset_all_daily_user_counters" ;;
		kick_user_over_limit)	COMMAND="/etc/local.fw-fff+ kickoverlimituser" ;;
		       kick_user_all)   COMMAND="/etc/local.fw-fff+ kickalluser" ;;
	   			 vds)	COMMAND="/usr/sbin/cron.evaluate_ulogd_syslogemu_fff+" ;;
	      build_service_announce)   COMMAND="/etc/init.d/S52build_services_fff+ start" ;;
	    rebuild_service_announce)   COMMAND="/etc/init.d/S52build_services_fff+ update" ;;
	    start_local_packetfilter)   COMMAND="/etc/local.fw-fff+ call" ;;
		      startup_helper)	COMMAND="/etc/init.d/S72filter_fff+ call" ;;
				   *)

					extract_function_name ()
					{
						echo "$1" | cut -d'_' -f2 | cut -d' ' -f1	# "_sms_send bla" -> "sms"
					}							# "_sms send bla" -> "sms"

				   	is_function ()
				   	{
				   		type "_$( extract_function_name \"$1\" )" >/dev/null && return 0
				   	}

					case "$TASK" in
						_*)
							is_function "$TASK" && {
								COMMAND=". /tmp/loader; _$( extract_function_name \"$TASK\" ) include; $TASK"
								TASK=
							}
						;;
						*)
							COMMAND="$TASK"
							TASK=
						;;
					esac	

				        _log do $FUNC daemon debug "user defined: '$COMMAND'"
				;;
	esac
	
	echo "$COMMAND"
}

_scheduler_add ()
{
	_scheduler vars
	
	local TASK="$1"
	local KEYWORD="$2"
	local COMMAND COUNTER
	      COMMAND="$( _scheduler task2command "$TASK" )" || return
	local FUNC="scheduler_add"

	if [ "$KEYWORD" = "move2top" ]; then		# insert on top, if not already in waiting_queue

		cat ${FILE_SCHEDULER_TMP}1000* 2>/dev/null | head -n1 | grep -q ^"$COMMAND" && {
		
			_log do $FUNC daemon debug "$KEYWORD - PID: '$$' - '$TASK' - already in queue, ignoring"
			return
		}
		
		COUNTER="$(( 1000000000 + $$ ))"
	else
		grep -sq ^"$COMMAND" ${FILE_SCHEDULER_TMP}* $FILE_SCHEDULER_COPY && {
	
			_log do $FUNC daemon debug "PID:'$$' - '$TASK' - already in queue, ignoring"
			return
		}
		
		COUNTER="$( _system date unixtime )"	# we need a monotonic + always_same_length-counter here, so better not use $$ (process-id)
	fi						# this is only true from 2001-Sep-10 ... 2038-Jan-19
	
	_log do $FUNC daemon debug "PID:'$$' +'$TASK'"
	echo "$COMMAND   # $TASK" >>${FILE_SCHEDULER_TMP}${COUNTER}
}

_scheduler_check_if_every_Nth_minute ()
{
	# some tasks should be repeated regulary, but NOT on the same
	# time on every node in the mesh. so we need a way the schedule
	# a script every X minutes based on uptime and not on daytime,so:
	# check every min, if uptime is divisor of X (without a rest)

	local UPTIME="$( _system uptime min )"	# e.g. uptime = 60 and
	local CARRYOVER="$(( $UPTIME % $1 ))"	# e.g. every = 55 min : 60 % 55 = 5 
	
	[ "$CARRYOVER" -eq 0 ] && {
		_log do scheduler_check_if_every_Nth_minute daemon debug "call '$2' for ${1}th minute, uptime: $UPTIME"
		return 0
	}

	return 1
}

_scheduler_wait_till_cpuload_is_low ()
{
	_system include

	local WAITING_TASK="$1"
	local FUNC="scheduler_wait_till_cpuload_is_low"
	local CPU_LOAD="$( _system load 1min )"
	local TARGET=60
	local WAIT

	echo >/dev/misc/crondog				# fixme! cron.minutely should do this
	
	while [ ${CPU_LOAD:=100} -gt $TARGET ]; do {
		WAIT=$(( 5 + ($CPU_LOAD - $TARGET) / 2 ))
		[ ${WAIT:=100} -gt 300 ] && WAIT=300
		
		_log do $FUNC daemon debug "PID:'$$' - load >=0.$TARGET ($CPU_LOAD) - waiting $WAIT sec (for '$WAITING_TASK')"
		
		TARGET=$(( $TARGET + 1 ))
		sleep $WAIT
		CPU_LOAD="$( _system load 1min )"
		echo >/dev/misc/crondog			# fixme! cron.minutely should do this
	} done
}

_scheduler_run ()
{
	_scheduler vars
	
	local FUNC="scheduler_run"
	local FILE LINE
	local LOCKFILE="/tmp/lockfile_scheduler_is_running"

	[ -e $LOCKFILE -o "$( _system uptime min )" -lt 5 ] && {
		_log do $FUNC daemon debug "already running or low uptime - ignoring call"
		return 1
	}

	_cleanup ()
	{
		rm $LOCKFILE
		_log do $FUNC daemon info "cleanup called during '$LINE'"
		exit 1
	}

	trap "_cleanup" SIGINT				# SIGINT = CTRL+C, SIGHUP/SIGTERM?
	touch $LOCKFILE
							# this builds the running queue from temp_queue
	for FILE in ${FILE_SCHEDULER_TMP}*; do {
		while read LINE; do {
			_log do $FUNC daemon debug "fetching '$LINE' from file '$FILE'"
			echo "$LINE" >>$FILE_SCHEDULER
		} done <$FILE
		rm $FILE
	} done
	cp $FILE_SCHEDULER $FILE_SCHEDULER_COPY		# for checking of DUPs in running queue -> scheduler_add()
	
	while read LINE; do {

		_scheduler wait_till_cpuload_is_low "$LINE"

		_log do $FUNC daemon debug "running '$LINE'"
		echo "$LINE" >$LOCKFILE
		/bin/sh -c "$LINE"
		_log do $FUNC daemon debug "ready '$LINE'"
		
		pidof crond >/dev/null || /etc/init.d/S51crond_fff+ restart

	} done <$FILE_SCHEDULER
	
	rm $FILE_SCHEDULER $FILE_SCHEDULER_COPY $LOCKFILE
}
