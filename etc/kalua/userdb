# fixme! email fuer tickets.pdf?
# fixme! free_intranet? 
# fixme! _userdb profile_lastid() + wenn man loescht luecken auffuellen?
# fixme! profile-flag: fuzzy login allowed?

_userdb_backup ()	# fixme! automatically call this after <prio> changes
{
	local FUNC="userdb_backup"
	local FILE="/www/cgi-bin/userdata_backup.tgz"

	if tar czf "$FILE" /tmp/USERDB ; then
		_log do $FUNC daemon info "[ok]"
	else
		_log do $FUNC daemon alert "[err]"
	fi
}

_userdb_restore ()	# fixme! automatically call this after reboot
{
	local FUNC="userdb_restore"
	local FILE="/www/cgi-bin/userdata_backup.tgz"

	if [ -e "$FILE" ]; then
	
		_log do $FUNC daemon info "unarc of '$FILE'"
		rm -fR /tmp/USERDB

		if tar -C / -xzf "$FILE" ; then
			_log do $FUNC daemon info "[ok]"
		else
			_lgo do $FUNC daemon alert "[err]"
		fi
	else
		_log do $FUNC daemon info "[err] '$FILE' not found"
	fi
}

_userdb_query ()
{
	local QUERY="$1"
	local KEYWORD1="$2"
	local KEYWORD2="$3"
	local ID USERNAME PASSWORD

	case "$QUERY" in
		login_exist)
			for ID in $( _userdb login list ); do {
				eval $( _userdb login show $ID "USERNAME PASSWORD" )
				[ "$USERNAME" = "$KEYWORD1" -a "$PASSWORD" = "$KEYWORD2" ] && {
					echo $ID
					return 0
				}
			} done
			return 1
		;;
	esac

	# samples:
	# query_login_valid? (return % of used time/traffic?)
	# update_device_traffic
	# update_device_time
}

_userdb_stats ()
{
	local TABLE
	
	for TABLE in profile login device; do {
		
		echo "TABLE: '$TABLE'"
		
		if [ -n "$( _userdb $TABLE list )" ]; then
			_userdb $TABLE list
		else
			echo "# empty table '$TABLE'"
		fi
	} done
}

_userdb_profile ()			# idea: allow configurable UPnP, P2P, QOS, ROAMING?
{
	local ACTION="$1"		# ARG1: string -> <empty>, add, del, list, update, id2name, name2id
	
	local DIR="/tmp/USERDB/PROFILE"
	local FUNC="userdb_profile"
	local ELEMENT VALUE
	local ELEMENT_LIST="NAME COMMENT AUTOGENERATE TIME_MODEL MAX_TIME MAX_TRAFFIC MAX_SPEED_UP MAX_SPEED_DOWN LANDING_URL COST CURRENCY"
	
	local ID			# autoincrement
	local NAME
	local COMMENT
	local AUTOGENERATE		# [bool]
	local TIME_MODEL		# [bool] used_time = unset/0 - passed_time = 1
	local MAX_TIME			# [min] -> autogenerate some keywords?, e.g. 1week, 24h, 1month ...
	local MAX_TRAFFIC		# [kb]
	local MAX_SPEED_UP		# [kb/s]
	local MAX_SPEED_OWN		# [kb/s]	// empty on MAX_* means: nolimit/unlimited
	local LANDING_URL
	local COST
	local CURRENCY			# ?

	case "$ACTION" in
		"")
			echo "Usage: _$FUNC	add <name> <comment> <autogenerate=0|1> <time_model=0|1=used/passed> <max_time> <tim<max_traffic> <max_speed_up> <max_speed_down> <landing_url> <cost> <currency>"
			echo "			update <id> <same_args_like_add>"
			echo "			del <id>"
			echo "			show <id> <specific_elements>"
			echo "			list"
			echo "			id2name <id>"
			echo "			name2id <name>"
		;;
		add|update)
			if [ "$ACTION" = "update" ]; then			# fixme! don't touch values, if "=" is given
				ID="$2"
				[ -z "$ID" ] && return
				shift
			else
				read ID 2>/dev/null <"$DIR/meta_maxid"
				ID="$(( ${ID:-0} + 1 ))"			# autoincrement
				mkdir -p "$DIR"
				echo -n >"$DIR/meta_maxid" "$ID"
			fi

			NAME="${2:-unset_name_$$}"
			COMMENT="$3"
			AUTOGENERATE="$4"
			TIME_MODEL="$5"
			MAX_TIME="$6"
			MAX_TRAFFIC="$7"
			MAX_SPEED_UP="$8"
			MAX_SPEED_DOWN="$9"
			LANDING_URL="${10}"
			COST="${11}"
			CURRENCY="${12}"		# ${13}

			_log do $FUNC daemon info "$ACTION - ID: $ID NAME: $NAME COMMENT: $COMMENT AUTOGENERATE: $AUTOGENERATE TIME_MODEL: $TIME_MODEL MAX_TIME: $MAX_TIME MAX_TRAFFIC: $MAX_TRAFFIC MAX_SPEED_UP: $MAX_SPEED_UP MAX_SPEED_DOWN: $MAX_SPEED_DOWN LANDING_URL: $LANDING_URL COST: $COST CURRENCY: $CURRENCY"

			mkdir -p "$DIR/$ID"					# each profile has it own dir
			for ELEMENT in $ELEMENT_LIST; do {
				eval "VALUE=\"\$${ELEMENT}\""
				echo -n >"$DIR/$ID/$ELEMENT" "$VALUE"
			} done
		;;
		del)
			ID="${2:-is_unset}"
			[ -d "$DIR/$ID" ] || return 1
			_log do $FUNC daemon info "$ACTION - removing ID '$ID'"
			rm -fR "$DIR/$ID"					# fixme! check, if referenced in logins
		;;
		show)
			ID="${2:-is_unset}"
			OPTION="$3"
			[ -d "$DIR/$ID" ] || return 1
			[ -n "$OPTION" ] && ELEMENT_LIST="$OPTION"
			echo "ID='$ID'"
			for ELEMENT in $ELEMENT_LIST; do {
				read VALUE <"$DIR/$ID/$ELEMENT"
				echo "$ELEMENT='$VALUE'"
			} done
		;;
		list)
			[ -d "$DIR" ] || return 1
			ls -1 "$DIR" 2>/dev/null | grep ^[0-9] | sort -n
		;;
		id2name)
			ID="$2"
			cat 2>/dev/null "$DIR/$ID/NAME" || return 1
		;;
		name2id)
			[ 2>/dev/null "${2:-unset}" -gt 0 ] && { 		# is_numeric? -> already ID
				[ -e "$DIR/$2/NAME" ] || return 1
				echo $2
				return 0
			}
			
			for FILE in $( find "$DIR" -type d ); do {
				[ -e "$FILE/NAME" ] && {
					read NAME <"$FILE/NAME"
					
					[ "$NAME" = "${2:-$NAME}" ] && {	# empty 'name' means: output any/first profile_name
						basename $FILE
						return
					}
				}
			} done
		;;
	esac
}

_userdb_device ()
{
	local ACTION="$1"
	local DIR="/tmp/USERDB/DEVICE"
	local FUNC="userdb_device"
	local ELEMENT VALUE
	local ELEMENT_LIST="USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION"

	local ID			# autoincrement
	local USER_ID
	local MAC			# lowercase + : e.g. 00:11:22:aa:bb:cc
	local DEVTYPE			# wifi, wire
	local LANG			# like i18n
	local FIRSTSEEN			# [unixtime]
	local LASTSEEN			# [unixtime]
	local USED_TRAFFIC		# [kb]
	local USED_TIME			# [min]
	local USED_TRAFFIC_TODAY	# [kb]
	local USED_TIME_TODAY		# [min]
	local ISOLATION			# [bool]

	case "$ACTION" in
		"")
			echo "Usage: _$FUNC	add <user_id> <mac> <devtype> <language> <firstseen> <lastseen> <used_traffic> <used_time> <used_traffic_today> <used_time_today> <isolation>"
			echo "			update <id> <same_args_like_add>"
			echo "			del <id>"
			echo "			show <id>"
			echo "			list"
		;;
		add|update)
			if [ "$ACTION" = "update" ]; then			# fixme! don't touch values, if "=" is given
				ID="$2"
				shift
			else
				read ID 2>/dev/null <"$DIR/meta_maxid"
				ID="$(( ${ID:-0} + 1 ))"			# autoincrement
				mkdir -p "$DIR"
				echo -n >"$DIR/meta_maxid" "$ID"
			fi

			USER_ID="$2"
			MAC="$3"
			DEVTYPE="$4"						# just for stats
			LANG="$5"						# empty means fallback to default lang, e.g. in weblogin
			FIRSTSEEN="$8"						# should be empty, if never seen
			LASTSEEN="$7"						# should be empty, if never seen
			USED_TRAFFIC="$8"
			USED_TIME="$9"
			USED_TRAFFIC_TODAY="${10}"
			USED_TIME_TODAY="${11}"
			ISOLATION="${12}"

			_log do $FUNC daemon info "$ACTION - ID: $ID USER_ID: $USER_ID MAC: $MAC DEVTYPE: $DEVTYPE LANG: $LANG FIRSTSEEN: $FIRSTSEEN LASTSEEN: $LASTSEEN USED_TRAFFIC: $USED_TRAFFIC USED_TIME: $USED_TIME USED_TRAFFIC_TODAY: $USED_TRAFFIC_TODAY USED_TIME_TODAY: $USED_TIME_TODAY ISOLATION: $ISOLATION"

			mkdir -p "$DIR/$ID"					# each profile has it own dir
			for ELEMENT in $ELEMENT_LIST; do {
				eval "VALUE=\"\$${ELEMENT}\""
				echo -n >"$DIR/$ID/$ELEMENT" "$VALUE"
			} done
		;;
		del)
			ID="${2:-is_unset}"
			[ -d "$DIR/$ID" ] || return 1
			_log do $FUNC daemon info "$ACTION - removing ID '$ID'"
			rm -fR "$DIR/$ID"
		;;
		show)
			ID="${2:-is_unset}"
			[ -d "$DIR/$ID" ] || return 1
			echo "ID='$ID'"
			for ELEMENT in $ELEMENT_LIST; do {
				read VALUE <"$DIR/$ID/$ELEMENT"
				echo "$ELEMENT='$VALUE'"
			} done
		;;
		list)
			[ -d "$DIR" ] || return 1
			ls -1 "$DIR" 2>/dev/null | grep ^[0-9] | sort -n
		;;
	esac
}

_userdb_login_autocreate ()
{
	local PROFILE="$1"			# name or ID
	local COUNTER="${2:-35}"		# 35 are fitting on 1 PDF (A4-sheet)
	local I=0
	local UNIXTIME="$( _system date unixtime )"
	
	while [ $I -lt $COUNTER ]; do {
		I=$(( $I + 1 ))
		_userdb login add "$1" "" "" "" "1" "$UNIXTIME"
	} done
}

_userdb_login ()
{
	local ACTION="$1"		# ARG1: string -> <empty>, add, del, list, update, gen_index
	local DIR="/tmp/USERDB/LOGIN"
	local FUNC="userdb_login"
	local ELEMENT VALUE	
	local ELEMENT_LIST="PROFILE_ID COMMENT USERNAME PASSWORD DEVICE_QUANTITY INSTALLED"

	local ID			# autoincrement
	local PROFILE_ID
	local COMMENT
	local USERNAME			# namespace from mydesign or explicit
	local PASSWORD
	local DEVICE_QUANTITY		# how many
	local INSTALLED			# [unixtime]

	case "$ACTION" in
		"")
			echo "Usage: _$FUNC	add <profile_id> <comment> <username> <password> <device_quantity> <installed_unixtime>"
			echo "			update <id> <plus_same_args_like_add>"
			echo "			del <login_id>"
			echo "			show <id>"
			echo "			list"
			echo "			index_gen | index_show"
		;;
		add|update)							# fixme! also save ID in $DIR ?
			if [ "$ACTION" = "update" ]; then			# fixme! don't touch values, if "=" is given
				ID="$2"
				[ -z "$ID" ] && return 1
				shift
			else
				read ID 2>/dev/null <"$DIR/meta_maxid"
				ID="$(( ${ID:-0} + 1 ))"			# autoincrement
				mkdir -p "$DIR"
				echo -n >"$DIR/meta_maxid" "$ID"
			fi

			PROFILE_ID="$2"
			if [ -z "$PROFILE_ID" ]; then
				for PROFILE_ID in $( _userdb profile list ); do break; done	# fetch first ID
			else
				PROFILE_ID="$( _userdb profile name2id "$2" )" || return 1	# name -> autoconvert to ID
			fi

			COMMENT="$3"
			USERNAME="${4:-$( _random_username do )}"
			PASSWORD="${5:-$( _math random_integer 1 99999 fillup )}"
			DEVICE_QUANTITY="$6"						# empty means /nolimit/
			INSTALLED="${7:-$( _system date unixtime)}"

			_log do $FUNC daemon info "$ACTION - ID: $ID PROFILE_ID: $PROFILE_ID COMMENT: $COMMENT USERNAME: $USERNAME PASSWORD: $PASSWORD DEVICE_QUANTITY: $DEVICE_QUANTITY INSTALLED: $INSTALLED"

			mkdir -p "$DIR/$ID"					# each login has it own dir

			for ELEMENT in $ELEMENT_LIST; do {
				eval "VALUE=\"\$${ELEMENT}\""
				echo -n >"$DIR/$ID/$ELEMENT" "$VALUE"
			} done
		;;
		del)
			ID="${2:-is_unset}"
			[ -d "$DIR/$ID" ] || return 1
			_log do $FUNC daemon info "$ACTION - removing ID '$ID'"
			rm -fR "$DIR/$ID"
		;;
		show)
			ID="${2:-is_unset}"
			OPTION="$3"
			[ -d "$DIR/$ID" ] || return 1
			[ -n "$OPTION" ] && ELEMENT_LIST="$OPTION"
			echo "ID='$ID'"
			for ELEMENT in $ELEMENT_LIST; do {
				read VALUE <"$DIR/$ID/$ELEMENT"
				echo "$ELEMENT='$VALUE'"
			} done
		;;
		list)
			[ -d "$DIR" ] || return 1
			OPTION="$2"
			ARG="${3:-0}"
			
			case "$OPTION" in
				last)
					ls -1 "$DIR" 2>/dev/null | grep ^[0-9] | sort -n | tail -n "$ARG"
				;;
				*)
					ls -1 "$DIR" 2>/dev/null | grep ^[0-9] | sort -n
				;;
			esac
		;;
		index_gen)
			local INDEX="$DIR/meta_index"
			local CRC USERNAME PASSWORD PROFILE_ID ID

			for ID in $( _userdb login list ); do {
				eval $( _userdb login show $ID "USERNAME PASSWORD PROFILE_ID" )
				CRC="$( echo -n "$USERNAME$PASSWORD" | md5sum | cut -d' ' -f1 )"
				echo "$CRC $ID $PROFILE_ID $USERNAME $PASSWORD"
			} done >$INDEX

			cp $INDEX /www/cgi-bin/userdata.txt	# fixme!

			_log do $FUNC daemon info "$ACTION: wrote '$INDEX' and '/www/cgi-bin/userdata.txt'"

			_userdb backup
		;;
		index_show)
			local USERINDEX="$DIR/meta_index"
			cat $USERINDEX
		;;
	esac
}

_userdb_login_pdfout_digest ()							# max 32 on one A4-sheet
{										# fixme! calculate correct output size? (template_size - replaced_vars_templete + replaced_vars)
	local FUNC="userdb_login_pdfout_digest"
	local LIST_LOGIN_ID="$1"						# fixme! automatically print 2,3...pages each 35 tickets

	_log do $FUNC daemon info "[start] generating A4-page with these logins: '$LIST_LOGIN_ID'"
	
	local PDF_TEMPLATE="/www/images/userdb_ticket_template.pdf"
	local PDF_LINES_MAX="35"						# fixme! read it from PDF, not hardcode here
	local TEMP="/tmp/db_output_generate_$$"
	local SQLTEMP="/tmp/db_output_sqlquery_$$"
	local LINE WORD NUMBER
	local ID PROFILE_ID NAME INSTALLED USERNAME PASSWORD
	local COUNT=0

	local VAR_CREATOR="ekuku multispot"					# fixme!
	local VAR_SOURCE="quellenangabe"					# fixme!
	local VAR_HOTELNAME="$( _weblogin metadata_locationname )"		# Hotel Liszt in Weimar
	local WORD_USERLIST="WLAN-Benutzerliste: "

	local VAR_GENTIME							# unixtime
	local VAR_TICKETTYPE							# 24-Stunden-Tickets, 1-Wochen-Tickets, 1-Monats-Tickets
	for ID in $LIST_LOGIN_ID; do {
		eval $( _db user login show $ID "PROFILE_ID INSTALLED" )
		eval $( _db user profile show $PROFILE_ID NAME )
		VAR_TICKETTYPE="$NAME"
		VAR_GENTIME="$INSTALLED"		# _system date unixtime2date
		break
	} done

	local WORD_GENTIME="Zeitpunkt der automatischen Generierung: "		# fixme! 'automatischen' / 'manuellen'
	local VAR_GENHUMANDATE="$( _sanitizer do $( _system date humanreadable nice ) escape_single_quotes )"
	local WORD_USER="Benutzername"
	local WORD_PASS="Passwort"
	local WORD_ROOMANDGUEST="Zimmernummer \/ Gastname"			# sed-style
	local WORD_COMMENT="Kommentar"
	local VARLIST="VAR_CREATOR VAR_GENTIME VAR_SOURCE VAR_HOTELNAME WORD_USERLIST VAR_TICKETTYPE VAR_GENHUMANDATE WORD_GENTIME WORD_USER WORD_PASS WORD_ROOMANDGUEST WORD_COMMENT" 

	for WORD in $VARLIST; do {
		echo -n "-e 's/$WORD/$( eval echo \$$WORD )/g' "
	} done >$TEMP

	ID=;while :; do ID="$ID N";test ${#ID} -eq $(( $PDF_LINES_MAX * 2 )) && break; done 	# outputs: N N N N ... (filling up template-page)
	for ID in $LIST_LOGIN_ID $ID; do {

		COUNT=$(( $COUNT + 1 ))				# for calc
		NUMBER=$COUNT					# for print
		[ $COUNT -gt 32 ] && ID="N"			# maximum per page reached
		[ ${#COUNT} -eq 1 ] && NUMBER="0${COUNT}"

		case "$ID" in
			N) USERNAME=; PASSWORD= ;;
			*) eval $( _db user login show $ID "USERNAME PASSWORD" ) ;;
		esac

		echo -n "-e 's/USER${NUMBER}/$USERNAME/' -e 's/PASS${NUMBER}/$PASSWORD/' -e 's/GUEST${NUMBER}//' -e 's/COMMENT${NUMBER}//' "
		[ $NUMBER -eq $PDF_LINES_MAX ] && break

	} done >>$TEMP

	_log do $FUNC daemon info "[end] generating PDF to stdout ($COUNT tickets)"

	echo "sed $( cat $TEMP; rm $TEMP ) '$PDF_TEMPLATE'" >$TEMP

	sh $TEMP && rm $TEMP
}

_userdb_login_pdfout_marker ()
{
	local FUNC="userdb_login_pdfout_marker"
	local LIST_LOGIN_ID="$1"
	local FONTSIZE=18
	local NUMBER I N N1 N2 ID USERNAME PASSWORD XCOL1 XCOL2 XCOL3 XCOL4 XCOL5 YCOL

	_log do $FUNC daemon info "[start] generating A4-page with these logins: '$LIST_LOGIN_ID'"

	cat <<EOF
%PDF-1.7

1 0 obj  % entry point
<<
  /Type /Catalog
  /Pages 2 0 R
>>
endobj

2 0 obj
<<
  /Type /Pages
  /MediaBox [ 0 0 595 842 ]
  /Count 1
  /Kids [ 3 0 R ]
>>
endobj

3 0 obj
<<
  /Type /Page
  /Parent 2 0 R
  /Resources <<
    /Font <<
      /F1 4 0 R 
    >>
  >>
  /Contents 5 0 R
>>
endobj

4 0 obj
<<
  /Type /Font
  /Subtype /Type1
  /BaseFont /Times-Roman
>>
endobj

5 0 obj  % page content
<<
  /Length 44
>>
stream
EOF

	tenth ()	# SENS: 123 -> 12.3
	{
		local VALUE="$1"

		echo "$(( $VALUE / 10 )).$(( $VALUE % 10 ))"
	}

	xcol ()
	{
		local COLUMN="$1"
		local BEGIN="163"
		local OFFSET="1170"
		local X

		X=$(( $BEGIN + ( $OFFSET * ( $COLUMN - 1 ) ) ))

		tenth $X
	}

	yrow ()					# pdf-coord-system starts in lower/left border with 0/0
	{
		local ROW="$1"
		local OPTION="$2"		# nextline
		local BEGIN="300"
		local OFFSET="516"
		local OFFSET_NEXTLINE="160"
		local Y

		Y=$(( $BEGIN + ($OFFSET * ($ROW - 1) ) ))

		[ -n "$OPTION" ] && Y=$(( $Y - $OFFSET_NEXTLINE ))

		tenth $Y
	}

	XCOL1=$( xcol 1 )
	XCOL2=$( xcol 2 )
	XCOL3=$( xcol 3 )
	XCOL4=$( xcol 4 )
	XCOL5=$( xcol 5 )
	I=17			# counter for right yrow (increasing)

	for ID in $LIST_LOGIN_ID; do {

		NUMBER=$(( ${NUMBER:-0} + 1 ))

		if [ $NUMBER -gt 16 ]; then		# right yrow

			I=$(( $I -1 ))
			N=$I
			
			XCOL1=$XCOL4
			XCOL2=$XCOL5
		else
			N=$(( $I - $NUMBER ))		# left yrow
		fi

		YROW1="$( yrow $N )"
		YROW2="$( yrow $N nextline )"

		eval $( _userdb login show $ID "USERNAME PASSWORD" )

		cat <<EOF
BT $XCOL1 $YROW1 TD /F1 $FONTSIZE Tf ($USERNAME)Tj ET
BT $XCOL1 $YROW2 TD /F1 $FONTSIZE Tf ($PASSWORD)Tj ET
BT $XCOL2 $YROW1 TD /F1 $FONTSIZE Tf ($USERNAME)Tj ET
BT $XCOL2 $YROW2 TD /F1 $FONTSIZE Tf ($PASSWORD)Tj ET
EOF

	} done

	cat <<EOF
endstream
endobj

xref
0 6
0000000000 65535 f 
0000000010 00000 n 
0000000079 00000 n 
0000000173 00000 n 
0000000301 00000 n 
0000000380 00000 n 
trailer
<<
  /Size 6
  /Root 1 0 R
>>
startxref
492
%%EOF
EOF

	_log do $FUNC daemon info "[end] generating PDF to stdout ($NUMBER tickets)" 
}
