_userdb_backup ()
{
	:	# automatically call this after <prio> changes
}

_userdb_restore ()
{
	:	# automatically call this after reboot
}

_userdb_query ()
{
	:
	# samples:
	# query_login_valid? (return % of used time/traffic?)
	# update_device_traffic
	# update_device_time
}

_userdb_stats ()
{
	local TABLE
	
	for TABLE in profile login device; do {
		
		echo "TABLE: '$TABLE'"
		
		if [ -n "$( _userdb $TABLE list )" ]; then
			_userdb $TABLE list
		else
			echo "# empty table '$TABLE'"
		fi
	} done
}

# fixme! email fuer tickets.pdf?
# fixme! free_intranet? 
# fixme! entscheidung zwischen echtzeit-ablauf und reine nutzungszeit-ablauf (profil)
# fixme! _userdb profile_lastid() + wenn man loescht luecken auffuellen?

_userdb_profile ()			# idea: allow configurable UPnP, P2P, QOS, ROAMING?
{
	local ACTION="$1"		# ARG1: string -> <empty>, add, del, list, update, id2name, name2id
	
	local DIR="/tmp/USERDB/PROFILE"
	local FUNC="userdb_profile"
	local ELEMENT VALUE
	local ELEMENT_LIST="NAME COMMENT AUTOGENERATE TIME_MODEL MAX_TIME MAX_TRAFFIC MAX_SPEED_UP MAX_SPEED_DOWN LANDING_URL COST CURRENCY"
	
	local ID			# autoincrement
	local NAME
	local COMMENT
	local AUTOGENERATE		# [bool]
	local TIME_MODEL		# [bool] used_time = unset/0 - passed_time = 1
	local MAX_TIME			# [min] -> autogenerate some keywords?, e.g. 1week, 24h, 1month ...
	local MAX_TRAFFIC		# [kb]
	local MAX_SPEED_UP		# [kb/s]
	local MAX_SPEED_OWN		# [kb/s]	// empty on MAX_* means: nolimit/unlimited
	local LANDING_URL
	local COST
	local CURRENCY			# ?

	case "$ACTION" in
		"")
			echo "Usage: _$FUNC	add <name> <comment> <autogenerate=0|1> <time_model=0|1=used/passed> <max_time> <tim<max_traffic> <max_speed_up> <max_speed_down> <landing_url> <cost> <currency>"
			echo "			update <id> <same_args_like_add>"
			echo "			del <id>"
			echo "			show <id> <specific_elements>"
			echo "			list"
			echo "			id2name <id>"
			echo "			name2id <name>"
		;;
		add|update)
			if [ "$ACTION" = "update" ]; then			# fixme! don't touch values, if "=" is given
				ID="$2"
				[ -z "$ID" ] && return
				shift
			else
				read ID 2>/dev/null <"$DIR/meta_maxid"
				ID="$(( ${ID:-0} + 1 ))"			# autoincrement
				mkdir -p "$DIR"
				echo -n >"$DIR/meta_maxid" "$ID"
			fi

			NAME="${2:-unset_name_$$}"
			COMMENT="$3"
			AUTOGENERATE="$4"
			TIME_MODEL="$5"
			MAX_TIME="$6"
			MAX_TRAFFIC="$7"
			MAX_SPEED_UP="$8"
			MAX_SPEED_DOWN="$9"
			LANDING_URL="${10}"
			COST="${11}"
			CURRENCY="${12}"		# ${13}

			_log do $FUNC daemon debug "$ACTION - ID: $ID NAME: $NAME COMMENT: $COMMENT AUTOGENERATE: $AUTOGENERATE TIME_MODEL: $TIME_MODEL MAX_TIME: $MAX_TIME MAX_TRAFFIC: $MAX_TRAFFIC MAX_SPEED_UP: $MAX_SPEED_UP MAX_SPEED_DOWN: $MAX_SPEED_DOWN LANDING_URL: $LANDING_URL COST: $COST CURRENCY: $CURRENCY"

			mkdir -p "$DIR/$ID"					# each profile has it own dir
			for ELEMENT in $ELEMENT_LIST; do {
				eval "VALUE=\"\$${ELEMENT}\""
				echo -n >"$DIR/$ID/$ELEMENT" "$VALUE"
			} done
		;;
		del)
			ID="${2:-is_unset}"
			[ -d "$DIR/$ID" ] || return 1
			_log do $FUNC daemon info "$ACTION - removing ID '$ID'"
			rm -fR "$DIR/$ID"					# fixme! check, if referenced in logins
		;;
		show)
			ID="${2:-is_unset}"
			OPTION="$3"
			[ -d "$DIR/$ID" ] || return 1
			[ -n "$OPTION" ] && ELEMENT_LIST="$OPTION"
			echo "ID='$ID'"
			for ELEMENT in $ELEMENT_LIST; do {
				read VALUE <"$DIR/$ID/$ELEMENT"
				echo "$ELEMENT='$VALUE'"
			} done
		;;
		list)
			[ -d "$DIR" ] || return 1
			ls -1 "$DIR" 2>/dev/null | grep ^[0-9] | sort -n
		;;
		id2name)
			ID="$2"
			cat 2>/dev/null "$DIR/$ID/NAME" || return 1
		;;
		name2id)
			[ 2>/dev/null "${2:-unset}" -gt 0 ] && { 		# is_numeric? -> already ID
				[ -e "$DIR/$2/NAME" ] || return 1
				echo $2
				return 0
			}
			
			for FILE in $( find "$DIR" -type d ); do {
				[ -e "$FILE/NAME" ] && {
					read NAME <"$FILE/NAME"
					
					[ "$NAME" = "${2:-$NAME}" ] && {	# empty 'name' means: output any/first profile_name
						basename $FILE
						return
					}
				}
			} done
		;;
	esac
}

_userdb_device ()
{
	local ACTION="$1"
	local DIR="/tmp/USERDB/DEVICE"
	local FUNC="userdb_device"
	local ELEMENT VALUE
	local ELEMENT_LIST="USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION"

	local ID			# autoincrement
	local USER_ID
	local MAC			# lowercase + : e.g. 00:11:22:aa:bb:cc
	local DEVTYPE			# wifi, wire
	local LANG			# like i18n
	local FIRSTSEEN			# [unixtime]
	local LASTSEEN			# [unixtime]
	local USED_TRAFFIC		# [kb]
	local USED_TIME			# [min]
	local USED_TRAFFIC_TODAY	# [kb]
	local USED_TIME_TODAY		# [min]
	local ISOLATION			# [bool]

	case "$ACTION" in
		"")
			echo "Usage: _$FUNC	add <user_id> <mac> <devtype> <language> <firstseen> <lastseen> <used_traffic> <used_time> <used_traffic_today> <used_time_today> <isolation>"
			echo "			update <id> <same_args_like_add>"
			echo "			del <id>"
			echo "			show <id>"
			echo "			list"
		;;
		add|update)
			if [ "$ACTION" = "update" ]; then			# fixme! don't touch values, if "=" is given
				ID="$2"
				shift
			else
				read ID 2>/dev/null <"$DIR/meta_maxid"
				ID="$(( ${ID:-0} + 1 ))"			# autoincrement
				mkdir -p "$DIR"
				echo -n >"$DIR/meta_maxid" "$ID"
			fi

			USER_ID="$2"
			MAC="$3"
			DEVTYPE="$4"						# just for stats
			LANG="$5"						# empty means fallback to default lang, e.g. in weblogin
			FIRSTSEEN="$8"						# should be empty, if never seen
			LASTSEEN="$7"						# should be empty, if never seen
			USED_TRAFFIC="$8"
			USED_TIME="$9"
			USED_TRAFFIC_TODAY="${10}"
			USED_TIME_TODAY="${11}"
			ISOLATION="${12}"

			_log do $FUNC daemon debug "$ACTION - ID: $ID USER_ID: $USER_ID MAC: $MAC DEVTYPE: $DEVTYPE LANG: $LANG FIRSTSEEN: $FIRSTSEEN LASTSEEN: $LASTSEEN USED_TRAFFIC: $USED_TRAFFIC USED_TIME: $USED_TIME USED_TRAFFIC_TODAY: $USED_TRAFFIC_TODAY USED_TIME_TODAY: $USED_TIME_TODAY ISOLATION: $ISOLATION"

			mkdir -p "$DIR/$ID"					# each profile has it own dir
			for ELEMENT in $ELEMENT_LIST; do {
				eval "VALUE=\"\$${ELEMENT}\""
				echo -n >"$DIR/$ID/$ELEMENT" "$VALUE"
			} done
		;;
		del)
			ID="${2:-is_unset}"
			[ -d "$DIR/$ID" ] || return 1
			_log do $FUNC daemon info "$ACTION - removing ID '$ID'"
			rm -fR "$DIR/$ID"
		;;
		show)
			ID="${2:-is_unset}"
			[ -d "$DIR/$ID" ] || return 1
			echo "ID='$ID'"
			for ELEMENT in $ELEMENT_LIST; do {
				read VALUE <"$DIR/$ID/$ELEMENT"
				echo "$ELEMENT='$VALUE'"
			} done
		;;
		list)
			[ -d "$DIR" ] || return 1
			ls -1 "$DIR" 2>/dev/null | grep ^[0-9] | sort -n
		;;
	esac
}

_userdb_login_autocreate ()
{
	local PROFILE="$1"			# name or ID
	local COUNTER="${2:-35}"		# 35 are fitting on 1 PDF (A4-sheet)
	local I=0
	local UNIXTIME="$( _system date unixtime )"
	
	while [ $I -lt $COUNTER ]; do {
		I=$(( $I + 1 ))
		_userdb login add "$1" "" "" "" "1" "$UNIXTIME"
	} done
}

_userdb_login ()
{
	local ACTION="$1"		# ARG1: string -> <empty>, add, del, list, update, gen_index
	local DIR="/tmp/USERDB/LOGIN"
	local FUNC="userdb_login"
	local ELEMENT VALUE	
	local ELEMENT_LIST="PROFILE_ID COMMENT USERNAME PASSWORD DEVICE_QUANTITY INSTALLED"

	local ID			# autoincrement
	local PROFILE_ID
	local COMMENT
	local USERNAME			# namespace from mydesign or explicit
	local PASSWORD
	local DEVICE_QUANTITY		# how many
	local INSTALLED			# [unixtime]

	case "$ACTION" in
		"")
			echo "Usage: _$FUNC	add <profile_id> <comment> <username> <password> <device_quantity> <installed_unixtime>"
			echo "			update <id> <plus_same_args_like_add>"
			echo "			del <login_id>"
			echo "			show <id>"
			echo "			list"
			echo "			gen_index"
		;;
		add|update)							# fixme! also save ID in $DIR ?
			if [ "$ACTION" = "update" ]; then			# fixme! don't touch values, if "=" is given
				ID="$2"
				[ -z "$ID" ] && return 1
				shift
			else
				read ID 2>/dev/null <"$DIR/meta_maxid"
				ID="$(( ${ID:-0} + 1 ))"			# autoincrement
				mkdir -p "$DIR"
				echo -n >"$DIR/meta_maxid" "$ID"
			fi
			
			PROFILE_ID="$( _userdb profile name2id "$2" )" || return 1	# name -> autoconvert to ID
			COMMENT="$3"
			USERNAME="${4:-$( _random_username do )}"
			PASSWORD="${5:-$( _math random_integer 1 99999 fillup )}"
			DEVICE_QUANTITY="${6:-1}"
			INSTALLED="${7:-$( _system date unixtime)}"

			_log do $FUNC daemon debug "$ACTON - ID: $ID PROFILE_ID: $PROFILE_ID COMMENT: $COMMENT USERNAME: $USERNAME PASSWORD: $PASSWORD DEVICE_QUANTITY: $DEVICE_QUANTITY INSTALLED: $INSTALLED"

			mkdir -p "$DIR/$ID"					# each login has it own dir

			for ELEMENT in $ELEMENT_LIST; do {
				eval "VALUE=\"\$${ELEMENT}\""
				echo -n >"$DIR/$ID/$ELEMENT" "$VALUE"
			} done
		;;
		del)
			ID="${2:-is_unset}"
			[ -d "$DIR/$ID" ] || return 1
			_log do $FUNC daemon info "$ACTION - removing ID '$ID'"
			rm -fR "$DIR/$ID"
		;;
		show)
			ID="${2:-is_unset}"
			OPTION="$3"
			[ -d "$DIR/$ID" ] || return 1
			[ -n "$OPTION" ] && ELEMENT_LIST="$OPTION"
			echo "ID='$ID'"
			for ELEMENT in $ELEMENT_LIST; do {
				read VALUE <"$DIR/$ID/$ELEMENT"
				echo "$ELEMENT='$VALUE'"
			} done
		;;
		list)
			[ -d "$DIR" ] || return 1
			OPTION="$2"
			ARG="${3:-0}"
			
			case "$OPTION" in
				last)
					ls -1 "$DIR" 2>/dev/null | grep ^[0-9] | sort -n | tail -n "$ARG"
				;;
				*)
					ls -1 "$DIR" 2>/dev/null | grep ^[0-9] | sort -n
				;;
			esac
		;;
		gen_index)							# fixme! write to /tmp/USERDB/LOGIN/meta_index
			local USERINDEX="/www/cgi-bin/userdata.txt"
			local CRC
			
			ls -1 "$DIR" | sort -n | while read ID; do {
				[ -d "$DIR/$ID" ] && {
					read USERNAME	<"$DIR/$ID/USERNAME"
					read PASSWORD	<"$DIR/$ID/PASSWORD"
					read PROFILE_ID	<"$DIR/$ID/PROFILE_ID"
				
					CRC="$( echo -n "$USERNAME$PASSWORD" | md5sum | cut -d' ' -f1 )"
					
					echo "$CRC $ID $PROFILE_ID $USERNAME $PASSWORD"
				}
			} done
		;;
	esac
}

_userdb_login_pdfout ()								# max 35 on one A4-sheet
{										# fixme! calculate correct output size? (template_size - replaced_vars_templete + replaced_vars)
	local FUNC="userdb_login_pdfout"
	local LIST_LOGIN_ID="$1"						# fixme! automatically print 2,3...pages each 35 tickets

	_log do $FUNC daemon info "[start] generating A4-page with these logins: '$LIST_LOGIN_ID'"
	
	local PDF_TEMPLATE="/www/images/userdb_ticket_template.pdf"
	local PDF_LINES_MAX="35"						# fixme! read it from PDF, not hardcode here
	local TEMP="/tmp/db_output_generate_$$"
	local SQLTEMP="/tmp/db_output_sqlquery_$$"
	local LINE WORD NUMBER
	local ID PROFILE_ID NAME INSTALLED USERNAME PASSWORD
	local COUNT=0

	local VAR_CREATOR="ekuku multispot"					# fixme!
	local VAR_SOURCE="quellenangabe"					# fixme!
	local VAR_HOTELNAME="$( _weblogin metadata_locationname )"		# Hotel Liszt in Weimar
	local WORD_USERLIST="WLAN-Benutzerliste: "

	local VAR_GENTIME							# unixtime
	local VAR_TICKETTYPE							# 24-Stunden-Tickets, 1-Wochen-Tickets, 1-Monats-Tickets
	for ID in $LIST_LOGIN_ID; do {
		eval $( _userdb login show $ID "PROFILE_ID INSTALLED" )
		eval $( _userdb profile show $PROFILE_ID NAME )
		VAR_TICKETTYPE="$NAME"
		VAR_GENTIME="$INSTALLED"		# _system date unixtime2date
		break
	} done

	local WORD_GENTIME="Zeitpunkt der automatischen Generierung: "		# fixme! 'automatischen' / 'manuellen'
	local VAR_GENHUMANDATE="$( _sanitizer do $( _system date humanreadable nice ) escape_single_quotes )"
	local WORD_USER="Benutzername"
	local WORD_PASS="Passwort"
	local WORD_ROOMANDGUEST="Zimmernummer \/ Gastname"			# sed-style
	local WORD_COMMENT="Kommentar"
	local VARLIST="VAR_CREATOR VAR_GENTIME VAR_SOURCE VAR_HOTELNAME WORD_USERLIST VAR_TICKETTYPE VAR_GENHUMANDATE WORD_GENTIME WORD_USER WORD_PASS WORD_ROOMANDGUEST WORD_COMMENT" 

	for WORD in $VARLIST; do {
		echo -n "-e 's/$WORD/$( eval echo \$$WORD )/g' "
	} done >$TEMP

	ID=;while :; do ID="$ID N";test ${#ID} -eq $(( $PDF_LINES_MAX * 2 )) && break; done 	# outputs: N N N N ... (filling up template-page)
	for ID in $LIST_LOGIN_ID $ID; do {

		COUNT=$(( $COUNT + 1 ))				# for calc
		NUMBER=$COUNT					# for print
		[ ${#COUNT} -eq 1 ] && NUMBER="0${COUNT}"

		case "$ID" in
			N) USERNAME=; PASSWORD= ;;
			*) eval $( _userdb login show $ID "USERNAME PASSWORD" ) ;;
		esac

		echo -n "-e 's/USER${NUMBER}/$USERNAME/' -e 's/PASS${NUMBER}/$PASSWORD/' -e 's/GUEST${NUMBER}//' -e 's/COMMENT${NUMBER}//' "
		[ $NUMBER -eq $PDF_LINES_MAX ] && break

	} done >>$TEMP

	_log do $FUNC daemon info "[end] generating PDF to stdout ($COUNT tickets)"

	echo "sed $( cat $TEMP; rm $TEMP ) '$PDF_TEMPLATE'" >$TEMP

	sh $TEMP && rm $TEMP
}
